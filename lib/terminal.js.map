{"version":3,"sources":["webpack://Terminal/webpack/universalModuleDefinition","webpack://Terminal/webpack/bootstrap","webpack://Terminal/./node_modules/balanced-match/index.js","webpack://Terminal/./node_modules/brace-expansion/index.js","webpack://Terminal/./node_modules/concat-map/index.js","webpack://Terminal/./node_modules/get-options/index.js","webpack://Terminal/./node_modules/immutable/dist/immutable.es.js","webpack://Terminal/./node_modules/minimatch-capture/index.js","webpack://Terminal/./node_modules/minimatch/minimatch.js","webpack://Terminal/./node_modules/path-browserify/index.js","webpack://Terminal/./node_modules/process/browser.js","webpack://Terminal/./src/commands sync ^\\.\\/.*$","webpack://Terminal/./src/commands/cat.js","webpack://Terminal/./src/commands/cd.js","webpack://Terminal/./src/commands/clear.js","webpack://Terminal/./src/commands/cp.js","webpack://Terminal/./src/commands/echo.js","webpack://Terminal/./src/commands/head.js","webpack://Terminal/./src/commands/history.js","webpack://Terminal/./src/commands/index.js","webpack://Terminal/./src/commands/ls.js","webpack://Terminal/./src/commands/mkdir.js","webpack://Terminal/./src/commands/printenv.js","webpack://Terminal/./src/commands/pwd.js","webpack://Terminal/./src/commands/rm.js","webpack://Terminal/./src/commands/rmdir.js","webpack://Terminal/./src/commands/tail.js","webpack://Terminal/./src/commands/touch.js","webpack://Terminal/./src/commands/util/_head_tail_util.js","webpack://Terminal/./src/commands/whoami.js","webpack://Terminal/./src/emulator-output/index.js","webpack://Terminal/./src/emulator-output/output-factory.js","webpack://Terminal/./src/emulator-output/output-type.js","webpack://Terminal/./src/emulator-state/EmulatorState.js","webpack://Terminal/./src/emulator-state/command-mapping.js","webpack://Terminal/./src/emulator-state/environment-variables.js","webpack://Terminal/./src/emulator-state/file-system.js","webpack://Terminal/./src/emulator-state/history.js","webpack://Terminal/./src/emulator-state/index.js","webpack://Terminal/./src/emulator-state/outputs.js","webpack://Terminal/./src/emulator-state/util.js","webpack://Terminal/./src/emulator/auto-complete.js","webpack://Terminal/./src/emulator/command-runner.js","webpack://Terminal/./src/emulator/emulator-error.js","webpack://Terminal/./src/emulator/index.js","webpack://Terminal/./src/emulator/plugins/BoundedHistoryIterator.js","webpack://Terminal/./src/emulator/plugins/HistoryKeyboardPlugin.js","webpack://Terminal/./src/fs/fs-error.js","webpack://Terminal/./src/fs/index.js","webpack://Terminal/./src/fs/operations-with-permissions/directory-operations.js","webpack://Terminal/./src/fs/operations-with-permissions/file-operations.js","webpack://Terminal/./src/fs/operations/base-operations.js","webpack://Terminal/./src/fs/operations/directory-operations.js","webpack://Terminal/./src/fs/operations/file-operations.js","webpack://Terminal/./src/fs/util/file-util.js","webpack://Terminal/./src/fs/util/glob-util.js","webpack://Terminal/./src/fs/util/path-util.js","webpack://Terminal/./src/fs/util/permission-util.js","webpack://Terminal/./src/index.js","webpack://Terminal/./src/parser/command-parser.js","webpack://Terminal/./src/parser/index.js","webpack://Terminal/./src/parser/option-parser.js"],"names":["fileToTextOutput","fs","filePath","FileOp","readFile","err","file","OutputFactory","makeErrorOutput","makeTextOutput","get","optDef","state","commandOptions","argv","length","filePaths","map","pathArg","outputs","path","getFileSystem","updateStateCwd","newCwdPath","EnvVariableUtil","setEnvironmentVariable","getEnvVariables","DirectoryOp","hasDirectory","newCwdPathDoesNotExistErr","fsErrorType","NO_SUCH_DIRECTORY","output","setEnvVariables","setOutputs","copySourceFile","srcPath","destPath","isTrailingPathDest","dirAtTrailingPathNonExistentErr","copyFile","copiedFS","setFileSystem","copySourceDirectory","lastPathComponent","PathUtil","getLastPathPart","emptyDir","FileUtil","makeDirectory","addDirectory","copyDirectory","options","isTrailingDestPath","isTrailingPath","recursive","VARIABLE_GROUP_REGEX","DOUBLE_SPACE_REGEX","substituteEnvVariables","environmentVariables","inputStr","replace","match","varName","input","join","outputStr","cleanStr","trim","headTrimmingFn","lines","lineCount","slice","content","clearStateHistory","setHistory","stringifyStateHistory","getHistory","clear","commandNames","reduce","mapping","commandName","require","IMPLIED_DIRECTORY_ENTRIES","resolveDirectoryToList","envVariables","cwd","getEnvironmentVariable","toAbsolutePath","makeSortedReturn","listing","sortedListing","sort","removeHiddenFilesFilter","record","startsWith","dirPath","listDirectory","dirList","list","all","concat","almostAll","filter","EMPTY_DIR","newFolderPath","DirOp","stringifyEnvVariables","varVal","varKey","varValue","makeNoPathErrorOutput","noSuchFileOrDirError","NO_SUCH_FILE_OR_DIRECTORY","deletionPath","noPreserveRoot","has","deleteDirectory","deleteFile","deletedPathFS","pathToDelete","tailTrimmingFn","EMPTY_FILE","makeFile","writeFile","DEFAULT_LINE_COUNT","trimFileContent","trimmingFn","linesCount","Number","trimmedLines","split","FALLBACK_USERNAME","OutputType","OutputRecord","type","undefined","makeHeaderOutput","command","HEADER_OUTPUT_TYPE","TEXT_OUTPUT_TYPE","TEXT_ERROR_OUTPUT_TYPE","source","FS_KEY","ENVIRONMENT_VARIABLES_KEY","HISTORY_KEY","OUTPUTS_KEY","COMMAND_MAPPING_KEY","EmulatorState","immutable","Map","Error","_immutable","getImmutable","newFileSystem","set","newEnvVariables","newHistory","newOutputs","newCommandMapping","toJS","create","history","commandMapping","stateMap","defaultCommandMapping","Object","keys","hasOwnProperty","isCommandSet","setCommand","commandFn","unsetCommand","getCommandFn","getCommandOptDef","getCommandNames","keySeq","defaultVariables","key","val","unsetEnvironmentVariable","DEFAULT_FILE_SYSTEM","jsFs","fillGaps","entries","Stack","of","recordCommand","commandRun","push","CommandMapping","EnvironmentVariables","FileSystem","History","Outputs","addRecord","outputRecord","Record","isRecord","resolvePath","suggestCommands","cmdMapping","partialStr","commandNameSeq","GlobUtil","globSeq","suggestCommandOptions","optDefSeq","flatMap","opts","opt","suggestFileSystemNames","fileSystem","completeNamePattern","completeSubfolderPattern","globPattern","endsWith","childPaths","globPaths","isAbsPath","pathPartsWithoutTail","toPathParts","newTail","toPath","makeRunnerErrorOutput","errorType","run","commandArgs","errorStr","emulatorErrorType","COMMAND_NOT_FOUND","notFoundCallback","CommandMappingUtil","fatalCommandError","UNEXPECTED_COMMAND_FAILURE","makeError","message","Emulator","suggestions","suggest","strParts","List","autocompletedText","update","lastVal","_trimLeadingSpace","lastPartialChar","isTypingNewPart","_getBoundaryWords","cmdName","start","lastTextEntered","end","getCommandMapping","strToComplete","str","executionListeners","executionListener","onExecuteStarted","_addHeaderOutput","_addCommandOutputs","_addCommandToHistory","_updateStateByExecution","onExecuteCompleted","commandStrToExecute","CommandRunner","nextState","commandStr","getOutputs","BoundedHistoryIterator","historyStack","index","size","hasUp","hasDown","HistoryKeyboardPlugin","_nullableHistoryIterator","createHistoryIteratorIfNull","up","down","FILE_EXISTS","DIRECTORY_EXISTS","DIRECTORY_NOT_EMPTY","NO_SUCH_FILE","FILE_OR_DIRECTORY_EXISTS","IS_A_DIRECTORY","NOT_A_DIRECTORY","PERMISSION_DENIED","OTHER","makeDirectoryOperationPermissionError","DirectoryOperations","listDirectoryFiles","listDirectoryFolders","PermissionUtil","canModifyPath","args","renameDirectory","currentPath","newPath","makeFileOperationPermissionError","hasFile","FileOperations","sourcePath","add","pathToAdd","fsElementToAdd","addParentPaths","parentPaths","getPathBreadCrumbs","parentPath","addedDirectoryFs","remove","pathToRemove","isNonEmptyDirectoryRemovable","childPathPattern","isEmpty","removeAll","onlyFilesFilter","isFile","onlyDirectoriesFilter","isDirectory","emptyDirectory","directoryGapPaths","withMutations","directoryGapPath","filesPattern","captureGlobPaths","isTrailingSlashAppended","foldersPattern","folderNames","folderName","addTrailingSlash","listFileErr","fileList","listFolderErr","folderList","dir","getPathParent","BaseOp","isPathTypeMatching","pathSeq","overwrite","srcChildPattern","srcPaths","srcSubPaths","destPaths","zip","newFs","possibleFile","pathParent","sourceFileName","metadata","GLOB_OPTIONS","dot","glob","seq","filterCondition","captures","pathCaptures","removeTrailingSeparator","pathParts","nonRootPathParts","secondPathPart","pathPartsWithoutRoot","breadCrumbs","pathPart","previousBreadCrumb","pathPartsWithoutFileName","splitFilePath","GO_UP","CURRENT_DIR","isStackAtRootDirectory","stack","relativePath","pathStack","pop","DEFAULT_PERMISSION","isModificationAllowed","directory","canModify","breadCrumbPaths","breadCrumbPath","removeExcessWhiteSpace","toCommandParts","parseCommands","commands","OptionParser","parseOptions","noAliasPropagation"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;QCVA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;AC1DA,gBAAgB,mBAAO,CAAC,sDAAY;AACpC,eAAe,mBAAO,CAAC,8DAAgB;;AAEvC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;AACA,mCAAmC;AACnC,oCAAoC;AACpC;AACA;AACA;;;AAGA;AACA;AACA,wCAAwC,GAAG,IAAI;AAC/C;AACA;AACA;;AAEA;AACA,qBAAqB,KAAK;;AAE1B;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,aAAa;AAClC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B,uCAAuC,GAAG;AAC1C,YAAY,GAAG,yBAAyB;AACxC;AACA;AACA,8BAA8B;AAC9B,cAAc,GAAG;AACjB;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,KAAK;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ,EAAE;AACV,2BAA2B;AAC3B,sBAAsB;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,YAAY,KAAK,QAAQ,EAAE,IAAI,EAAE;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,mCAAmC,2BAA2B;AAC9D;;AAEA,iBAAiB,cAAc;AAC/B,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACvMA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACZa;;AAEb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,aAAa;AACzB,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,cAAc;AACnC,UAAU,EAAE;AACZ;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA,6CAA6C,cAAc;AAC3D;AACA;AACA,SAAS,yBAAyB;AAClC;AACA;;;AAGA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;;;;AAIA;AACA,0BAA0B,YAAY;AACtC;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,kBAAkB;AAC7B,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,SAAS;AACpB,YAAY;AACZ;AACA;AACA;AACA;AACA,iCAAiC,OAAO;AACxC;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,QAAQ,OAAO;;AAEf,qBAAqB;AACrB,qBAAqB;AACrB,wBAAwB;;AAExB,eAAe,YAAY;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO,WAAW;AAC7B,YAAY;AACZ;AACA;AACA,oCAAoC;AACpC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC,OAAO;AACxC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yCAAyC;AACzC;AACA;;AAEA;AACA;;AAEA,mDAAmD;AACnD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,cAAc;AACzB,WAAW,OAAO,WAAW;AAC7B;AACA,kDAAkD;;AAElD;AACA;AACA,UAAU,WAAW;;AAErB;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;;AAEA;AACA;AACA,+CAA+C,KAAK;AACpD,kBAAkB,KAAK;AACvB;;AAEA;AACA;AACA,+CAA+C,KAAK;AACpD,kBAAkB,KAAK;AACvB;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA,6CAA6C;AAC7C;AACA;;AAEA,4CAA4C;AAC5C;AACA;AACA;;AAEA,iCAAiC;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA,kEAAkE,KAAK,kBAAkB,sBAAsB;AAC/G;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU,MAAM;;AAEhB;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA,kCAAkC,OAAO;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC,eAAe;AACpD;AACA,wCAAwC,YAAY,SAAS,eAAe;AAC5E;AACA;;;AAGA;AACA;;AAEA;AACA,uCAAuC,mCAAmC;;AAE1E,kCAAkC,OAAO;AACzC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,KAAK;AACzC,0BAA0B,KAAK;AAC/B;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA,iCAAiC,OAAO;AACxC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,0CAA0C;AAC1C,sDAAsD;AACtD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;;;;;;;;;;;;ACttBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,UAAU;AACV;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iCAAiC,KAAK;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,CAAC;;AAED;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf,eAAe;AACf;AACA;AACA;AACA,+EAA+E;AAC/E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,+CAA+C,uCAAuC;AACtF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,6CAA6C,kDAAkD;AAC/F;AACA;AACA;;AAEA;AACA;;AAEA,iDAAiD,yBAAyB,EAAE;AAC5E;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,yDAAyD,EAAE;AAC/E;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,8CAA8C,yBAAyB,EAAE;AACzE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA,mCAAmC,mBAAmB;AACtD;AACA,0DAA0D;AAC1D,yCAAyC,6BAA6B;AACtE;AACA;AACA,qCAAqC,iCAAiC;AACtE,0CAA0C,4BAA4B;AACtE;AACA;AACA;;AAEA,iDAAiD,mCAAmC,EAAE;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uCAAuC,4BAA4B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,+DAA+D,EAAE;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,0CAA0C,mBAAmB;AAC7D;AACA;AACA;AACA,0CAA0C,0BAA0B;AACpE;AACA;AACA;AACA,sDAAsD,8DAA8D;AACpH,yCAAyC,iDAAiD;AAC1F,gDAAgD,mCAAmC;AACnF;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,uEAAuE,EAAE;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,4EAA4E,cAAc,EAAE;AAC5F,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6DAA6D;AACjF;AACA,GAAG;AACH;AACA,oCAAoC,uCAAuC,EAAE;AAC7E;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B,6EAA6E;AACvG;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL,0BAA0B,qBAAqB,EAAE;;AAEjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B,uDAAuD,EAAE;AACnF;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB,8CAA8C,EAAE;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+DAA+D,EAAE;AAC3F;AACA;AACA,gCAAgC,8CAA8C,EAAE;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sCAAsC,EAAE;AACpE,+BAA+B,qDAAqD,EAAE;AACtF;AACA;AACA,4CAA4C,+CAA+C,EAAE;AAC7F;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oDAAoD,eAAe,EAAE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sEAAsE;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,iBAAiB,EAAE;AAC/D,oDAAoD,eAAe,EAAE,6BAA6B,eAAe,EAAE;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,gBAAgB,EAAE;AACrE;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,UAAU;AAC5B;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,wBAAwB;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;;AAEA;AACA,6DAA6D,cAAc,EAAE;AAC7E;;AAEA;AACA;AACA;;AAEA;AACA,oDAAoD,gBAAgB,EAAE;AACtE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kEAAkE;AACjG;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,2DAA2D,mCAAmC,EAAE;AAChG;;AAEA;AACA;AACA;;AAEA,2DAA2D,uCAAuC;AAClG;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,sBAAsB,EAAE;AAClE,WAAW;AACX;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,iCAAiC,KAAK;AACtC;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yCAAyC,wBAAwB,EAAE;AACnE,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,UAAU;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAQ,WAAW;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW;AACX;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,UAAU;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ,WAAW;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,iDAAiD,gBAAgB;AACjE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+CAA+C,gBAAgB;AAC/D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+CAA+C,UAAU;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,aAAa;AAC/B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,aAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,uBAAuB,EAAE;AAC7D,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oBAAoB;AAC1C;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,oBAAoB;AAC1C;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,sCAAsC,yBAAyB,EAAE,EAAE,EAAE;AACxG,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,eAAe;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,sBAAsB,EAAE;AAClE,WAAW;AACX;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wCAAwC,KAAK;AAC7C;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,wBAAwB,gDAAgD,EAAE;AAC1E;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,yCAAyC,EAAE;AAC9F;AACA;AACA,+BAA+B,iBAAiB,EAAE;AAClD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,yBAAyB,yBAAyB,EAAE;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,mBAAmB,EAAE;AAC5D,WAAW;AACX;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,KAAK;AACtC;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,wCAAwC,0BAA0B,EAAE;AACpE,qCAAqC,uBAAuB,EAAE;AAC9D,KAAK;AACL;;AAEA;AACA;AACA;;AAEA,uCAAuC,qBAAqB,EAAE;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mBAAmB;AACzC,8DAA8D,uBAAuB,EAAE;AACvF;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,uCAAuC,+BAA+B,EAAE;AACxE;AACA;AACA,wCAAwC,6BAA6B,EAAE;AACvE;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,uCAAuC,+BAA+B,EAAE;AACxE;AACA;AACA,sCAAsC,6BAA6B,EAAE;AACrE;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,6CAA6C,yBAAyB,EAAE;AACxE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA,uCAAuC,+BAA+B,EAAE;AACxE,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA,GAAG;;AAEH;AACA,+EAA+E,aAAa,EAAE;AAC9F,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,2BAA2B;AAC3E;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA,wCAAwC,2BAA2B,EAAE;AACrE,GAAG;;AAEH;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA,wCAAwC,6BAA6B,EAAE;AACvE,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA,0CAA0C,+BAA+B,EAAE;AAC3E,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA,GAAG;;AAEH;;AAEA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B,2DAA2D,EAAE;AAC3F;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B,2CAA2C,EAAE;AAC3E;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA,6DAA6D,+CAA+C;;AAE5G;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,qCAAqC,sBAAsB,EAAE;AAC7D,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0DAA0D;AAC1D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,mBAAmB,EAAE;AAC5D,WAAW;AACX;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wCAAwC,KAAK;AAC7C;;AAEA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kCAAkC;AAClC;AACA;AACA,kCAAkC,SAAS;AAC3C;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0DAA0D,2BAA2B,EAAE;AACvF;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,2EAA2E;AAC3E;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,2DAA2D;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEe,wEAAS,EAAC;AACmV;;;;;;;;;;;;;ACzrLhW;;AAEZ,kBAAkB,mBAAO,CAAC,wDAAW;AACrC,sCAAsC,IAAI;AAC1C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA,0BAA0B;AAC1B;;;;;;;;;;;;ACvGA;AACA;;AAEA,YAAY;AACZ;AACA,SAAS,mBAAO,CAAC,qDAAM;AACvB,CAAC;;AAED;AACA,aAAa,mBAAO,CAAC,gEAAiB;;AAEtC;AACA,QAAQ,uCAAuC;AAC/C,QAAQ,2BAA2B;AACnC,QAAQ,2BAA2B;AACnC,QAAQ,2BAA2B;AACnC,QAAQ;AACR;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,yCAAyC,IAAI;;AAE7C;AACA;AACA;;AAEA;AACA,gCAAgC;;AAEhC,aAAa;AACb;AACA;AACA;AACA;AACA,GAAG,IAAI;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;AACL,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK,IAAI;AACT,KAAK,GAAG;AACR,KAAK,KAAK;AACV,KAAK,IAAI,IAAI,EAAE;AACf,KAAK,IAAI,EAAE,IAAI;AACf;AACA;AACA,KAAK,IAAI,OAAO,IAAI;AACpB,KAAK,EAAE,OAAO,EAAE;AAChB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sBAAsB,IAAI;AAC1B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,IAAI;AACxC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,IAAI;AACvC;AACA;AACA;AACA,gCAAgC,EAAE,EAAE,KAAK;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,sBAAsB;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,6CAA6C;AAC7C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;;AAEA,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK,6CAA6C;;AAElD;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B;AAC3B;;;;;;;;;;;;AC15BA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,MAAM;AAChB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,8BAA8B;AAClE;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,oBAAoB;AAC9B;AACA;;AAEA;AACA,UAAU,UAAU;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,sBAAsB;AACrD;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7SA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC;;AAErC;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA,4BAA4B,UAAU;;;;;;;;;;;;ACvLtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A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","file":"terminal.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Terminal\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Terminal\"] = factory();\n\telse\n\t\troot[\"Terminal\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","'use strict';\nmodule.exports = balanced;\nfunction balanced(a, b, str) {\n  if (a instanceof RegExp) a = maybeMatch(a, str);\n  if (b instanceof RegExp) b = maybeMatch(b, str);\n\n  var r = range(a, b, str);\n\n  return r && {\n    start: r[0],\n    end: r[1],\n    pre: str.slice(0, r[0]),\n    body: str.slice(r[0] + a.length, r[1]),\n    post: str.slice(r[1] + b.length)\n  };\n}\n\nfunction maybeMatch(reg, str) {\n  var m = str.match(reg);\n  return m ? m[0] : null;\n}\n\nbalanced.range = range;\nfunction range(a, b, str) {\n  var begs, beg, left, right, result;\n  var ai = str.indexOf(a);\n  var bi = str.indexOf(b, ai + 1);\n  var i = ai;\n\n  if (ai >= 0 && bi > 0) {\n    begs = [];\n    left = str.length;\n\n    while (i >= 0 && !result) {\n      if (i == ai) {\n        begs.push(i);\n        ai = str.indexOf(a, i + 1);\n      } else if (begs.length == 1) {\n        result = [ begs.pop(), bi ];\n      } else {\n        beg = begs.pop();\n        if (beg < left) {\n          left = beg;\n          right = bi;\n        }\n\n        bi = str.indexOf(b, i + 1);\n      }\n\n      i = ai < bi && ai >= 0 ? ai : bi;\n    }\n\n    if (begs.length) {\n      result = [ left, right ];\n    }\n  }\n\n  return result;\n}\n","var concatMap = require('concat-map');\nvar balanced = require('balanced-match');\n\nmodule.exports = expandTop;\n\nvar escSlash = '\\0SLASH'+Math.random()+'\\0';\nvar escOpen = '\\0OPEN'+Math.random()+'\\0';\nvar escClose = '\\0CLOSE'+Math.random()+'\\0';\nvar escComma = '\\0COMMA'+Math.random()+'\\0';\nvar escPeriod = '\\0PERIOD'+Math.random()+'\\0';\n\nfunction numeric(str) {\n  return parseInt(str, 10) == str\n    ? parseInt(str, 10)\n    : str.charCodeAt(0);\n}\n\nfunction escapeBraces(str) {\n  return str.split('\\\\\\\\').join(escSlash)\n            .split('\\\\{').join(escOpen)\n            .split('\\\\}').join(escClose)\n            .split('\\\\,').join(escComma)\n            .split('\\\\.').join(escPeriod);\n}\n\nfunction unescapeBraces(str) {\n  return str.split(escSlash).join('\\\\')\n            .split(escOpen).join('{')\n            .split(escClose).join('}')\n            .split(escComma).join(',')\n            .split(escPeriod).join('.');\n}\n\n\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n  if (!str)\n    return [''];\n\n  var parts = [];\n  var m = balanced('{', '}', str);\n\n  if (!m)\n    return str.split(',');\n\n  var pre = m.pre;\n  var body = m.body;\n  var post = m.post;\n  var p = pre.split(',');\n\n  p[p.length-1] += '{' + body + '}';\n  var postParts = parseCommaParts(post);\n  if (post.length) {\n    p[p.length-1] += postParts.shift();\n    p.push.apply(p, postParts);\n  }\n\n  parts.push.apply(parts, p);\n\n  return parts;\n}\n\nfunction expandTop(str) {\n  if (!str)\n    return [];\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.substr(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.substr(2);\n  }\n\n  return expand(escapeBraces(str), true).map(unescapeBraces);\n}\n\nfunction identity(e) {\n  return e;\n}\n\nfunction embrace(str) {\n  return '{' + str + '}';\n}\nfunction isPadded(el) {\n  return /^-?0\\d/.test(el);\n}\n\nfunction lte(i, y) {\n  return i <= y;\n}\nfunction gte(i, y) {\n  return i >= y;\n}\n\nfunction expand(str, isTop) {\n  var expansions = [];\n\n  var m = balanced('{', '}', str);\n  if (!m || /\\$$/.test(m.pre)) return [str];\n\n  var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isSequence = isNumericSequence || isAlphaSequence;\n  var isOptions = m.body.indexOf(',') >= 0;\n  if (!isSequence && !isOptions) {\n    // {a},b}\n    if (m.post.match(/,.*\\}/)) {\n      str = m.pre + '{' + m.body + escClose + m.post;\n      return expand(str);\n    }\n    return [str];\n  }\n\n  var n;\n  if (isSequence) {\n    n = m.body.split(/\\.\\./);\n  } else {\n    n = parseCommaParts(m.body);\n    if (n.length === 1) {\n      // x{{a,b}}y ==> x{a}y x{b}y\n      n = expand(n[0], false).map(embrace);\n      if (n.length === 1) {\n        var post = m.post.length\n          ? expand(m.post, false)\n          : [''];\n        return post.map(function(p) {\n          return m.pre + n[0] + p;\n        });\n      }\n    }\n  }\n\n  // at this point, n is the parts, and we know it's not a comma set\n  // with a single entry.\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  var pre = m.pre;\n  var post = m.post.length\n    ? expand(m.post, false)\n    : [''];\n\n  var N;\n\n  if (isSequence) {\n    var x = numeric(n[0]);\n    var y = numeric(n[1]);\n    var width = Math.max(n[0].length, n[1].length)\n    var incr = n.length == 3\n      ? Math.abs(numeric(n[2]))\n      : 1;\n    var test = lte;\n    var reverse = y < x;\n    if (reverse) {\n      incr *= -1;\n      test = gte;\n    }\n    var pad = n.some(isPadded);\n\n    N = [];\n\n    for (var i = x; test(i, y); i += incr) {\n      var c;\n      if (isAlphaSequence) {\n        c = String.fromCharCode(i);\n        if (c === '\\\\')\n          c = '';\n      } else {\n        c = String(i);\n        if (pad) {\n          var need = width - c.length;\n          if (need > 0) {\n            var z = new Array(need + 1).join('0');\n            if (i < 0)\n              c = '-' + z + c.slice(1);\n            else\n              c = z + c;\n          }\n        }\n      }\n      N.push(c);\n    }\n  } else {\n    N = concatMap(n, function(el) { return expand(el, false) });\n  }\n\n  for (var j = 0; j < N.length; j++) {\n    for (var k = 0; k < post.length; k++) {\n      var expansion = pre + N[j] + post[k];\n      if (!isTop || isSequence || expansion)\n        expansions.push(expansion);\n    }\n  }\n\n  return expansions;\n}\n\n","module.exports = function (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        var x = fn(xs[i], i);\n        if (isArray(x)) res.push.apply(res, x);\n        else res.push(x);\n    }\n    return res;\n};\n\nvar isArray = Array.isArray || function (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n};\n","\"use strict\";\n\n/**\n * Class used internally to represent individual options.\n * @internal\n */\nclass Option{\n\t\n\t/**\n\t * Create a new Option instance.\n\t *\n\t * @param {String|Array} names - Comma-separated list of names.\n\t * @param {String|Array} params - Arguments which the option expects.\n\t * @example new Option(\"-l, --long-list, --length\", \"<num> <type>\")\n\t * @example new Option(\"-e, --exec\", \"[num] [type]\")\n\t * @constructor\n\t */\n\tconstructor(names, params = \"\"){\n\t\tthis.shortNames = [];\n\t\tthis.longNames  = [];\n\t\tthis.params     = [];\n\t\tthis.values     = [];\n\t\t\n\t\tthis.defineNames(names);\n\t\tthis.defineParams(params);\n\t}\n\t\n\t\n\t/**\n\t * Describe the names used to refer to this option.\n\t * \n\t * @param {String|Array} input\n\t * @internal\n\t */\n\tdefineNames(input){\n\t\tif(!Array.isArray(input))\n\t\t\tinput = String(input).split(/,/g);\n\t\t\n\t\tfor(let name of input){\n\t\t\tname = name.trim();\n\t\t\t/^-([^\\s-])$/.test(name)\n\t\t\t\t? this.shortNames.push(RegExp.lastParen)\n\t\t\t\t: this.longNames.push(name.replace(/^-+/, \"\"));\n\t\t}\n\t}\n\t\n\t\n\t/**\n\t * Describe the parameters this option accepts/expects.\n\t *\n\t * @param {String|Array} input\n\t * @internal\n\t */\n\tdefineParams(input){\n\t\tinput = Array.isArray(input)\n\t\t\t? input.filter(Boolean).join(\" \")\n\t\t\t: String(input).trim().split(/\\s+/g);\n\t\t\n\t\t// Strip any enclosing brackets added for readability\n\t\tinput = input.map(param => param.replace(/^<(.+?)>$|^\\[(.+?)\\]$|^\\((.+?)\\)$/gm, (...args) =>\n\t\t\targs.slice(1, 4).filter(Boolean).join(\"\")));\n\t\t\n\t\tfor(const param of input){\n\t\t\tif(!param) continue;\n\t\t\tconst [, name, pattern=\".+\"] = param.match(/^([^=]+)(?:=(.+)?)?$/);\n\t\t\tthis.params.push({name, pattern});\n\t\t\tif(/\\.{3}$/.test(name))\n\t\t\t\tthis.variadic = true;\n\t\t}\n\t}\n\t\n\t\n\t/**\n\t * Pattern to match option when expressed in bundled short-form.\n\t *\n\t * @readonly\n\t * @return {String}\n\t */\n\tget bundlePattern(){\n\t\t\n\t\t// Use a cached result if possible\n\t\tif(this._bundlePattern)\n\t\t\treturn this._bundlePattern;\n\t\t\n\t\tconst param = this.params.map(param => `(${param.pattern})?`).join(\"\");\n\t\tconst names = 1 === this.shortNames.length\n\t\t\t? this.shortNames[0]\n\t\t\t: `[${this.shortNames.join(\"\")}]`;\n\t\treturn (this._bundlePattern = names + param);\n\t}\n\t\n\t\n\t/**\n\t * Number of parameters this option expects/accepts.\n\t *\n\t * @readonly\n\t * @property {Number}\n\t */\n\tget arity(){\n\t\treturn this.params ? this.params.length : 0;\n\t}\n\t\n\t\n\t/**\n\t * Array of names recognised by the option, both long and short.\n\t *\n\t * @readonly\n\t * @property {Array}\n\t */\n\tget names(){\n\t\treturn this.shortNames.concat(this.longNames);\n\t}\n\t\n\t\n\t/**\n\t * Whether the option can accept another parameter.\n\t *\n\t * @readonly\n\t * @property {Boolean}\n\t */\n\tget canCollect(){\n\t\treturn !!(this.variadic || this.values.length < this.params.length);\n\t}\n}\n\n\n\n/**\n * Box a value inside an {@link Array}, unless it already is one.\n *\n * @example arrayify(1)   => [1]\n * @example arrayify([1]) => [1]\n * @param {*} input\n * @return {Array}\n * @internal\n */\nfunction arrayify(input){\n\treturn Array.isArray(input) ? input : [input];\n}\n\n\n/**\n * Strip leading dashes from an option name and convert it to camelCase.\n *\n * @param {String} input - An option's name, such as \"--write-to\"\n * @param {Boolean} noCamelCase - Strip leading dashes only\n * @return {String}\n * @internal\n */\nfunction formatName(input, noCamelCase){\n\tinput = input.replace(/^-+/, \"\");\n\t\n\t// Convert kebab-case to camelCase\n\tif(!noCamelCase && /-/.test(input))\n\t\tinput = input.toLowerCase().replace(/([a-z])-+([a-z])/g, (_, a, b) => a + b.toUpperCase());\n\t\n\treturn input;\n}\n\n\n/**\n * Test a string against a list of patterns.\n *\n * @param {String} input\n * @param {String[]|RegExp[]} patterns\n * @return {Boolean}\n * @internal\n */\nfunction match(input, patterns = []){\n\tif(!patterns || 0 === patterns.length)\n\t\treturn false;\n\t\n\tinput    = String(input);\n\tpatterns = arrayify(patterns).filter(Boolean);\n\tfor(const pattern of patterns)\n\t\tif((pattern === input && \"string\" === typeof pattern)\n\t\t|| (pattern instanceof RegExp) && pattern.test(input))\n\t\t\treturn true;\n\treturn false;\n}\n\n\n/**\n * Filter duplicate strings from an array.\n *\n * @param {String[]} input\n * @return {Array}\n * @internal\n */\nfunction uniqueStrings(input){\n\tconst output = {};\n\tfor(let i = 0, l = input.length; i < l; ++i)\n\t\toutput[input[i]] = true;\n\treturn Object.keys(output);\n}\n\n\n/**\n * Parse a string as a whitespace-delimited list of options,\n * preserving quoted and escaped characters.\n *\n * @example unstringify(\"--foo --bar\")     => [\"--foo\", \"--bar\"];\n * @example unstringify('--foo \"bar baz\"') => [\"--foo\", '\"bar baz\"'];\n * @param {String} input\n * @return {Object}\n * @internal\n */\nfunction unstringify(input){\n\tinput = String(input || \"\");\n\tconst tokens   = [];\n\tconst {length} = input;\n\t\n\tlet quoteChar  = \"\";    // Quote-type enclosing current region\n\tlet tokenData  = \"\";    // Characters currently being collected\n\tlet isEscaped  = false; // Flag identifying an escape sequence\n\t\n\tfor(let i = 0; i < length; ++i){\n\t\tconst char = input[i];\n\t\t\n\t\t// Previous character was a backslash\n\t\tif(isEscaped){\n\t\t\ttokenData += char;\n\t\t\tisEscaped = false;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t// Whitespace: terminate token unless quoted\n\t\tif(!quoteChar && /[ \\t\\n]/.test(char)){\n\t\t\ttokenData && tokens.push(tokenData);\n\t\t\ttokenData = \"\";\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t// Backslash: escape next character\n\t\tif(\"\\\\\" === char){\n\t\t\tisEscaped = true;\n\t\t\t\n\t\t\t// Swallow backslash if it escapes a metacharacter\n\t\t\tconst next = input[i + 1];\n\t\t\tif(quoteChar && (quoteChar === next || \"\\\\\" === next)\n\t\t\t|| !quoteChar && /[- \\t\\n\\\\'\"`]/.test(next))\n\t\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t// Quote marks\n\t\telse if((!quoteChar || char === quoteChar) && /['\"`]/.test(char)){\n\t\t\tquoteChar = quoteChar === char ? \"\" : char;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\ttokenData += char;\n\t}\n\tif(tokenData)\n\t\ttokens.push(tokenData);\n\treturn tokens;\n}\n\n\n/**\n * Parse input using \"best guess\" logic. Called when no optdef is passed.\n *\n * Essentially, the following assumptions are made about input:\n *\n * - Anything beginning with at least one dash is an option name\n * - Options without arguments mean a boolean \"true\"\n * - Option-reading stops at \"--\"\n * - Anything caught between two options becomes the first option's value\n *\n * @param {Array} input\n * @param {Object} [config={}]\n * @return {Object}\n * @internal\n */\nfunction autoOpts(input, config = {}){\n\tconst opts = new Object(null);\n\tconst argv = [];\n\tlet argvEnd;\n\t\n\t// Bail early if passed a blank string\n\tif(!input) return opts;\n\t\n\t// Stop parsing options after a double-dash\n\tconst stopAt = input.indexOf(\"--\");\n\tif(stopAt !== -1){\n\t\targvEnd = input.slice(stopAt + 1);\n\t\tinput = input.slice(0, stopAt);\n\t}\n\t\n\tfor(let i = 0, l = input.length; i < l; ++i){\n\t\tlet name = input[i];\n\t\t\n\t\t// Appears to be an option\n\t\tif(/^-/.test(name)){\n\t\t\t\n\t\t\t// Equals sign is used, should it become the option's value?\n\t\t\tif(!config.ignoreEquals && /=/.test(name)){\n\t\t\t\tconst split = name.split(/=/);\n\t\t\t\tname        = formatName(split[0], config.noCamelCase);\n\t\t\t\topts[name]  = split.slice(1).join(\"=\");\n\t\t\t}\n\t\t\t\n\t\t\telse{\n\t\t\t\tname = formatName(name, config.noCamelCase);\n\t\t\t\t\n\t\t\t\t// Treat a following non-option as this option's value\n\t\t\t\tconst next = input[i + 1];\n\t\t\t\tif(next != null && !/^-/.test(next)){\n\t\t\t\t\t\n\t\t\t\t\t// There's another option after this one. Collect multiple non-options into an array.\n\t\t\t\t\tconst nextOpt = input.findIndex((s, I) => I > i && /^-/.test(s));\n\t\t\t\t\tif(nextOpt !== -1){\n\t\t\t\t\t\topts[name] = input.slice(i + 1, nextOpt);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// There's only one value to store; don't wrap it in an array\n\t\t\t\t\t\tif(nextOpt - i < 3)\n\t\t\t\t\t\t\topts[name] = opts[name][0];\n\t\t\t\t\t\t\n\t\t\t\t\t\ti = nextOpt - 1;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// We're at the last option. Don't touch argv; assume it's a boolean-type option\n\t\t\t\t\telse opts[name] = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// No arguments defined. Assume it's a boolean-type option.\n\t\t\t\telse opts[name] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Non-option: add to argv\n\t\telse argv.push(name);\n\t}\n\t\n\t\n\t// Add any additional arguments that were found after a \"--\" delimiter\n\tif(argvEnd)\n\t\targv.push(...argvEnd);\n\t\n\treturn {\n\t\toptions: opts,\n\t\targv:    argv,\n\t};\n}\n\n\n\n/**\n * Extract command-line options from a list of strings.\n *\n * @param {String|Array} input\n * @param {String|Object} [optdef=null]\n * @param {Object} [config={}]\n */\nfunction getOpts(input, optdef = null, config = {}){\n\t\n\t// Do nothing if given nothing\n\tif(!input || 0 === input.length)\n\t\treturn {options: {}, argv: []};\n\t\n\t// Avoid modifying original array\n\tif(Array.isArray(input))\n\t\tinput = [...input].map(String);\n\t\n\t// If called with a string, break it apart into an array\n\telse if(\"string\" === typeof input)\n\t\tinput = unstringify(input);\n\t\n\t\n\t// Take a different approach if optdefs aren't specified\n\tif(null === optdef || \"\" === optdef || false === optdef)\n\t\treturn autoOpts(input, config);\n\t\n\t\n\t// Allow \"t:h:i:s\" style of getopt usage\n\tif(\"[object String]\" === Object.prototype.toString.call(optdef)){\n\t\tconst names = optdef.match(/[^\\s:]:?/g);\n\t\toptdef = {};\n\t\tnames.forEach(name => {\n\t\t\toptdef[`-${name.replace(/:/, \"\")}`] = name.length > 1 ? \"<arg>\" : \"\";\n\t\t});\n\t}\n\n\t// Parse settings that affect runtime option-handling\n\tconst {\n\t\tnoAliasPropagation,\n\t\tnoCamelCase,\n\t\tnoBundling,\n\t\tnoMixedOrder,\n\t\tnoUndefined,\n\t\tterminator,\n\t\tignoreEquals,\n\t\tduplicates = \"use-last\",\n\t} = config;\n\t\n\tconst shortNames = {};\n\tconst longNames = {};\n\tconst result = {argv: [], options: new Object(null)};\n\n\t// Define each named option. Throw an error if a duplicate is found.\n\tfor(const name in optdef){\n\t\tconst option = new Option(name, optdef[name]);\n\t\t\n\t\tfor(const name of option.shortNames){\n\t\t\tif(undefined !== shortNames[name])\n\t\t\t\tthrow new ReferenceError(`Short option \"-${name}\" already defined`);\n\t\t\tshortNames[`-${name}`] = option;\n\t\t}\n\t\t\n\t\tfor(const name of option.longNames){\n\t\t\tif(undefined !== longNames[name])\n\t\t\t\tthrow new ReferenceError(`Long option \"--${name}\" already defined`);\n\t\t\tlongNames[`--${name}`] = option;\n\t\t}\n\t}\n\t\n\t// Pointer to the option that's currently picking up arguments\n\tlet currentOption;\n\t\n\t\n\t// Manage duplicated option values\n\tfunction resolveDuplicate(option, name, value){\n\t\tswitch(duplicates){\n\t\t\t\n\t\t\t// Use the first value (or set of values); discard any following duplicates\n\t\t\tcase \"use-first\":\n\t\t\t\treturn result.options[name];\n\t\t\t\n\t\t\t// Use the last value (or set of values); discard any preceding duplicates. Default.\n\t\t\tcase \"use-last\":\n\t\t\tdefault:\n\t\t\t\treturn result.options[name] = value;\n\t\t\t\n\t\t\t// Use the first/last options; treat any following/preceding duplicates as argv items respectively\n\t\t\tcase \"limit-first\":\n\t\t\tcase \"limit-last\":\n\t\t\t\tresult.argv.push(option.prevMatchedName, ...arrayify(value));\n\t\t\t\tbreak;\n\t\t\t\n\t\t\t// Throw an exception\n\t\t\tcase \"error\":\n\t\t\t\tconst error = new TypeError(`Attempting to reassign option \"${name}\" with value(s) ${JSON.stringify(value)}`);\n\t\t\t\terror.affectedOption = option;\n\t\t\t\terror.affectedValue  = value;\n\t\t\t\tthrow error;\n\t\t\t\n\t\t\t// Add parameters of duplicate options to the argument list of the first\n\t\t\tcase \"append\":\n\t\t\t\tconst oldValues = arrayify(result.options[name]);\n\t\t\t\tconst newValues = arrayify(value);\n\t\t\t\tresult.options[name] = oldValues.concat(newValues);\n\t\t\t\tbreak;\n\t\t\t\n\t\t\t// Store parameters of duplicated options in a multidimensional array\n\t\t\tcase \"stack\": {\n\t\t\t\tlet oldValues   = result.options[name];\n\t\t\t\tconst newValues = arrayify(value);\n\t\t\t\t\n\t\t\t\t// This option hasn't been \"stacked\" yet\n\t\t\t\tif(!option.stacked){\n\t\t\t\t\toldValues            = arrayify(oldValues);\n\t\t\t\t\tresult.options[name] = [oldValues, newValues];\n\t\t\t\t\toption.stacked       = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Already \"stacked\", so just shove the values onto the end of the array\n\t\t\t\telse result.options[name].push(arrayify(newValues));\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t// Store each duplicated value in an array using the order they appear\n\t\t\tcase \"stack-values\": {\n\t\t\t\tlet values = result.options[name];\n\t\t\t\t\n\t\t\t\t// First time \"stacking\" this option (nesting its value/s inside an array)\n\t\t\t\tif(!option.stacked){\n\t\t\t\t\tconst stack = [];\n\t\t\t\t\tfor(const value of arrayify(values))\n\t\t\t\t\t\tstack.push([value]);\n\t\t\t\t\tvalues = stack;\n\t\t\t\t\toption.stacked = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tarrayify(value).forEach((v, i) => {\n\t\t\t\t\t\n\t\t\t\t\t// An array hasn't been created at this index yet,\n\t\t\t\t\t// because an earlier option wasn't given enough parameters.\n\t\t\t\t\tif(undefined === values[i])\n\t\t\t\t\t\tvalues[i] = Array(values[0].length - 1);\n\t\t\t\t\t\n\t\t\t\t\tvalues[i].push(v);\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tresult.options[name] = values;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t// Assign an option's parsed value to the result's `.options` property\n\tfunction setValue(option, value){\n\t\t\n\t\t// Assign the value only to the option name it matched\n\t\tif(noAliasPropagation){\n\t\t\tlet name = option.lastMatchedName;\n\t\t\t\n\t\t\t// Special alternative:\n\t\t\t// In lieu of using the matched option name, use the first --long-name only\n\t\t\tif(\"first-only\" === noAliasPropagation)\n\t\t\t\tname = option.longNames[0] || option.shortNames[0];\n\t\t\t\n\t\t\t// camelCase?\n\t\t\tname = formatName(name, noCamelCase);\n\t\t\t\n\t\t\t// This option's already been set before\n\t\t\tif(result.options[name])\n\t\t\t\tresolveDuplicate(option, name, value);\n\t\t\t\n\t\t\telse result.options[name] = value;\n\t\t}\n\t\t\n\t\t// Copy across every alias this option's recognised by\n\t\telse{\n\t\t\tconst {names} = option;\n\t\t\t\n\t\t\tfor(let name of names){\n\t\t\t\t\n\t\t\t\t// Decide whether to camelCase this option name\n\t\t\t\tname = formatName(name, noCamelCase);\n\t\t\t\t\n\t\t\t\t// Ascertain if this option's being duplicated\n\t\t\t\tif(result.options[name])\n\t\t\t\t\tresolveDuplicate(option, name, value);\n\t\t\t\t\n\t\t\t\tresult.options[name] = value;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t// Push whatever we've currently collected for this option and reset pointer\n\tfunction wrapItUp(){\n\t\tlet optValue = currentOption.values;\n\t\t\n\t\t// Don't store solitary values in an array. Store them directly as strings\n\t\tif(1 === currentOption.arity && !currentOption.variadic)\n\t\t\toptValue = optValue[0];\n\n\t\tsetValue(currentOption, optValue);\n\t\tcurrentOption.values = [];\n\t\tcurrentOption = null;\n\t}\n\t\n\t\n\t// Reverse the order of an argument list, keeping options and their parameter lists intact\n\tfunction flip(input){\n\t\tinput = input.reverse();\n\t\t\n\t\t// Flip any options back into the right order\n\t\tfor(let i = 0, l = input.length; i < l; ++i){\n\t\t\tconst arg = input[i];\n\t\t\tconst opt = shortNames[arg] || longNames[arg];\n\t\t\t\n\t\t\tif(opt){\n\t\t\t\tconst from    = Math.max(0, i - opt.arity);\n\t\t\t\tconst to      = i + 1;\n\t\t\t\tconst extract = input.slice(from, to).reverse();\n\t\t\t\tinput.splice(from, extract.length, ...extract);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn input;\n\t}\n\t\n\t\n\t// Tackle bundling. Ensure there's at least one option with a short name to work with.\n\tconst nameKeys = Object.keys(shortNames);\n\tlet bundleMatch, bundlePatterns, niladicArgs;\n\t\n\tif(!noBundling && nameKeys.length){\n\t\tbundlePatterns  = uniqueStrings(nameKeys.map(n => shortNames[n].bundlePattern)).join(\"|\");\n\t\tbundleMatch     = new RegExp(`^-(${bundlePatterns})+`, \"g\");\n\t\tniladicArgs     = uniqueStrings(nameKeys.filter(n => !shortNames[n].arity).map(n => shortNames[n].bundlePattern)).join(\"|\");\n\t\tniladicArgs     = new RegExp(`^(-(?:${niladicArgs})+)((?!${bundlePatterns})\\\\S+)`);\n\t\tbundlePatterns  = new RegExp(bundlePatterns, \"g\");\n\t}\n\t\n\t\n\t// Is pre-processing of the argument list necessary?\n\tif(!ignoreEquals || bundleMatch){\n\t\t\n\t\t// Limit equals-sign expansion to items that begin with recognised option names\n\t\tconst legalNames = new RegExp(`^(?:${ Object.keys(longNames).join(\"|\") })=`);\n\t\t\n\t\tfor(let i = 0, l = input.length; i < l; ++i){\n\t\t\tlet arg = input[i];\n\t\t\t\n\t\t\t// We have bundling in use\n\t\t\tif(bundleMatch){\n\t\t\t\tbundleMatch.lastIndex = 0;\n\t\t\t\t\n\t\t\t\t// Expand bundled option clusters (\"-mvl2\" -> \"-m -v -l 2\")\n\t\t\t\tif(bundleMatch.test(arg)){\n\t\t\t\t\t\n\t\t\t\t\t// Break off arguments attached to niladic options\n\t\t\t\t\tconst niladicMatch = arg.match(niladicArgs);\n\t\t\t\t\tif(niladicMatch){\n\t\t\t\t\t\tniladicArgs.lastIndex = 0;\n\t\t\t\t\t\targ = niladicMatch[1];\n\t\t\t\t\t\tinput.splice(i + 1, 0, niladicMatch[2]);\n\t\t\t\t\t\tl = input.length;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tconst segments = [].concat(...arg.match(bundlePatterns).map(m => {\n\t\t\t\t\t\tconst option = shortNames[`-${m[0]}`];\n\t\t\t\t\t\tconst result = [`-${m[0]}`];\n\t\t\t\t\t\tif(!option.arity) return result;\n\t\t\t\t\t\tresult.push(...m.match(new RegExp(option.bundlePattern)).slice(1).filter(i => i));\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}));\n\t\t\t\t\tinput.splice(i, 1, ...segments);\n\t\t\t\t\tl =  input.length;\n\t\t\t\t\ti += segments.length - 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Expand \"--option=value\" sequences to become \"--option value\"\n\t\t\tif(legalNames.test(arg)){\n\t\t\t\tconst match = arg.match(/^([^=]+)=(.+)$/);\n\t\t\t\tinput.splice(i, 1, match[1], match[2]);\n\t\t\t\tl =  input.length;\n\t\t\t\ti += 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t// If we're handling duplicate options with \"limit-last\", flip the input order\n\tif(\"limit-last\" === duplicates)\n\t\tinput = flip(input);\n\t\n\t// Start processing the arguments we were given to handle\n\tfor(let i = 0, l = input.length; i < l; ++i){\n\t\tconst arg = input[i];\n\t\tconst opt = shortNames[arg] || longNames[arg];\n\t\t\n\t\t// This argument matches a recognised option name\n\t\tif(opt){\n\t\t\t\n\t\t\t// Record the name given on command-line that matched the option\n\t\t\topt.lastMatchedName = arg;\n\t\t\t\n\t\t\t// Did we have an existing option that was collecting values?\n\t\t\tif(currentOption) wrapItUp();\n\t\t\t\n\t\t\t\n\t\t\t// Option takes at least one argument\n\t\t\tif(opt.arity)\n\t\t\t\tcurrentOption = opt;\n\t\t\t\n\t\t\t// This option takes no arguments, so just assign it a value of \"true\"\n\t\t\telse setValue(opt, true);\n\t\t\t\n\t\t\t\n\t\t\t// Store an additional back-reference to the current option's name\n\t\t\topt.prevMatchedName = arg;\n\t\t}\n\t\t\n\t\telse{\n\t\t\tconst isTerminator = match(arg, terminator);\n\t\t\tconst keepRest = () => result.argv.push(...input.slice(i + 1));\n\t\t\t\n\t\t\t// A previous option is still collecting arguments\n\t\t\tif(currentOption && currentOption.canCollect && !isTerminator)\n\t\t\t\tcurrentOption.values.push(arg);\n\t\t\t\n\t\t\t// Not associated with an option\n\t\t\telse{\n\t\t\t\tcurrentOption && wrapItUp();\n\t\t\t\t\n\t\t\t\t// Terminate option parsing?\n\t\t\t\tif(isTerminator){\n\t\t\t\t\tkeepRest();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Raise an exception if unrecognised switches are considered an error\n\t\t\t\tif(noUndefined && /^-./.test(arg)){\n\t\t\t\t\tlet error = noUndefined;\n\t\t\t\t\t\n\t\t\t\t\t// Prepare an error object to be thrown in the user's direction\n\t\t\t\t\tswitch(typeof noUndefined){\n\t\t\t\t\t\tcase \"function\": error = error(arg); break;\n\t\t\t\t\t\tcase \"boolean\":  error = 'Unknown option: \"%s\"'; // Fall-through\n\t\t\t\t\t\tcase \"string\":   error = new TypeError(error.replace(\"%s\", arg));\n\t\t\t\t\t}\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tresult.argv.push(arg);\n\t\t\t\t\n\t\t\t\t// Finish processing if mixed-order is disabled\n\t\t\t\tif(noMixedOrder){\n\t\t\t\t\tkeepRest();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t// Ended abruptly?\n\tif(currentOption) wrapItUp();\n\t\n\t\n\t// Check if we need to flip the returned .argv array back into the right order again\n\tif(\"limit-last\" === duplicates)\n\t\tresult.argv = flip(result.argv);\n\t\t\n\treturn result;\n}\n\n\nif(\"undefined\" !== typeof module.exports)\n\tmodule.exports = getOpts;\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// Used for setting prototype methods that IE8 chokes on.\nvar DELETE = 'delete';\n\n// Constants describing the size of trie nodes.\nvar SHIFT = 5; // Resulted in best performance after ______?\nvar SIZE = 1 << SHIFT;\nvar MASK = SIZE - 1;\n\n// A consistent shared value representing \"not set\" which equals nothing other\n// than itself, and nothing that could be provided externally.\nvar NOT_SET = {};\n\n// Boolean references, Rough equivalent of `bool &`.\nfunction MakeRef() {\n  return { value: false };\n}\n\nfunction SetRef(ref) {\n  if (ref) {\n    ref.value = true;\n  }\n}\n\n// A function which returns a value representing an \"owner\" for transient writes\n// to tries. The return value will only ever equal itself, and will not equal\n// the return of any subsequent call of this function.\nfunction OwnerID() {}\n\nfunction ensureSize(iter) {\n  if (iter.size === undefined) {\n    iter.size = iter.__iterate(returnTrue);\n  }\n  return iter.size;\n}\n\nfunction wrapIndex(iter, index) {\n  // This implements \"is array index\" which the ECMAString spec defines as:\n  //\n  //     A String property name P is an array index if and only if\n  //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal\n  //     to 2^321.\n  //\n  // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects\n  if (typeof index !== 'number') {\n    var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32\n    if ('' + uint32Index !== index || uint32Index === 4294967295) {\n      return NaN;\n    }\n    index = uint32Index;\n  }\n  return index < 0 ? ensureSize(iter) + index : index;\n}\n\nfunction returnTrue() {\n  return true;\n}\n\nfunction wholeSlice(begin, end, size) {\n  return (\n    ((begin === 0 && !isNeg(begin)) ||\n      (size !== undefined && begin <= -size)) &&\n    (end === undefined || (size !== undefined && end >= size))\n  );\n}\n\nfunction resolveBegin(begin, size) {\n  return resolveIndex(begin, size, 0);\n}\n\nfunction resolveEnd(end, size) {\n  return resolveIndex(end, size, size);\n}\n\nfunction resolveIndex(index, size, defaultIndex) {\n  // Sanitize indices using this shorthand for ToInt32(argument)\n  // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n  return index === undefined\n    ? defaultIndex\n    : isNeg(index)\n      ? size === Infinity\n        ? size\n        : Math.max(0, size + index) | 0\n      : size === undefined || size === index\n        ? index\n        : Math.min(size, index) | 0;\n}\n\nfunction isNeg(value) {\n  // Account for -0 which is negative, but not less than 0.\n  return value < 0 || (value === 0 && 1 / value === -Infinity);\n}\n\n// Note: value is unchanged to not break immutable-devtools.\nvar IS_COLLECTION_SYMBOL = '@@__IMMUTABLE_ITERABLE__@@';\n\nfunction isCollection(maybeCollection) {\n  return Boolean(maybeCollection && maybeCollection[IS_COLLECTION_SYMBOL]);\n}\n\nvar IS_KEYED_SYMBOL = '@@__IMMUTABLE_KEYED__@@';\n\nfunction isKeyed(maybeKeyed) {\n  return Boolean(maybeKeyed && maybeKeyed[IS_KEYED_SYMBOL]);\n}\n\nvar IS_INDEXED_SYMBOL = '@@__IMMUTABLE_INDEXED__@@';\n\nfunction isIndexed(maybeIndexed) {\n  return Boolean(maybeIndexed && maybeIndexed[IS_INDEXED_SYMBOL]);\n}\n\nfunction isAssociative(maybeAssociative) {\n  return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);\n}\n\nvar Collection = function Collection(value) {\n  return isCollection(value) ? value : Seq(value);\n};\n\nvar KeyedCollection = /*@__PURE__*/(function (Collection) {\n  function KeyedCollection(value) {\n    return isKeyed(value) ? value : KeyedSeq(value);\n  }\n\n  if ( Collection ) KeyedCollection.__proto__ = Collection;\n  KeyedCollection.prototype = Object.create( Collection && Collection.prototype );\n  KeyedCollection.prototype.constructor = KeyedCollection;\n\n  return KeyedCollection;\n}(Collection));\n\nvar IndexedCollection = /*@__PURE__*/(function (Collection) {\n  function IndexedCollection(value) {\n    return isIndexed(value) ? value : IndexedSeq(value);\n  }\n\n  if ( Collection ) IndexedCollection.__proto__ = Collection;\n  IndexedCollection.prototype = Object.create( Collection && Collection.prototype );\n  IndexedCollection.prototype.constructor = IndexedCollection;\n\n  return IndexedCollection;\n}(Collection));\n\nvar SetCollection = /*@__PURE__*/(function (Collection) {\n  function SetCollection(value) {\n    return isCollection(value) && !isAssociative(value) ? value : SetSeq(value);\n  }\n\n  if ( Collection ) SetCollection.__proto__ = Collection;\n  SetCollection.prototype = Object.create( Collection && Collection.prototype );\n  SetCollection.prototype.constructor = SetCollection;\n\n  return SetCollection;\n}(Collection));\n\nCollection.Keyed = KeyedCollection;\nCollection.Indexed = IndexedCollection;\nCollection.Set = SetCollection;\n\nvar IS_SEQ_SYMBOL = '@@__IMMUTABLE_SEQ__@@';\n\nfunction isSeq(maybeSeq) {\n  return Boolean(maybeSeq && maybeSeq[IS_SEQ_SYMBOL]);\n}\n\nvar IS_RECORD_SYMBOL = '@@__IMMUTABLE_RECORD__@@';\n\nfunction isRecord(maybeRecord) {\n  return Boolean(maybeRecord && maybeRecord[IS_RECORD_SYMBOL]);\n}\n\nfunction isImmutable(maybeImmutable) {\n  return isCollection(maybeImmutable) || isRecord(maybeImmutable);\n}\n\nvar IS_ORDERED_SYMBOL = '@@__IMMUTABLE_ORDERED__@@';\n\nfunction isOrdered(maybeOrdered) {\n  return Boolean(maybeOrdered && maybeOrdered[IS_ORDERED_SYMBOL]);\n}\n\nvar ITERATE_KEYS = 0;\nvar ITERATE_VALUES = 1;\nvar ITERATE_ENTRIES = 2;\n\nvar REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\n\nvar ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;\n\nvar Iterator = function Iterator(next) {\n  this.next = next;\n};\n\nIterator.prototype.toString = function toString () {\n  return '[Iterator]';\n};\n\nIterator.KEYS = ITERATE_KEYS;\nIterator.VALUES = ITERATE_VALUES;\nIterator.ENTRIES = ITERATE_ENTRIES;\n\nIterator.prototype.inspect = Iterator.prototype.toSource = function() {\n  return this.toString();\n};\nIterator.prototype[ITERATOR_SYMBOL] = function() {\n  return this;\n};\n\nfunction iteratorValue(type, k, v, iteratorResult) {\n  var value = type === 0 ? k : type === 1 ? v : [k, v];\n  iteratorResult\n    ? (iteratorResult.value = value)\n    : (iteratorResult = {\n        value: value,\n        done: false,\n      });\n  return iteratorResult;\n}\n\nfunction iteratorDone() {\n  return { value: undefined, done: true };\n}\n\nfunction hasIterator(maybeIterable) {\n  return !!getIteratorFn(maybeIterable);\n}\n\nfunction isIterator(maybeIterator) {\n  return maybeIterator && typeof maybeIterator.next === 'function';\n}\n\nfunction getIterator(iterable) {\n  var iteratorFn = getIteratorFn(iterable);\n  return iteratorFn && iteratorFn.call(iterable);\n}\n\nfunction getIteratorFn(iterable) {\n  var iteratorFn =\n    iterable &&\n    ((REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||\n      iterable[FAUX_ITERATOR_SYMBOL]);\n  if (typeof iteratorFn === 'function') {\n    return iteratorFn;\n  }\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction isArrayLike(value) {\n  if (Array.isArray(value) || typeof value === 'string') {\n    return true;\n  }\n\n  return (\n    value &&\n    typeof value === 'object' &&\n    Number.isInteger(value.length) &&\n    value.length >= 0 &&\n    (value.length === 0\n      ? // Only {length: 0} is considered Array-like.\n        Object.keys(value).length === 1\n      : // An object is only Array-like if it has a property where the last value\n        // in the array-like may be found (which could be undefined).\n        value.hasOwnProperty(value.length - 1))\n  );\n}\n\nvar Seq = /*@__PURE__*/(function (Collection$$1) {\n  function Seq(value) {\n    return value === null || value === undefined\n      ? emptySequence()\n      : isImmutable(value)\n        ? value.toSeq()\n        : seqFromValue(value);\n  }\n\n  if ( Collection$$1 ) Seq.__proto__ = Collection$$1;\n  Seq.prototype = Object.create( Collection$$1 && Collection$$1.prototype );\n  Seq.prototype.constructor = Seq;\n\n  Seq.prototype.toSeq = function toSeq () {\n    return this;\n  };\n\n  Seq.prototype.toString = function toString () {\n    return this.__toString('Seq {', '}');\n  };\n\n  Seq.prototype.cacheResult = function cacheResult () {\n    if (!this._cache && this.__iterateUncached) {\n      this._cache = this.entrySeq().toArray();\n      this.size = this._cache.length;\n    }\n    return this;\n  };\n\n  // abstract __iterateUncached(fn, reverse)\n\n  Seq.prototype.__iterate = function __iterate (fn, reverse) {\n    var cache = this._cache;\n    if (cache) {\n      var size = cache.length;\n      var i = 0;\n      while (i !== size) {\n        var entry = cache[reverse ? size - ++i : i++];\n        if (fn(entry[1], entry[0], this) === false) {\n          break;\n        }\n      }\n      return i;\n    }\n    return this.__iterateUncached(fn, reverse);\n  };\n\n  // abstract __iteratorUncached(type, reverse)\n\n  Seq.prototype.__iterator = function __iterator (type, reverse) {\n    var cache = this._cache;\n    if (cache) {\n      var size = cache.length;\n      var i = 0;\n      return new Iterator(function () {\n        if (i === size) {\n          return iteratorDone();\n        }\n        var entry = cache[reverse ? size - ++i : i++];\n        return iteratorValue(type, entry[0], entry[1]);\n      });\n    }\n    return this.__iteratorUncached(type, reverse);\n  };\n\n  return Seq;\n}(Collection));\n\nvar KeyedSeq = /*@__PURE__*/(function (Seq) {\n  function KeyedSeq(value) {\n    return value === null || value === undefined\n      ? emptySequence().toKeyedSeq()\n      : isCollection(value)\n        ? isKeyed(value)\n          ? value.toSeq()\n          : value.fromEntrySeq()\n        : isRecord(value)\n          ? value.toSeq()\n          : keyedSeqFromValue(value);\n  }\n\n  if ( Seq ) KeyedSeq.__proto__ = Seq;\n  KeyedSeq.prototype = Object.create( Seq && Seq.prototype );\n  KeyedSeq.prototype.constructor = KeyedSeq;\n\n  KeyedSeq.prototype.toKeyedSeq = function toKeyedSeq () {\n    return this;\n  };\n\n  return KeyedSeq;\n}(Seq));\n\nvar IndexedSeq = /*@__PURE__*/(function (Seq) {\n  function IndexedSeq(value) {\n    return value === null || value === undefined\n      ? emptySequence()\n      : isCollection(value)\n        ? isKeyed(value)\n          ? value.entrySeq()\n          : value.toIndexedSeq()\n        : isRecord(value)\n          ? value.toSeq().entrySeq()\n          : indexedSeqFromValue(value);\n  }\n\n  if ( Seq ) IndexedSeq.__proto__ = Seq;\n  IndexedSeq.prototype = Object.create( Seq && Seq.prototype );\n  IndexedSeq.prototype.constructor = IndexedSeq;\n\n  IndexedSeq.of = function of (/*...values*/) {\n    return IndexedSeq(arguments);\n  };\n\n  IndexedSeq.prototype.toIndexedSeq = function toIndexedSeq () {\n    return this;\n  };\n\n  IndexedSeq.prototype.toString = function toString () {\n    return this.__toString('Seq [', ']');\n  };\n\n  return IndexedSeq;\n}(Seq));\n\nvar SetSeq = /*@__PURE__*/(function (Seq) {\n  function SetSeq(value) {\n    return (isCollection(value) && !isAssociative(value)\n      ? value\n      : IndexedSeq(value)\n    ).toSetSeq();\n  }\n\n  if ( Seq ) SetSeq.__proto__ = Seq;\n  SetSeq.prototype = Object.create( Seq && Seq.prototype );\n  SetSeq.prototype.constructor = SetSeq;\n\n  SetSeq.of = function of (/*...values*/) {\n    return SetSeq(arguments);\n  };\n\n  SetSeq.prototype.toSetSeq = function toSetSeq () {\n    return this;\n  };\n\n  return SetSeq;\n}(Seq));\n\nSeq.isSeq = isSeq;\nSeq.Keyed = KeyedSeq;\nSeq.Set = SetSeq;\nSeq.Indexed = IndexedSeq;\n\nSeq.prototype[IS_SEQ_SYMBOL] = true;\n\n// #pragma Root Sequences\n\nvar ArraySeq = /*@__PURE__*/(function (IndexedSeq) {\n  function ArraySeq(array) {\n    this._array = array;\n    this.size = array.length;\n  }\n\n  if ( IndexedSeq ) ArraySeq.__proto__ = IndexedSeq;\n  ArraySeq.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );\n  ArraySeq.prototype.constructor = ArraySeq;\n\n  ArraySeq.prototype.get = function get (index, notSetValue) {\n    return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;\n  };\n\n  ArraySeq.prototype.__iterate = function __iterate (fn, reverse) {\n    var array = this._array;\n    var size = array.length;\n    var i = 0;\n    while (i !== size) {\n      var ii = reverse ? size - ++i : i++;\n      if (fn(array[ii], ii, this) === false) {\n        break;\n      }\n    }\n    return i;\n  };\n\n  ArraySeq.prototype.__iterator = function __iterator (type, reverse) {\n    var array = this._array;\n    var size = array.length;\n    var i = 0;\n    return new Iterator(function () {\n      if (i === size) {\n        return iteratorDone();\n      }\n      var ii = reverse ? size - ++i : i++;\n      return iteratorValue(type, ii, array[ii]);\n    });\n  };\n\n  return ArraySeq;\n}(IndexedSeq));\n\nvar ObjectSeq = /*@__PURE__*/(function (KeyedSeq) {\n  function ObjectSeq(object) {\n    var keys = Object.keys(object);\n    this._object = object;\n    this._keys = keys;\n    this.size = keys.length;\n  }\n\n  if ( KeyedSeq ) ObjectSeq.__proto__ = KeyedSeq;\n  ObjectSeq.prototype = Object.create( KeyedSeq && KeyedSeq.prototype );\n  ObjectSeq.prototype.constructor = ObjectSeq;\n\n  ObjectSeq.prototype.get = function get (key, notSetValue) {\n    if (notSetValue !== undefined && !this.has(key)) {\n      return notSetValue;\n    }\n    return this._object[key];\n  };\n\n  ObjectSeq.prototype.has = function has (key) {\n    return hasOwnProperty.call(this._object, key);\n  };\n\n  ObjectSeq.prototype.__iterate = function __iterate (fn, reverse) {\n    var object = this._object;\n    var keys = this._keys;\n    var size = keys.length;\n    var i = 0;\n    while (i !== size) {\n      var key = keys[reverse ? size - ++i : i++];\n      if (fn(object[key], key, this) === false) {\n        break;\n      }\n    }\n    return i;\n  };\n\n  ObjectSeq.prototype.__iterator = function __iterator (type, reverse) {\n    var object = this._object;\n    var keys = this._keys;\n    var size = keys.length;\n    var i = 0;\n    return new Iterator(function () {\n      if (i === size) {\n        return iteratorDone();\n      }\n      var key = keys[reverse ? size - ++i : i++];\n      return iteratorValue(type, key, object[key]);\n    });\n  };\n\n  return ObjectSeq;\n}(KeyedSeq));\nObjectSeq.prototype[IS_ORDERED_SYMBOL] = true;\n\nvar CollectionSeq = /*@__PURE__*/(function (IndexedSeq) {\n  function CollectionSeq(collection) {\n    this._collection = collection;\n    this.size = collection.length || collection.size;\n  }\n\n  if ( IndexedSeq ) CollectionSeq.__proto__ = IndexedSeq;\n  CollectionSeq.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );\n  CollectionSeq.prototype.constructor = CollectionSeq;\n\n  CollectionSeq.prototype.__iterateUncached = function __iterateUncached (fn, reverse) {\n    if (reverse) {\n      return this.cacheResult().__iterate(fn, reverse);\n    }\n    var collection = this._collection;\n    var iterator = getIterator(collection);\n    var iterations = 0;\n    if (isIterator(iterator)) {\n      var step;\n      while (!(step = iterator.next()).done) {\n        if (fn(step.value, iterations++, this) === false) {\n          break;\n        }\n      }\n    }\n    return iterations;\n  };\n\n  CollectionSeq.prototype.__iteratorUncached = function __iteratorUncached (type, reverse) {\n    if (reverse) {\n      return this.cacheResult().__iterator(type, reverse);\n    }\n    var collection = this._collection;\n    var iterator = getIterator(collection);\n    if (!isIterator(iterator)) {\n      return new Iterator(iteratorDone);\n    }\n    var iterations = 0;\n    return new Iterator(function () {\n      var step = iterator.next();\n      return step.done ? step : iteratorValue(type, iterations++, step.value);\n    });\n  };\n\n  return CollectionSeq;\n}(IndexedSeq));\n\n// # pragma Helper functions\n\nvar EMPTY_SEQ;\n\nfunction emptySequence() {\n  return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));\n}\n\nfunction keyedSeqFromValue(value) {\n  var seq = Array.isArray(value)\n    ? new ArraySeq(value)\n    : hasIterator(value)\n      ? new CollectionSeq(value)\n      : undefined;\n  if (seq) {\n    return seq.fromEntrySeq();\n  }\n  if (typeof value === 'object') {\n    return new ObjectSeq(value);\n  }\n  throw new TypeError(\n    'Expected Array or collection object of [k, v] entries, or keyed object: ' +\n      value\n  );\n}\n\nfunction indexedSeqFromValue(value) {\n  var seq = maybeIndexedSeqFromValue(value);\n  if (seq) {\n    return seq;\n  }\n  throw new TypeError(\n    'Expected Array or collection object of values: ' + value\n  );\n}\n\nfunction seqFromValue(value) {\n  var seq = maybeIndexedSeqFromValue(value);\n  if (seq) {\n    return seq;\n  }\n  if (typeof value === 'object') {\n    return new ObjectSeq(value);\n  }\n  throw new TypeError(\n    'Expected Array or collection object of values, or keyed object: ' + value\n  );\n}\n\nfunction maybeIndexedSeqFromValue(value) {\n  return isArrayLike(value)\n    ? new ArraySeq(value)\n    : hasIterator(value)\n      ? new CollectionSeq(value)\n      : undefined;\n}\n\nvar IS_MAP_SYMBOL = '@@__IMMUTABLE_MAP__@@';\n\nfunction isMap(maybeMap) {\n  return Boolean(maybeMap && maybeMap[IS_MAP_SYMBOL]);\n}\n\nfunction isOrderedMap(maybeOrderedMap) {\n  return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);\n}\n\nfunction isValueObject(maybeValue) {\n  return Boolean(\n    maybeValue &&\n      typeof maybeValue.equals === 'function' &&\n      typeof maybeValue.hashCode === 'function'\n  );\n}\n\n/**\n * An extension of the \"same-value\" algorithm as [described for use by ES6 Map\n * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)\n *\n * NaN is considered the same as NaN, however -0 and 0 are considered the same\n * value, which is different from the algorithm described by\n * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).\n *\n * This is extended further to allow Objects to describe the values they\n * represent, by way of `valueOf` or `equals` (and `hashCode`).\n *\n * Note: because of this extension, the key equality of Immutable.Map and the\n * value equality of Immutable.Set will differ from ES6 Map and Set.\n *\n * ### Defining custom values\n *\n * The easiest way to describe the value an object represents is by implementing\n * `valueOf`. For example, `Date` represents a value by returning a unix\n * timestamp for `valueOf`:\n *\n *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...\n *     var date2 = new Date(1234567890000);\n *     date1.valueOf(); // 1234567890000\n *     assert( date1 !== date2 );\n *     assert( Immutable.is( date1, date2 ) );\n *\n * Note: overriding `valueOf` may have other implications if you use this object\n * where JavaScript expects a primitive, such as implicit string coercion.\n *\n * For more complex types, especially collections, implementing `valueOf` may\n * not be performant. An alternative is to implement `equals` and `hashCode`.\n *\n * `equals` takes another object, presumably of similar type, and returns true\n * if it is equal. Equality is symmetrical, so the same result should be\n * returned if this and the argument are flipped.\n *\n *     assert( a.equals(b) === b.equals(a) );\n *\n * `hashCode` returns a 32bit integer number representing the object which will\n * be used to determine how to store the value object in a Map or Set. You must\n * provide both or neither methods, one must not exist without the other.\n *\n * Also, an important relationship between these methods must be upheld: if two\n * values are equal, they *must* return the same hashCode. If the values are not\n * equal, they might have the same hashCode; this is called a hash collision,\n * and while undesirable for performance reasons, it is acceptable.\n *\n *     if (a.equals(b)) {\n *       assert( a.hashCode() === b.hashCode() );\n *     }\n *\n * All Immutable collections are Value Objects: they implement `equals()`\n * and `hashCode()`.\n */\nfunction is(valueA, valueB) {\n  if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n    return true;\n  }\n  if (!valueA || !valueB) {\n    return false;\n  }\n  if (\n    typeof valueA.valueOf === 'function' &&\n    typeof valueB.valueOf === 'function'\n  ) {\n    valueA = valueA.valueOf();\n    valueB = valueB.valueOf();\n    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n      return true;\n    }\n    if (!valueA || !valueB) {\n      return false;\n    }\n  }\n  return !!(\n    isValueObject(valueA) &&\n    isValueObject(valueB) &&\n    valueA.equals(valueB)\n  );\n}\n\nvar imul =\n  typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2\n    ? Math.imul\n    : function imul(a, b) {\n        a |= 0; // int\n        b |= 0; // int\n        var c = a & 0xffff;\n        var d = b & 0xffff;\n        // Shift by 0 fixes the sign on the high part.\n        return (c * d + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0)) | 0; // int\n      };\n\n// v8 has an optimization for storing 31-bit signed numbers.\n// Values which have either 00 or 11 as the high order bits qualify.\n// This function drops the highest order bit in a signed number, maintaining\n// the sign bit.\nfunction smi(i32) {\n  return ((i32 >>> 1) & 0x40000000) | (i32 & 0xbfffffff);\n}\n\nvar defaultValueOf = Object.prototype.valueOf;\n\nfunction hash(o) {\n  switch (typeof o) {\n    case 'boolean':\n      // The hash values for built-in constants are a 1 value for each 5-byte\n      // shift region expect for the first, which encodes the value. This\n      // reduces the odds of a hash collision for these common values.\n      return o ? 0x42108421 : 0x42108420;\n    case 'number':\n      return hashNumber(o);\n    case 'string':\n      return o.length > STRING_HASH_CACHE_MIN_STRLEN\n        ? cachedHashString(o)\n        : hashString(o);\n    case 'object':\n    case 'function':\n      if (o === null) {\n        return 0x42108422;\n      }\n      if (typeof o.hashCode === 'function') {\n        // Drop any high bits from accidentally long hash codes.\n        return smi(o.hashCode(o));\n      }\n      if (o.valueOf !== defaultValueOf && typeof o.valueOf === 'function') {\n        o = o.valueOf(o);\n      }\n      return hashJSObj(o);\n    case 'undefined':\n      return 0x42108423;\n    default:\n      if (typeof o.toString === 'function') {\n        return hashString(o.toString());\n      }\n      throw new Error('Value type ' + typeof o + ' cannot be hashed.');\n  }\n}\n\n// Compress arbitrarily large numbers into smi hashes.\nfunction hashNumber(n) {\n  if (n !== n || n === Infinity) {\n    return 0;\n  }\n  var hash = n | 0;\n  if (hash !== n) {\n    hash ^= n * 0xffffffff;\n  }\n  while (n > 0xffffffff) {\n    n /= 0xffffffff;\n    hash ^= n;\n  }\n  return smi(hash);\n}\n\nfunction cachedHashString(string) {\n  var hashed = stringHashCache[string];\n  if (hashed === undefined) {\n    hashed = hashString(string);\n    if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {\n      STRING_HASH_CACHE_SIZE = 0;\n      stringHashCache = {};\n    }\n    STRING_HASH_CACHE_SIZE++;\n    stringHashCache[string] = hashed;\n  }\n  return hashed;\n}\n\n// http://jsperf.com/hashing-strings\nfunction hashString(string) {\n  // This is the hash from JVM\n  // The hash code for a string is computed as\n  // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],\n  // where s[i] is the ith character of the string and n is the length of\n  // the string. We \"mod\" the result to make it between 0 (inclusive) and 2^31\n  // (exclusive) by dropping high bits.\n  var hashed = 0;\n  for (var ii = 0; ii < string.length; ii++) {\n    hashed = (31 * hashed + string.charCodeAt(ii)) | 0;\n  }\n  return smi(hashed);\n}\n\nfunction hashJSObj(obj) {\n  var hashed;\n  if (usingWeakMap) {\n    hashed = weakMap.get(obj);\n    if (hashed !== undefined) {\n      return hashed;\n    }\n  }\n\n  hashed = obj[UID_HASH_KEY];\n  if (hashed !== undefined) {\n    return hashed;\n  }\n\n  if (!canDefineProperty) {\n    hashed = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];\n    if (hashed !== undefined) {\n      return hashed;\n    }\n\n    hashed = getIENodeHash(obj);\n    if (hashed !== undefined) {\n      return hashed;\n    }\n  }\n\n  hashed = ++objHashUID;\n  if (objHashUID & 0x40000000) {\n    objHashUID = 0;\n  }\n\n  if (usingWeakMap) {\n    weakMap.set(obj, hashed);\n  } else if (isExtensible !== undefined && isExtensible(obj) === false) {\n    throw new Error('Non-extensible objects are not allowed as keys.');\n  } else if (canDefineProperty) {\n    Object.defineProperty(obj, UID_HASH_KEY, {\n      enumerable: false,\n      configurable: false,\n      writable: false,\n      value: hashed,\n    });\n  } else if (\n    obj.propertyIsEnumerable !== undefined &&\n    obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable\n  ) {\n    // Since we can't define a non-enumerable property on the object\n    // we'll hijack one of the less-used non-enumerable properties to\n    // save our hash on it. Since this is a function it will not show up in\n    // `JSON.stringify` which is what we want.\n    obj.propertyIsEnumerable = function() {\n      return this.constructor.prototype.propertyIsEnumerable.apply(\n        this,\n        arguments\n      );\n    };\n    obj.propertyIsEnumerable[UID_HASH_KEY] = hashed;\n  } else if (obj.nodeType !== undefined) {\n    // At this point we couldn't get the IE `uniqueID` to use as a hash\n    // and we couldn't use a non-enumerable property to exploit the\n    // dontEnum bug so we simply add the `UID_HASH_KEY` on the node\n    // itself.\n    obj[UID_HASH_KEY] = hashed;\n  } else {\n    throw new Error('Unable to set a non-enumerable property on object.');\n  }\n\n  return hashed;\n}\n\n// Get references to ES5 object methods.\nvar isExtensible = Object.isExtensible;\n\n// True if Object.defineProperty works as expected. IE8 fails this test.\nvar canDefineProperty = (function() {\n  try {\n    Object.defineProperty({}, '@', {});\n    return true;\n  } catch (e) {\n    return false;\n  }\n})();\n\n// IE has a `uniqueID` property on DOM nodes. We can construct the hash from it\n// and avoid memory leaks from the IE cloneNode bug.\nfunction getIENodeHash(node) {\n  if (node && node.nodeType > 0) {\n    switch (node.nodeType) {\n      case 1: // Element\n        return node.uniqueID;\n      case 9: // Document\n        return node.documentElement && node.documentElement.uniqueID;\n    }\n  }\n}\n\n// If possible, use a WeakMap.\nvar usingWeakMap = typeof WeakMap === 'function';\nvar weakMap;\nif (usingWeakMap) {\n  weakMap = new WeakMap();\n}\n\nvar objHashUID = 0;\n\nvar UID_HASH_KEY = '__immutablehash__';\nif (typeof Symbol === 'function') {\n  UID_HASH_KEY = Symbol(UID_HASH_KEY);\n}\n\nvar STRING_HASH_CACHE_MIN_STRLEN = 16;\nvar STRING_HASH_CACHE_MAX_SIZE = 255;\nvar STRING_HASH_CACHE_SIZE = 0;\nvar stringHashCache = {};\n\nvar ToKeyedSequence = /*@__PURE__*/(function (KeyedSeq$$1) {\n  function ToKeyedSequence(indexed, useKeys) {\n    this._iter = indexed;\n    this._useKeys = useKeys;\n    this.size = indexed.size;\n  }\n\n  if ( KeyedSeq$$1 ) ToKeyedSequence.__proto__ = KeyedSeq$$1;\n  ToKeyedSequence.prototype = Object.create( KeyedSeq$$1 && KeyedSeq$$1.prototype );\n  ToKeyedSequence.prototype.constructor = ToKeyedSequence;\n\n  ToKeyedSequence.prototype.get = function get (key, notSetValue) {\n    return this._iter.get(key, notSetValue);\n  };\n\n  ToKeyedSequence.prototype.has = function has (key) {\n    return this._iter.has(key);\n  };\n\n  ToKeyedSequence.prototype.valueSeq = function valueSeq () {\n    return this._iter.valueSeq();\n  };\n\n  ToKeyedSequence.prototype.reverse = function reverse () {\n    var this$1 = this;\n\n    var reversedSequence = reverseFactory(this, true);\n    if (!this._useKeys) {\n      reversedSequence.valueSeq = function () { return this$1._iter.toSeq().reverse(); };\n    }\n    return reversedSequence;\n  };\n\n  ToKeyedSequence.prototype.map = function map (mapper, context) {\n    var this$1 = this;\n\n    var mappedSequence = mapFactory(this, mapper, context);\n    if (!this._useKeys) {\n      mappedSequence.valueSeq = function () { return this$1._iter.toSeq().map(mapper, context); };\n    }\n    return mappedSequence;\n  };\n\n  ToKeyedSequence.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    return this._iter.__iterate(function (v, k) { return fn(v, k, this$1); }, reverse);\n  };\n\n  ToKeyedSequence.prototype.__iterator = function __iterator (type, reverse) {\n    return this._iter.__iterator(type, reverse);\n  };\n\n  return ToKeyedSequence;\n}(KeyedSeq));\nToKeyedSequence.prototype[IS_ORDERED_SYMBOL] = true;\n\nvar ToIndexedSequence = /*@__PURE__*/(function (IndexedSeq$$1) {\n  function ToIndexedSequence(iter) {\n    this._iter = iter;\n    this.size = iter.size;\n  }\n\n  if ( IndexedSeq$$1 ) ToIndexedSequence.__proto__ = IndexedSeq$$1;\n  ToIndexedSequence.prototype = Object.create( IndexedSeq$$1 && IndexedSeq$$1.prototype );\n  ToIndexedSequence.prototype.constructor = ToIndexedSequence;\n\n  ToIndexedSequence.prototype.includes = function includes (value) {\n    return this._iter.includes(value);\n  };\n\n  ToIndexedSequence.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    var i = 0;\n    reverse && ensureSize(this);\n    return this._iter.__iterate(\n      function (v) { return fn(v, reverse ? this$1.size - ++i : i++, this$1); },\n      reverse\n    );\n  };\n\n  ToIndexedSequence.prototype.__iterator = function __iterator (type, reverse) {\n    var this$1 = this;\n\n    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n    var i = 0;\n    reverse && ensureSize(this);\n    return new Iterator(function () {\n      var step = iterator.next();\n      return step.done\n        ? step\n        : iteratorValue(\n            type,\n            reverse ? this$1.size - ++i : i++,\n            step.value,\n            step\n          );\n    });\n  };\n\n  return ToIndexedSequence;\n}(IndexedSeq));\n\nvar ToSetSequence = /*@__PURE__*/(function (SetSeq$$1) {\n  function ToSetSequence(iter) {\n    this._iter = iter;\n    this.size = iter.size;\n  }\n\n  if ( SetSeq$$1 ) ToSetSequence.__proto__ = SetSeq$$1;\n  ToSetSequence.prototype = Object.create( SetSeq$$1 && SetSeq$$1.prototype );\n  ToSetSequence.prototype.constructor = ToSetSequence;\n\n  ToSetSequence.prototype.has = function has (key) {\n    return this._iter.includes(key);\n  };\n\n  ToSetSequence.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    return this._iter.__iterate(function (v) { return fn(v, v, this$1); }, reverse);\n  };\n\n  ToSetSequence.prototype.__iterator = function __iterator (type, reverse) {\n    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n    return new Iterator(function () {\n      var step = iterator.next();\n      return step.done\n        ? step\n        : iteratorValue(type, step.value, step.value, step);\n    });\n  };\n\n  return ToSetSequence;\n}(SetSeq));\n\nvar FromEntriesSequence = /*@__PURE__*/(function (KeyedSeq$$1) {\n  function FromEntriesSequence(entries) {\n    this._iter = entries;\n    this.size = entries.size;\n  }\n\n  if ( KeyedSeq$$1 ) FromEntriesSequence.__proto__ = KeyedSeq$$1;\n  FromEntriesSequence.prototype = Object.create( KeyedSeq$$1 && KeyedSeq$$1.prototype );\n  FromEntriesSequence.prototype.constructor = FromEntriesSequence;\n\n  FromEntriesSequence.prototype.entrySeq = function entrySeq () {\n    return this._iter.toSeq();\n  };\n\n  FromEntriesSequence.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    return this._iter.__iterate(function (entry) {\n      // Check if entry exists first so array access doesn't throw for holes\n      // in the parent iteration.\n      if (entry) {\n        validateEntry(entry);\n        var indexedCollection = isCollection(entry);\n        return fn(\n          indexedCollection ? entry.get(1) : entry[1],\n          indexedCollection ? entry.get(0) : entry[0],\n          this$1\n        );\n      }\n    }, reverse);\n  };\n\n  FromEntriesSequence.prototype.__iterator = function __iterator (type, reverse) {\n    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n    return new Iterator(function () {\n      while (true) {\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        // Check if entry exists first so array access doesn't throw for holes\n        // in the parent iteration.\n        if (entry) {\n          validateEntry(entry);\n          var indexedCollection = isCollection(entry);\n          return iteratorValue(\n            type,\n            indexedCollection ? entry.get(0) : entry[0],\n            indexedCollection ? entry.get(1) : entry[1],\n            step\n          );\n        }\n      }\n    });\n  };\n\n  return FromEntriesSequence;\n}(KeyedSeq));\n\nToIndexedSequence.prototype.cacheResult = ToKeyedSequence.prototype.cacheResult = ToSetSequence.prototype.cacheResult = FromEntriesSequence.prototype.cacheResult = cacheResultThrough;\n\nfunction flipFactory(collection) {\n  var flipSequence = makeSequence(collection);\n  flipSequence._iter = collection;\n  flipSequence.size = collection.size;\n  flipSequence.flip = function () { return collection; };\n  flipSequence.reverse = function() {\n    var reversedSequence = collection.reverse.apply(this); // super.reverse()\n    reversedSequence.flip = function () { return collection.reverse(); };\n    return reversedSequence;\n  };\n  flipSequence.has = function (key) { return collection.includes(key); };\n  flipSequence.includes = function (key) { return collection.has(key); };\n  flipSequence.cacheResult = cacheResultThrough;\n  flipSequence.__iterateUncached = function(fn, reverse) {\n    var this$1 = this;\n\n    return collection.__iterate(function (v, k) { return fn(k, v, this$1) !== false; }, reverse);\n  };\n  flipSequence.__iteratorUncached = function(type, reverse) {\n    if (type === ITERATE_ENTRIES) {\n      var iterator = collection.__iterator(type, reverse);\n      return new Iterator(function () {\n        var step = iterator.next();\n        if (!step.done) {\n          var k = step.value[0];\n          step.value[0] = step.value[1];\n          step.value[1] = k;\n        }\n        return step;\n      });\n    }\n    return collection.__iterator(\n      type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,\n      reverse\n    );\n  };\n  return flipSequence;\n}\n\nfunction mapFactory(collection, mapper, context) {\n  var mappedSequence = makeSequence(collection);\n  mappedSequence.size = collection.size;\n  mappedSequence.has = function (key) { return collection.has(key); };\n  mappedSequence.get = function (key, notSetValue) {\n    var v = collection.get(key, NOT_SET);\n    return v === NOT_SET\n      ? notSetValue\n      : mapper.call(context, v, key, collection);\n  };\n  mappedSequence.__iterateUncached = function(fn, reverse) {\n    var this$1 = this;\n\n    return collection.__iterate(\n      function (v, k, c) { return fn(mapper.call(context, v, k, c), k, this$1) !== false; },\n      reverse\n    );\n  };\n  mappedSequence.__iteratorUncached = function(type, reverse) {\n    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n    return new Iterator(function () {\n      var step = iterator.next();\n      if (step.done) {\n        return step;\n      }\n      var entry = step.value;\n      var key = entry[0];\n      return iteratorValue(\n        type,\n        key,\n        mapper.call(context, entry[1], key, collection),\n        step\n      );\n    });\n  };\n  return mappedSequence;\n}\n\nfunction reverseFactory(collection, useKeys) {\n  var this$1 = this;\n\n  var reversedSequence = makeSequence(collection);\n  reversedSequence._iter = collection;\n  reversedSequence.size = collection.size;\n  reversedSequence.reverse = function () { return collection; };\n  if (collection.flip) {\n    reversedSequence.flip = function() {\n      var flipSequence = flipFactory(collection);\n      flipSequence.reverse = function () { return collection.flip(); };\n      return flipSequence;\n    };\n  }\n  reversedSequence.get = function (key, notSetValue) { return collection.get(useKeys ? key : -1 - key, notSetValue); };\n  reversedSequence.has = function (key) { return collection.has(useKeys ? key : -1 - key); };\n  reversedSequence.includes = function (value) { return collection.includes(value); };\n  reversedSequence.cacheResult = cacheResultThrough;\n  reversedSequence.__iterate = function(fn, reverse) {\n    var this$1 = this;\n\n    var i = 0;\n    reverse && ensureSize(collection);\n    return collection.__iterate(\n      function (v, k) { return fn(v, useKeys ? k : reverse ? this$1.size - ++i : i++, this$1); },\n      !reverse\n    );\n  };\n  reversedSequence.__iterator = function (type, reverse) {\n    var i = 0;\n    reverse && ensureSize(collection);\n    var iterator = collection.__iterator(ITERATE_ENTRIES, !reverse);\n    return new Iterator(function () {\n      var step = iterator.next();\n      if (step.done) {\n        return step;\n      }\n      var entry = step.value;\n      return iteratorValue(\n        type,\n        useKeys ? entry[0] : reverse ? this$1.size - ++i : i++,\n        entry[1],\n        step\n      );\n    });\n  };\n  return reversedSequence;\n}\n\nfunction filterFactory(collection, predicate, context, useKeys) {\n  var filterSequence = makeSequence(collection);\n  if (useKeys) {\n    filterSequence.has = function (key) {\n      var v = collection.get(key, NOT_SET);\n      return v !== NOT_SET && !!predicate.call(context, v, key, collection);\n    };\n    filterSequence.get = function (key, notSetValue) {\n      var v = collection.get(key, NOT_SET);\n      return v !== NOT_SET && predicate.call(context, v, key, collection)\n        ? v\n        : notSetValue;\n    };\n  }\n  filterSequence.__iterateUncached = function(fn, reverse) {\n    var this$1 = this;\n\n    var iterations = 0;\n    collection.__iterate(function (v, k, c) {\n      if (predicate.call(context, v, k, c)) {\n        iterations++;\n        return fn(v, useKeys ? k : iterations - 1, this$1);\n      }\n    }, reverse);\n    return iterations;\n  };\n  filterSequence.__iteratorUncached = function(type, reverse) {\n    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n    var iterations = 0;\n    return new Iterator(function () {\n      while (true) {\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        var key = entry[0];\n        var value = entry[1];\n        if (predicate.call(context, value, key, collection)) {\n          return iteratorValue(type, useKeys ? key : iterations++, value, step);\n        }\n      }\n    });\n  };\n  return filterSequence;\n}\n\nfunction countByFactory(collection, grouper, context) {\n  var groups = Map().asMutable();\n  collection.__iterate(function (v, k) {\n    groups.update(grouper.call(context, v, k, collection), 0, function (a) { return a + 1; });\n  });\n  return groups.asImmutable();\n}\n\nfunction groupByFactory(collection, grouper, context) {\n  var isKeyedIter = isKeyed(collection);\n  var groups = (isOrdered(collection) ? OrderedMap() : Map()).asMutable();\n  collection.__iterate(function (v, k) {\n    groups.update(\n      grouper.call(context, v, k, collection),\n      function (a) { return ((a = a || []), a.push(isKeyedIter ? [k, v] : v), a); }\n    );\n  });\n  var coerce = collectionClass(collection);\n  return groups.map(function (arr) { return reify(collection, coerce(arr)); }).asImmutable();\n}\n\nfunction sliceFactory(collection, begin, end, useKeys) {\n  var originalSize = collection.size;\n\n  if (wholeSlice(begin, end, originalSize)) {\n    return collection;\n  }\n\n  var resolvedBegin = resolveBegin(begin, originalSize);\n  var resolvedEnd = resolveEnd(end, originalSize);\n\n  // begin or end will be NaN if they were provided as negative numbers and\n  // this collection's size is unknown. In that case, cache first so there is\n  // a known size and these do not resolve to NaN.\n  if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {\n    return sliceFactory(collection.toSeq().cacheResult(), begin, end, useKeys);\n  }\n\n  // Note: resolvedEnd is undefined when the original sequence's length is\n  // unknown and this slice did not supply an end and should contain all\n  // elements after resolvedBegin.\n  // In that case, resolvedSize will be NaN and sliceSize will remain undefined.\n  var resolvedSize = resolvedEnd - resolvedBegin;\n  var sliceSize;\n  if (resolvedSize === resolvedSize) {\n    sliceSize = resolvedSize < 0 ? 0 : resolvedSize;\n  }\n\n  var sliceSeq = makeSequence(collection);\n\n  // If collection.size is undefined, the size of the realized sliceSeq is\n  // unknown at this point unless the number of items to slice is 0\n  sliceSeq.size =\n    sliceSize === 0 ? sliceSize : (collection.size && sliceSize) || undefined;\n\n  if (!useKeys && isSeq(collection) && sliceSize >= 0) {\n    sliceSeq.get = function(index, notSetValue) {\n      index = wrapIndex(this, index);\n      return index >= 0 && index < sliceSize\n        ? collection.get(index + resolvedBegin, notSetValue)\n        : notSetValue;\n    };\n  }\n\n  sliceSeq.__iterateUncached = function(fn, reverse) {\n    var this$1 = this;\n\n    if (sliceSize === 0) {\n      return 0;\n    }\n    if (reverse) {\n      return this.cacheResult().__iterate(fn, reverse);\n    }\n    var skipped = 0;\n    var isSkipping = true;\n    var iterations = 0;\n    collection.__iterate(function (v, k) {\n      if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {\n        iterations++;\n        return (\n          fn(v, useKeys ? k : iterations - 1, this$1) !== false &&\n          iterations !== sliceSize\n        );\n      }\n    });\n    return iterations;\n  };\n\n  sliceSeq.__iteratorUncached = function(type, reverse) {\n    if (sliceSize !== 0 && reverse) {\n      return this.cacheResult().__iterator(type, reverse);\n    }\n    // Don't bother instantiating parent iterator if taking 0.\n    if (sliceSize === 0) {\n      return new Iterator(iteratorDone);\n    }\n    var iterator = collection.__iterator(type, reverse);\n    var skipped = 0;\n    var iterations = 0;\n    return new Iterator(function () {\n      while (skipped++ < resolvedBegin) {\n        iterator.next();\n      }\n      if (++iterations > sliceSize) {\n        return iteratorDone();\n      }\n      var step = iterator.next();\n      if (useKeys || type === ITERATE_VALUES || step.done) {\n        return step;\n      }\n      if (type === ITERATE_KEYS) {\n        return iteratorValue(type, iterations - 1, undefined, step);\n      }\n      return iteratorValue(type, iterations - 1, step.value[1], step);\n    });\n  };\n\n  return sliceSeq;\n}\n\nfunction takeWhileFactory(collection, predicate, context) {\n  var takeSequence = makeSequence(collection);\n  takeSequence.__iterateUncached = function(fn, reverse) {\n    var this$1 = this;\n\n    if (reverse) {\n      return this.cacheResult().__iterate(fn, reverse);\n    }\n    var iterations = 0;\n    collection.__iterate(\n      function (v, k, c) { return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$1); }\n    );\n    return iterations;\n  };\n  takeSequence.__iteratorUncached = function(type, reverse) {\n    var this$1 = this;\n\n    if (reverse) {\n      return this.cacheResult().__iterator(type, reverse);\n    }\n    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n    var iterating = true;\n    return new Iterator(function () {\n      if (!iterating) {\n        return iteratorDone();\n      }\n      var step = iterator.next();\n      if (step.done) {\n        return step;\n      }\n      var entry = step.value;\n      var k = entry[0];\n      var v = entry[1];\n      if (!predicate.call(context, v, k, this$1)) {\n        iterating = false;\n        return iteratorDone();\n      }\n      return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);\n    });\n  };\n  return takeSequence;\n}\n\nfunction skipWhileFactory(collection, predicate, context, useKeys) {\n  var skipSequence = makeSequence(collection);\n  skipSequence.__iterateUncached = function(fn, reverse) {\n    var this$1 = this;\n\n    if (reverse) {\n      return this.cacheResult().__iterate(fn, reverse);\n    }\n    var isSkipping = true;\n    var iterations = 0;\n    collection.__iterate(function (v, k, c) {\n      if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {\n        iterations++;\n        return fn(v, useKeys ? k : iterations - 1, this$1);\n      }\n    });\n    return iterations;\n  };\n  skipSequence.__iteratorUncached = function(type, reverse) {\n    var this$1 = this;\n\n    if (reverse) {\n      return this.cacheResult().__iterator(type, reverse);\n    }\n    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n    var skipping = true;\n    var iterations = 0;\n    return new Iterator(function () {\n      var step;\n      var k;\n      var v;\n      do {\n        step = iterator.next();\n        if (step.done) {\n          if (useKeys || type === ITERATE_VALUES) {\n            return step;\n          }\n          if (type === ITERATE_KEYS) {\n            return iteratorValue(type, iterations++, undefined, step);\n          }\n          return iteratorValue(type, iterations++, step.value[1], step);\n        }\n        var entry = step.value;\n        k = entry[0];\n        v = entry[1];\n        skipping && (skipping = predicate.call(context, v, k, this$1));\n      } while (skipping);\n      return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);\n    });\n  };\n  return skipSequence;\n}\n\nfunction concatFactory(collection, values) {\n  var isKeyedCollection = isKeyed(collection);\n  var iters = [collection]\n    .concat(values)\n    .map(function (v) {\n      if (!isCollection(v)) {\n        v = isKeyedCollection\n          ? keyedSeqFromValue(v)\n          : indexedSeqFromValue(Array.isArray(v) ? v : [v]);\n      } else if (isKeyedCollection) {\n        v = KeyedCollection(v);\n      }\n      return v;\n    })\n    .filter(function (v) { return v.size !== 0; });\n\n  if (iters.length === 0) {\n    return collection;\n  }\n\n  if (iters.length === 1) {\n    var singleton = iters[0];\n    if (\n      singleton === collection ||\n      (isKeyedCollection && isKeyed(singleton)) ||\n      (isIndexed(collection) && isIndexed(singleton))\n    ) {\n      return singleton;\n    }\n  }\n\n  var concatSeq = new ArraySeq(iters);\n  if (isKeyedCollection) {\n    concatSeq = concatSeq.toKeyedSeq();\n  } else if (!isIndexed(collection)) {\n    concatSeq = concatSeq.toSetSeq();\n  }\n  concatSeq = concatSeq.flatten(true);\n  concatSeq.size = iters.reduce(function (sum, seq) {\n    if (sum !== undefined) {\n      var size = seq.size;\n      if (size !== undefined) {\n        return sum + size;\n      }\n    }\n  }, 0);\n  return concatSeq;\n}\n\nfunction flattenFactory(collection, depth, useKeys) {\n  var flatSequence = makeSequence(collection);\n  flatSequence.__iterateUncached = function(fn, reverse) {\n    if (reverse) {\n      return this.cacheResult().__iterate(fn, reverse);\n    }\n    var iterations = 0;\n    var stopped = false;\n    function flatDeep(iter, currentDepth) {\n      iter.__iterate(function (v, k) {\n        if ((!depth || currentDepth < depth) && isCollection(v)) {\n          flatDeep(v, currentDepth + 1);\n        } else {\n          iterations++;\n          if (fn(v, useKeys ? k : iterations - 1, flatSequence) === false) {\n            stopped = true;\n          }\n        }\n        return !stopped;\n      }, reverse);\n    }\n    flatDeep(collection, 0);\n    return iterations;\n  };\n  flatSequence.__iteratorUncached = function(type, reverse) {\n    if (reverse) {\n      return this.cacheResult().__iterator(type, reverse);\n    }\n    var iterator = collection.__iterator(type, reverse);\n    var stack = [];\n    var iterations = 0;\n    return new Iterator(function () {\n      while (iterator) {\n        var step = iterator.next();\n        if (step.done !== false) {\n          iterator = stack.pop();\n          continue;\n        }\n        var v = step.value;\n        if (type === ITERATE_ENTRIES) {\n          v = v[1];\n        }\n        if ((!depth || stack.length < depth) && isCollection(v)) {\n          stack.push(iterator);\n          iterator = v.__iterator(type, reverse);\n        } else {\n          return useKeys ? step : iteratorValue(type, iterations++, v, step);\n        }\n      }\n      return iteratorDone();\n    });\n  };\n  return flatSequence;\n}\n\nfunction flatMapFactory(collection, mapper, context) {\n  var coerce = collectionClass(collection);\n  return collection\n    .toSeq()\n    .map(function (v, k) { return coerce(mapper.call(context, v, k, collection)); })\n    .flatten(true);\n}\n\nfunction interposeFactory(collection, separator) {\n  var interposedSequence = makeSequence(collection);\n  interposedSequence.size = collection.size && collection.size * 2 - 1;\n  interposedSequence.__iterateUncached = function(fn, reverse) {\n    var this$1 = this;\n\n    var iterations = 0;\n    collection.__iterate(\n      function (v) { return (!iterations || fn(separator, iterations++, this$1) !== false) &&\n        fn(v, iterations++, this$1) !== false; },\n      reverse\n    );\n    return iterations;\n  };\n  interposedSequence.__iteratorUncached = function(type, reverse) {\n    var iterator = collection.__iterator(ITERATE_VALUES, reverse);\n    var iterations = 0;\n    var step;\n    return new Iterator(function () {\n      if (!step || iterations % 2) {\n        step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n      }\n      return iterations % 2\n        ? iteratorValue(type, iterations++, separator)\n        : iteratorValue(type, iterations++, step.value, step);\n    });\n  };\n  return interposedSequence;\n}\n\nfunction sortFactory(collection, comparator, mapper) {\n  if (!comparator) {\n    comparator = defaultComparator;\n  }\n  var isKeyedCollection = isKeyed(collection);\n  var index = 0;\n  var entries = collection\n    .toSeq()\n    .map(function (v, k) { return [k, v, index++, mapper ? mapper(v, k, collection) : v]; })\n    .valueSeq()\n    .toArray();\n  entries.sort(function (a, b) { return comparator(a[3], b[3]) || a[2] - b[2]; }).forEach(\n    isKeyedCollection\n      ? function (v, i) {\n          entries[i].length = 2;\n        }\n      : function (v, i) {\n          entries[i] = v[1];\n        }\n  );\n  return isKeyedCollection\n    ? KeyedSeq(entries)\n    : isIndexed(collection)\n      ? IndexedSeq(entries)\n      : SetSeq(entries);\n}\n\nfunction maxFactory(collection, comparator, mapper) {\n  if (!comparator) {\n    comparator = defaultComparator;\n  }\n  if (mapper) {\n    var entry = collection\n      .toSeq()\n      .map(function (v, k) { return [v, mapper(v, k, collection)]; })\n      .reduce(function (a, b) { return (maxCompare(comparator, a[1], b[1]) ? b : a); });\n    return entry && entry[0];\n  }\n  return collection.reduce(function (a, b) { return (maxCompare(comparator, a, b) ? b : a); });\n}\n\nfunction maxCompare(comparator, a, b) {\n  var comp = comparator(b, a);\n  // b is considered the new max if the comparator declares them equal, but\n  // they are not equal and b is in fact a nullish value.\n  return (\n    (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) ||\n    comp > 0\n  );\n}\n\nfunction zipWithFactory(keyIter, zipper, iters, zipAll) {\n  var zipSequence = makeSequence(keyIter);\n  var sizes = new ArraySeq(iters).map(function (i) { return i.size; });\n  zipSequence.size = zipAll ? sizes.max() : sizes.min();\n  // Note: this a generic base implementation of __iterate in terms of\n  // __iterator which may be more generically useful in the future.\n  zipSequence.__iterate = function(fn, reverse) {\n    /* generic:\n    var iterator = this.__iterator(ITERATE_ENTRIES, reverse);\n    var step;\n    var iterations = 0;\n    while (!(step = iterator.next()).done) {\n      iterations++;\n      if (fn(step.value[1], step.value[0], this) === false) {\n        break;\n      }\n    }\n    return iterations;\n    */\n    // indexed:\n    var iterator = this.__iterator(ITERATE_VALUES, reverse);\n    var step;\n    var iterations = 0;\n    while (!(step = iterator.next()).done) {\n      if (fn(step.value, iterations++, this) === false) {\n        break;\n      }\n    }\n    return iterations;\n  };\n  zipSequence.__iteratorUncached = function(type, reverse) {\n    var iterators = iters.map(\n      function (i) { return ((i = Collection(i)), getIterator(reverse ? i.reverse() : i)); }\n    );\n    var iterations = 0;\n    var isDone = false;\n    return new Iterator(function () {\n      var steps;\n      if (!isDone) {\n        steps = iterators.map(function (i) { return i.next(); });\n        isDone = zipAll ? steps.every(function (s) { return s.done; }) : steps.some(function (s) { return s.done; });\n      }\n      if (isDone) {\n        return iteratorDone();\n      }\n      return iteratorValue(\n        type,\n        iterations++,\n        zipper.apply(null, steps.map(function (s) { return s.value; }))\n      );\n    });\n  };\n  return zipSequence;\n}\n\n// #pragma Helper Functions\n\nfunction reify(iter, seq) {\n  return iter === seq ? iter : isSeq(iter) ? seq : iter.constructor(seq);\n}\n\nfunction validateEntry(entry) {\n  if (entry !== Object(entry)) {\n    throw new TypeError('Expected [K, V] tuple: ' + entry);\n  }\n}\n\nfunction collectionClass(collection) {\n  return isKeyed(collection)\n    ? KeyedCollection\n    : isIndexed(collection)\n      ? IndexedCollection\n      : SetCollection;\n}\n\nfunction makeSequence(collection) {\n  return Object.create(\n    (isKeyed(collection)\n      ? KeyedSeq\n      : isIndexed(collection)\n        ? IndexedSeq\n        : SetSeq\n    ).prototype\n  );\n}\n\nfunction cacheResultThrough() {\n  if (this._iter.cacheResult) {\n    this._iter.cacheResult();\n    this.size = this._iter.size;\n    return this;\n  }\n  return Seq.prototype.cacheResult.call(this);\n}\n\nfunction defaultComparator(a, b) {\n  if (a === undefined && b === undefined) {\n    return 0;\n  }\n\n  if (a === undefined) {\n    return 1;\n  }\n\n  if (b === undefined) {\n    return -1;\n  }\n\n  return a > b ? 1 : a < b ? -1 : 0;\n}\n\n// http://jsperf.com/copy-array-inline\nfunction arrCopy(arr, offset) {\n  offset = offset || 0;\n  var len = Math.max(0, arr.length - offset);\n  var newArr = new Array(len);\n  for (var ii = 0; ii < len; ii++) {\n    newArr[ii] = arr[ii + offset];\n  }\n  return newArr;\n}\n\nfunction invariant(condition, error) {\n  if (!condition) { throw new Error(error); }\n}\n\nfunction assertNotInfinite(size) {\n  invariant(\n    size !== Infinity,\n    'Cannot perform this action with an infinite size.'\n  );\n}\n\nfunction coerceKeyPath(keyPath) {\n  if (isArrayLike(keyPath) && typeof keyPath !== 'string') {\n    return keyPath;\n  }\n  if (isOrdered(keyPath)) {\n    return keyPath.toArray();\n  }\n  throw new TypeError(\n    'Invalid keyPath: expected Ordered Collection or Array: ' + keyPath\n  );\n}\n\nfunction isPlainObj(value) {\n  return (\n    value &&\n    (typeof value.constructor !== 'function' ||\n      value.constructor.name === 'Object')\n  );\n}\n\n/**\n * Returns true if the value is a potentially-persistent data structure, either\n * provided by Immutable.js or a plain Array or Object.\n */\nfunction isDataStructure(value) {\n  return (\n    typeof value === 'object' &&\n    (isImmutable(value) || Array.isArray(value) || isPlainObj(value))\n  );\n}\n\n/**\n * Converts a value to a string, adding quotes if a string was provided.\n */\nfunction quoteString(value) {\n  try {\n    return typeof value === 'string' ? JSON.stringify(value) : String(value);\n  } catch (_ignoreError) {\n    return JSON.stringify(value);\n  }\n}\n\nfunction has(collection, key) {\n  return isImmutable(collection)\n    ? collection.has(key)\n    : isDataStructure(collection) && hasOwnProperty.call(collection, key);\n}\n\nfunction get(collection, key, notSetValue) {\n  return isImmutable(collection)\n    ? collection.get(key, notSetValue)\n    : !has(collection, key)\n      ? notSetValue\n      : typeof collection.get === 'function'\n        ? collection.get(key)\n        : collection[key];\n}\n\nfunction shallowCopy(from) {\n  if (Array.isArray(from)) {\n    return arrCopy(from);\n  }\n  var to = {};\n  for (var key in from) {\n    if (hasOwnProperty.call(from, key)) {\n      to[key] = from[key];\n    }\n  }\n  return to;\n}\n\nfunction remove(collection, key) {\n  if (!isDataStructure(collection)) {\n    throw new TypeError(\n      'Cannot update non-data-structure value: ' + collection\n    );\n  }\n  if (isImmutable(collection)) {\n    if (!collection.remove) {\n      throw new TypeError(\n        'Cannot update immutable value without .remove() method: ' + collection\n      );\n    }\n    return collection.remove(key);\n  }\n  if (!hasOwnProperty.call(collection, key)) {\n    return collection;\n  }\n  var collectionCopy = shallowCopy(collection);\n  if (Array.isArray(collectionCopy)) {\n    collectionCopy.splice(key, 1);\n  } else {\n    delete collectionCopy[key];\n  }\n  return collectionCopy;\n}\n\nfunction set(collection, key, value) {\n  if (!isDataStructure(collection)) {\n    throw new TypeError(\n      'Cannot update non-data-structure value: ' + collection\n    );\n  }\n  if (isImmutable(collection)) {\n    if (!collection.set) {\n      throw new TypeError(\n        'Cannot update immutable value without .set() method: ' + collection\n      );\n    }\n    return collection.set(key, value);\n  }\n  if (hasOwnProperty.call(collection, key) && value === collection[key]) {\n    return collection;\n  }\n  var collectionCopy = shallowCopy(collection);\n  collectionCopy[key] = value;\n  return collectionCopy;\n}\n\nfunction updateIn(collection, keyPath, notSetValue, updater) {\n  if (!updater) {\n    updater = notSetValue;\n    notSetValue = undefined;\n  }\n  var updatedValue = updateInDeeply(\n    isImmutable(collection),\n    collection,\n    coerceKeyPath(keyPath),\n    0,\n    notSetValue,\n    updater\n  );\n  return updatedValue === NOT_SET ? notSetValue : updatedValue;\n}\n\nfunction updateInDeeply(\n  inImmutable,\n  existing,\n  keyPath,\n  i,\n  notSetValue,\n  updater\n) {\n  var wasNotSet = existing === NOT_SET;\n  if (i === keyPath.length) {\n    var existingValue = wasNotSet ? notSetValue : existing;\n    var newValue = updater(existingValue);\n    return newValue === existingValue ? existing : newValue;\n  }\n  if (!wasNotSet && !isDataStructure(existing)) {\n    throw new TypeError(\n      'Cannot update within non-data-structure value in path [' +\n        keyPath.slice(0, i).map(quoteString) +\n        ']: ' +\n        existing\n    );\n  }\n  var key = keyPath[i];\n  var nextExisting = wasNotSet ? NOT_SET : get(existing, key, NOT_SET);\n  var nextUpdated = updateInDeeply(\n    nextExisting === NOT_SET ? inImmutable : isImmutable(nextExisting),\n    nextExisting,\n    keyPath,\n    i + 1,\n    notSetValue,\n    updater\n  );\n  return nextUpdated === nextExisting\n    ? existing\n    : nextUpdated === NOT_SET\n      ? remove(existing, key)\n      : set(\n          wasNotSet ? (inImmutable ? emptyMap() : {}) : existing,\n          key,\n          nextUpdated\n        );\n}\n\nfunction setIn(collection, keyPath, value) {\n  return updateIn(collection, keyPath, NOT_SET, function () { return value; });\n}\n\nfunction setIn$1(keyPath, v) {\n  return setIn(this, keyPath, v);\n}\n\nfunction removeIn(collection, keyPath) {\n  return updateIn(collection, keyPath, function () { return NOT_SET; });\n}\n\nfunction deleteIn(keyPath) {\n  return removeIn(this, keyPath);\n}\n\nfunction update(collection, key, notSetValue, updater) {\n  return updateIn(collection, [key], notSetValue, updater);\n}\n\nfunction update$1(key, notSetValue, updater) {\n  return arguments.length === 1\n    ? key(this)\n    : update(this, key, notSetValue, updater);\n}\n\nfunction updateIn$1(keyPath, notSetValue, updater) {\n  return updateIn(this, keyPath, notSetValue, updater);\n}\n\nfunction merge() {\n  var iters = [], len = arguments.length;\n  while ( len-- ) iters[ len ] = arguments[ len ];\n\n  return mergeIntoKeyedWith(this, iters);\n}\n\nfunction mergeWith(merger) {\n  var iters = [], len = arguments.length - 1;\n  while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n  if (typeof merger !== 'function') {\n    throw new TypeError('Invalid merger function: ' + merger);\n  }\n  return mergeIntoKeyedWith(this, iters, merger);\n}\n\nfunction mergeIntoKeyedWith(collection, collections, merger) {\n  var iters = [];\n  for (var ii = 0; ii < collections.length; ii++) {\n    var collection$1 = KeyedCollection(collections[ii]);\n    if (collection$1.size !== 0) {\n      iters.push(collection$1);\n    }\n  }\n  if (iters.length === 0) {\n    return collection;\n  }\n  if (\n    collection.toSeq().size === 0 &&\n    !collection.__ownerID &&\n    iters.length === 1\n  ) {\n    return collection.constructor(iters[0]);\n  }\n  return collection.withMutations(function (collection) {\n    var mergeIntoCollection = merger\n      ? function (value, key) {\n          update(\n            collection,\n            key,\n            NOT_SET,\n            function (oldVal) { return (oldVal === NOT_SET ? value : merger(oldVal, value, key)); }\n          );\n        }\n      : function (value, key) {\n          collection.set(key, value);\n        };\n    for (var ii = 0; ii < iters.length; ii++) {\n      iters[ii].forEach(mergeIntoCollection);\n    }\n  });\n}\n\nfunction merge$1(collection) {\n  var sources = [], len = arguments.length - 1;\n  while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\n  return mergeWithSources(collection, sources);\n}\n\nfunction mergeWith$1(merger, collection) {\n  var sources = [], len = arguments.length - 2;\n  while ( len-- > 0 ) sources[ len ] = arguments[ len + 2 ];\n\n  return mergeWithSources(collection, sources, merger);\n}\n\nfunction mergeDeep(collection) {\n  var sources = [], len = arguments.length - 1;\n  while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\n  return mergeDeepWithSources(collection, sources);\n}\n\nfunction mergeDeepWith(merger, collection) {\n  var sources = [], len = arguments.length - 2;\n  while ( len-- > 0 ) sources[ len ] = arguments[ len + 2 ];\n\n  return mergeDeepWithSources(collection, sources, merger);\n}\n\nfunction mergeDeepWithSources(collection, sources, merger) {\n  return mergeWithSources(collection, sources, deepMergerWith(merger));\n}\n\nfunction mergeWithSources(collection, sources, merger) {\n  if (!isDataStructure(collection)) {\n    throw new TypeError(\n      'Cannot merge into non-data-structure value: ' + collection\n    );\n  }\n  if (isImmutable(collection)) {\n    return typeof merger === 'function' && collection.mergeWith\n      ? collection.mergeWith.apply(collection, [ merger ].concat( sources ))\n      : collection.merge\n        ? collection.merge.apply(collection, sources)\n        : collection.concat.apply(collection, sources);\n  }\n  var isArray = Array.isArray(collection);\n  var merged = collection;\n  var Collection$$1 = isArray ? IndexedCollection : KeyedCollection;\n  var mergeItem = isArray\n    ? function (value) {\n        // Copy on write\n        if (merged === collection) {\n          merged = shallowCopy(merged);\n        }\n        merged.push(value);\n      }\n    : function (value, key) {\n        var hasVal = hasOwnProperty.call(merged, key);\n        var nextVal =\n          hasVal && merger ? merger(merged[key], value, key) : value;\n        if (!hasVal || nextVal !== merged[key]) {\n          // Copy on write\n          if (merged === collection) {\n            merged = shallowCopy(merged);\n          }\n          merged[key] = nextVal;\n        }\n      };\n  for (var i = 0; i < sources.length; i++) {\n    Collection$$1(sources[i]).forEach(mergeItem);\n  }\n  return merged;\n}\n\nfunction deepMergerWith(merger) {\n  function deepMerger(oldValue, newValue, key) {\n    return isDataStructure(oldValue) && isDataStructure(newValue)\n      ? mergeWithSources(oldValue, [newValue], deepMerger)\n      : merger\n        ? merger(oldValue, newValue, key)\n        : newValue;\n  }\n  return deepMerger;\n}\n\nfunction mergeDeep$1() {\n  var iters = [], len = arguments.length;\n  while ( len-- ) iters[ len ] = arguments[ len ];\n\n  return mergeDeepWithSources(this, iters);\n}\n\nfunction mergeDeepWith$1(merger) {\n  var iters = [], len = arguments.length - 1;\n  while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n  return mergeDeepWithSources(this, iters, merger);\n}\n\nfunction mergeIn(keyPath) {\n  var iters = [], len = arguments.length - 1;\n  while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n  return updateIn(this, keyPath, emptyMap(), function (m) { return mergeWithSources(m, iters); });\n}\n\nfunction mergeDeepIn(keyPath) {\n  var iters = [], len = arguments.length - 1;\n  while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n  return updateIn(this, keyPath, emptyMap(), function (m) { return mergeDeepWithSources(m, iters); }\n  );\n}\n\nfunction withMutations(fn) {\n  var mutable = this.asMutable();\n  fn(mutable);\n  return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;\n}\n\nfunction asMutable() {\n  return this.__ownerID ? this : this.__ensureOwner(new OwnerID());\n}\n\nfunction asImmutable() {\n  return this.__ensureOwner();\n}\n\nfunction wasAltered() {\n  return this.__altered;\n}\n\nvar Map = /*@__PURE__*/(function (KeyedCollection$$1) {\n  function Map(value) {\n    return value === null || value === undefined\n      ? emptyMap()\n      : isMap(value) && !isOrdered(value)\n        ? value\n        : emptyMap().withMutations(function (map) {\n            var iter = KeyedCollection$$1(value);\n            assertNotInfinite(iter.size);\n            iter.forEach(function (v, k) { return map.set(k, v); });\n          });\n  }\n\n  if ( KeyedCollection$$1 ) Map.__proto__ = KeyedCollection$$1;\n  Map.prototype = Object.create( KeyedCollection$$1 && KeyedCollection$$1.prototype );\n  Map.prototype.constructor = Map;\n\n  Map.of = function of () {\n    var keyValues = [], len = arguments.length;\n    while ( len-- ) keyValues[ len ] = arguments[ len ];\n\n    return emptyMap().withMutations(function (map) {\n      for (var i = 0; i < keyValues.length; i += 2) {\n        if (i + 1 >= keyValues.length) {\n          throw new Error('Missing value for key: ' + keyValues[i]);\n        }\n        map.set(keyValues[i], keyValues[i + 1]);\n      }\n    });\n  };\n\n  Map.prototype.toString = function toString () {\n    return this.__toString('Map {', '}');\n  };\n\n  // @pragma Access\n\n  Map.prototype.get = function get (k, notSetValue) {\n    return this._root\n      ? this._root.get(0, undefined, k, notSetValue)\n      : notSetValue;\n  };\n\n  // @pragma Modification\n\n  Map.prototype.set = function set (k, v) {\n    return updateMap(this, k, v);\n  };\n\n  Map.prototype.remove = function remove (k) {\n    return updateMap(this, k, NOT_SET);\n  };\n\n  Map.prototype.deleteAll = function deleteAll (keys) {\n    var collection = Collection(keys);\n\n    if (collection.size === 0) {\n      return this;\n    }\n\n    return this.withMutations(function (map) {\n      collection.forEach(function (key) { return map.remove(key); });\n    });\n  };\n\n  Map.prototype.clear = function clear () {\n    if (this.size === 0) {\n      return this;\n    }\n    if (this.__ownerID) {\n      this.size = 0;\n      this._root = null;\n      this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return emptyMap();\n  };\n\n  // @pragma Composition\n\n  Map.prototype.sort = function sort (comparator) {\n    // Late binding\n    return OrderedMap(sortFactory(this, comparator));\n  };\n\n  Map.prototype.sortBy = function sortBy (mapper, comparator) {\n    // Late binding\n    return OrderedMap(sortFactory(this, comparator, mapper));\n  };\n\n  Map.prototype.map = function map (mapper, context) {\n    return this.withMutations(function (map) {\n      map.forEach(function (value, key) {\n        map.set(key, mapper.call(context, value, key, map));\n      });\n    });\n  };\n\n  // @pragma Mutability\n\n  Map.prototype.__iterator = function __iterator (type, reverse) {\n    return new MapIterator(this, type, reverse);\n  };\n\n  Map.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    var iterations = 0;\n    this._root &&\n      this._root.iterate(function (entry) {\n        iterations++;\n        return fn(entry[1], entry[0], this$1);\n      }, reverse);\n    return iterations;\n  };\n\n  Map.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n    if (!ownerID) {\n      if (this.size === 0) {\n        return emptyMap();\n      }\n      this.__ownerID = ownerID;\n      this.__altered = false;\n      return this;\n    }\n    return makeMap(this.size, this._root, ownerID, this.__hash);\n  };\n\n  return Map;\n}(KeyedCollection));\n\nMap.isMap = isMap;\n\nvar MapPrototype = Map.prototype;\nMapPrototype[IS_MAP_SYMBOL] = true;\nMapPrototype[DELETE] = MapPrototype.remove;\nMapPrototype.removeAll = MapPrototype.deleteAll;\nMapPrototype.setIn = setIn$1;\nMapPrototype.removeIn = MapPrototype.deleteIn = deleteIn;\nMapPrototype.update = update$1;\nMapPrototype.updateIn = updateIn$1;\nMapPrototype.merge = MapPrototype.concat = merge;\nMapPrototype.mergeWith = mergeWith;\nMapPrototype.mergeDeep = mergeDeep$1;\nMapPrototype.mergeDeepWith = mergeDeepWith$1;\nMapPrototype.mergeIn = mergeIn;\nMapPrototype.mergeDeepIn = mergeDeepIn;\nMapPrototype.withMutations = withMutations;\nMapPrototype.wasAltered = wasAltered;\nMapPrototype.asImmutable = asImmutable;\nMapPrototype['@@transducer/init'] = MapPrototype.asMutable = asMutable;\nMapPrototype['@@transducer/step'] = function(result, arr) {\n  return result.set(arr[0], arr[1]);\n};\nMapPrototype['@@transducer/result'] = function(obj) {\n  return obj.asImmutable();\n};\n\n// #pragma Trie Nodes\n\nvar ArrayMapNode = function ArrayMapNode(ownerID, entries) {\n  this.ownerID = ownerID;\n  this.entries = entries;\n};\n\nArrayMapNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n  var entries = this.entries;\n  for (var ii = 0, len = entries.length; ii < len; ii++) {\n    if (is(key, entries[ii][0])) {\n      return entries[ii][1];\n    }\n  }\n  return notSetValue;\n};\n\nArrayMapNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n  var removed = value === NOT_SET;\n\n  var entries = this.entries;\n  var idx = 0;\n  var len = entries.length;\n  for (; idx < len; idx++) {\n    if (is(key, entries[idx][0])) {\n      break;\n    }\n  }\n  var exists = idx < len;\n\n  if (exists ? entries[idx][1] === value : removed) {\n    return this;\n  }\n\n  SetRef(didAlter);\n  (removed || !exists) && SetRef(didChangeSize);\n\n  if (removed && entries.length === 1) {\n    return; // undefined\n  }\n\n  if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {\n    return createNodes(ownerID, entries, key, value);\n  }\n\n  var isEditable = ownerID && ownerID === this.ownerID;\n  var newEntries = isEditable ? entries : arrCopy(entries);\n\n  if (exists) {\n    if (removed) {\n      idx === len - 1\n        ? newEntries.pop()\n        : (newEntries[idx] = newEntries.pop());\n    } else {\n      newEntries[idx] = [key, value];\n    }\n  } else {\n    newEntries.push([key, value]);\n  }\n\n  if (isEditable) {\n    this.entries = newEntries;\n    return this;\n  }\n\n  return new ArrayMapNode(ownerID, newEntries);\n};\n\nvar BitmapIndexedNode = function BitmapIndexedNode(ownerID, bitmap, nodes) {\n  this.ownerID = ownerID;\n  this.bitmap = bitmap;\n  this.nodes = nodes;\n};\n\nBitmapIndexedNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n  if (keyHash === undefined) {\n    keyHash = hash(key);\n  }\n  var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);\n  var bitmap = this.bitmap;\n  return (bitmap & bit) === 0\n    ? notSetValue\n    : this.nodes[popCount(bitmap & (bit - 1))].get(\n        shift + SHIFT,\n        keyHash,\n        key,\n        notSetValue\n      );\n};\n\nBitmapIndexedNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n  if (keyHash === undefined) {\n    keyHash = hash(key);\n  }\n  var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n  var bit = 1 << keyHashFrag;\n  var bitmap = this.bitmap;\n  var exists = (bitmap & bit) !== 0;\n\n  if (!exists && value === NOT_SET) {\n    return this;\n  }\n\n  var idx = popCount(bitmap & (bit - 1));\n  var nodes = this.nodes;\n  var node = exists ? nodes[idx] : undefined;\n  var newNode = updateNode(\n    node,\n    ownerID,\n    shift + SHIFT,\n    keyHash,\n    key,\n    value,\n    didChangeSize,\n    didAlter\n  );\n\n  if (newNode === node) {\n    return this;\n  }\n\n  if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {\n    return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);\n  }\n\n  if (\n    exists &&\n    !newNode &&\n    nodes.length === 2 &&\n    isLeafNode(nodes[idx ^ 1])\n  ) {\n    return nodes[idx ^ 1];\n  }\n\n  if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {\n    return newNode;\n  }\n\n  var isEditable = ownerID && ownerID === this.ownerID;\n  var newBitmap = exists ? (newNode ? bitmap : bitmap ^ bit) : bitmap | bit;\n  var newNodes = exists\n    ? newNode\n      ? setAt(nodes, idx, newNode, isEditable)\n      : spliceOut(nodes, idx, isEditable)\n    : spliceIn(nodes, idx, newNode, isEditable);\n\n  if (isEditable) {\n    this.bitmap = newBitmap;\n    this.nodes = newNodes;\n    return this;\n  }\n\n  return new BitmapIndexedNode(ownerID, newBitmap, newNodes);\n};\n\nvar HashArrayMapNode = function HashArrayMapNode(ownerID, count, nodes) {\n  this.ownerID = ownerID;\n  this.count = count;\n  this.nodes = nodes;\n};\n\nHashArrayMapNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n  if (keyHash === undefined) {\n    keyHash = hash(key);\n  }\n  var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n  var node = this.nodes[idx];\n  return node\n    ? node.get(shift + SHIFT, keyHash, key, notSetValue)\n    : notSetValue;\n};\n\nHashArrayMapNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n  if (keyHash === undefined) {\n    keyHash = hash(key);\n  }\n  var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n  var removed = value === NOT_SET;\n  var nodes = this.nodes;\n  var node = nodes[idx];\n\n  if (removed && !node) {\n    return this;\n  }\n\n  var newNode = updateNode(\n    node,\n    ownerID,\n    shift + SHIFT,\n    keyHash,\n    key,\n    value,\n    didChangeSize,\n    didAlter\n  );\n  if (newNode === node) {\n    return this;\n  }\n\n  var newCount = this.count;\n  if (!node) {\n    newCount++;\n  } else if (!newNode) {\n    newCount--;\n    if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {\n      return packNodes(ownerID, nodes, newCount, idx);\n    }\n  }\n\n  var isEditable = ownerID && ownerID === this.ownerID;\n  var newNodes = setAt(nodes, idx, newNode, isEditable);\n\n  if (isEditable) {\n    this.count = newCount;\n    this.nodes = newNodes;\n    return this;\n  }\n\n  return new HashArrayMapNode(ownerID, newCount, newNodes);\n};\n\nvar HashCollisionNode = function HashCollisionNode(ownerID, keyHash, entries) {\n  this.ownerID = ownerID;\n  this.keyHash = keyHash;\n  this.entries = entries;\n};\n\nHashCollisionNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n  var entries = this.entries;\n  for (var ii = 0, len = entries.length; ii < len; ii++) {\n    if (is(key, entries[ii][0])) {\n      return entries[ii][1];\n    }\n  }\n  return notSetValue;\n};\n\nHashCollisionNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n  if (keyHash === undefined) {\n    keyHash = hash(key);\n  }\n\n  var removed = value === NOT_SET;\n\n  if (keyHash !== this.keyHash) {\n    if (removed) {\n      return this;\n    }\n    SetRef(didAlter);\n    SetRef(didChangeSize);\n    return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);\n  }\n\n  var entries = this.entries;\n  var idx = 0;\n  var len = entries.length;\n  for (; idx < len; idx++) {\n    if (is(key, entries[idx][0])) {\n      break;\n    }\n  }\n  var exists = idx < len;\n\n  if (exists ? entries[idx][1] === value : removed) {\n    return this;\n  }\n\n  SetRef(didAlter);\n  (removed || !exists) && SetRef(didChangeSize);\n\n  if (removed && len === 2) {\n    return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);\n  }\n\n  var isEditable = ownerID && ownerID === this.ownerID;\n  var newEntries = isEditable ? entries : arrCopy(entries);\n\n  if (exists) {\n    if (removed) {\n      idx === len - 1\n        ? newEntries.pop()\n        : (newEntries[idx] = newEntries.pop());\n    } else {\n      newEntries[idx] = [key, value];\n    }\n  } else {\n    newEntries.push([key, value]);\n  }\n\n  if (isEditable) {\n    this.entries = newEntries;\n    return this;\n  }\n\n  return new HashCollisionNode(ownerID, this.keyHash, newEntries);\n};\n\nvar ValueNode = function ValueNode(ownerID, keyHash, entry) {\n  this.ownerID = ownerID;\n  this.keyHash = keyHash;\n  this.entry = entry;\n};\n\nValueNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n  return is(key, this.entry[0]) ? this.entry[1] : notSetValue;\n};\n\nValueNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n  var removed = value === NOT_SET;\n  var keyMatch = is(key, this.entry[0]);\n  if (keyMatch ? value === this.entry[1] : removed) {\n    return this;\n  }\n\n  SetRef(didAlter);\n\n  if (removed) {\n    SetRef(didChangeSize);\n    return; // undefined\n  }\n\n  if (keyMatch) {\n    if (ownerID && ownerID === this.ownerID) {\n      this.entry[1] = value;\n      return this;\n    }\n    return new ValueNode(ownerID, this.keyHash, [key, value]);\n  }\n\n  SetRef(didChangeSize);\n  return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);\n};\n\n// #pragma Iterators\n\nArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate = function(\n  fn,\n  reverse\n) {\n  var entries = this.entries;\n  for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {\n    if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {\n      return false;\n    }\n  }\n};\n\nBitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate = function(\n  fn,\n  reverse\n) {\n  var nodes = this.nodes;\n  for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {\n    var node = nodes[reverse ? maxIndex - ii : ii];\n    if (node && node.iterate(fn, reverse) === false) {\n      return false;\n    }\n  }\n};\n\n// eslint-disable-next-line no-unused-vars\nValueNode.prototype.iterate = function(fn, reverse) {\n  return fn(this.entry);\n};\n\nvar MapIterator = /*@__PURE__*/(function (Iterator$$1) {\n  function MapIterator(map, type, reverse) {\n    this._type = type;\n    this._reverse = reverse;\n    this._stack = map._root && mapIteratorFrame(map._root);\n  }\n\n  if ( Iterator$$1 ) MapIterator.__proto__ = Iterator$$1;\n  MapIterator.prototype = Object.create( Iterator$$1 && Iterator$$1.prototype );\n  MapIterator.prototype.constructor = MapIterator;\n\n  MapIterator.prototype.next = function next () {\n    var type = this._type;\n    var stack = this._stack;\n    while (stack) {\n      var node = stack.node;\n      var index = stack.index++;\n      var maxIndex = (void 0);\n      if (node.entry) {\n        if (index === 0) {\n          return mapIteratorValue(type, node.entry);\n        }\n      } else if (node.entries) {\n        maxIndex = node.entries.length - 1;\n        if (index <= maxIndex) {\n          return mapIteratorValue(\n            type,\n            node.entries[this._reverse ? maxIndex - index : index]\n          );\n        }\n      } else {\n        maxIndex = node.nodes.length - 1;\n        if (index <= maxIndex) {\n          var subNode = node.nodes[this._reverse ? maxIndex - index : index];\n          if (subNode) {\n            if (subNode.entry) {\n              return mapIteratorValue(type, subNode.entry);\n            }\n            stack = this._stack = mapIteratorFrame(subNode, stack);\n          }\n          continue;\n        }\n      }\n      stack = this._stack = this._stack.__prev;\n    }\n    return iteratorDone();\n  };\n\n  return MapIterator;\n}(Iterator));\n\nfunction mapIteratorValue(type, entry) {\n  return iteratorValue(type, entry[0], entry[1]);\n}\n\nfunction mapIteratorFrame(node, prev) {\n  return {\n    node: node,\n    index: 0,\n    __prev: prev,\n  };\n}\n\nfunction makeMap(size, root, ownerID, hash$$1) {\n  var map = Object.create(MapPrototype);\n  map.size = size;\n  map._root = root;\n  map.__ownerID = ownerID;\n  map.__hash = hash$$1;\n  map.__altered = false;\n  return map;\n}\n\nvar EMPTY_MAP;\nfunction emptyMap() {\n  return EMPTY_MAP || (EMPTY_MAP = makeMap(0));\n}\n\nfunction updateMap(map, k, v) {\n  var newRoot;\n  var newSize;\n  if (!map._root) {\n    if (v === NOT_SET) {\n      return map;\n    }\n    newSize = 1;\n    newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);\n  } else {\n    var didChangeSize = MakeRef();\n    var didAlter = MakeRef();\n    newRoot = updateNode(\n      map._root,\n      map.__ownerID,\n      0,\n      undefined,\n      k,\n      v,\n      didChangeSize,\n      didAlter\n    );\n    if (!didAlter.value) {\n      return map;\n    }\n    newSize = map.size + (didChangeSize.value ? (v === NOT_SET ? -1 : 1) : 0);\n  }\n  if (map.__ownerID) {\n    map.size = newSize;\n    map._root = newRoot;\n    map.__hash = undefined;\n    map.__altered = true;\n    return map;\n  }\n  return newRoot ? makeMap(newSize, newRoot) : emptyMap();\n}\n\nfunction updateNode(\n  node,\n  ownerID,\n  shift,\n  keyHash,\n  key,\n  value,\n  didChangeSize,\n  didAlter\n) {\n  if (!node) {\n    if (value === NOT_SET) {\n      return node;\n    }\n    SetRef(didAlter);\n    SetRef(didChangeSize);\n    return new ValueNode(ownerID, keyHash, [key, value]);\n  }\n  return node.update(\n    ownerID,\n    shift,\n    keyHash,\n    key,\n    value,\n    didChangeSize,\n    didAlter\n  );\n}\n\nfunction isLeafNode(node) {\n  return (\n    node.constructor === ValueNode || node.constructor === HashCollisionNode\n  );\n}\n\nfunction mergeIntoNode(node, ownerID, shift, keyHash, entry) {\n  if (node.keyHash === keyHash) {\n    return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);\n  }\n\n  var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;\n  var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\n  var newNode;\n  var nodes =\n    idx1 === idx2\n      ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)]\n      : ((newNode = new ValueNode(ownerID, keyHash, entry)),\n        idx1 < idx2 ? [node, newNode] : [newNode, node]);\n\n  return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);\n}\n\nfunction createNodes(ownerID, entries, key, value) {\n  if (!ownerID) {\n    ownerID = new OwnerID();\n  }\n  var node = new ValueNode(ownerID, hash(key), [key, value]);\n  for (var ii = 0; ii < entries.length; ii++) {\n    var entry = entries[ii];\n    node = node.update(ownerID, 0, undefined, entry[0], entry[1]);\n  }\n  return node;\n}\n\nfunction packNodes(ownerID, nodes, count, excluding) {\n  var bitmap = 0;\n  var packedII = 0;\n  var packedNodes = new Array(count);\n  for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {\n    var node = nodes[ii];\n    if (node !== undefined && ii !== excluding) {\n      bitmap |= bit;\n      packedNodes[packedII++] = node;\n    }\n  }\n  return new BitmapIndexedNode(ownerID, bitmap, packedNodes);\n}\n\nfunction expandNodes(ownerID, nodes, bitmap, including, node) {\n  var count = 0;\n  var expandedNodes = new Array(SIZE);\n  for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {\n    expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;\n  }\n  expandedNodes[including] = node;\n  return new HashArrayMapNode(ownerID, count + 1, expandedNodes);\n}\n\nfunction popCount(x) {\n  x -= (x >> 1) & 0x55555555;\n  x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n  x = (x + (x >> 4)) & 0x0f0f0f0f;\n  x += x >> 8;\n  x += x >> 16;\n  return x & 0x7f;\n}\n\nfunction setAt(array, idx, val, canEdit) {\n  var newArray = canEdit ? array : arrCopy(array);\n  newArray[idx] = val;\n  return newArray;\n}\n\nfunction spliceIn(array, idx, val, canEdit) {\n  var newLen = array.length + 1;\n  if (canEdit && idx + 1 === newLen) {\n    array[idx] = val;\n    return array;\n  }\n  var newArray = new Array(newLen);\n  var after = 0;\n  for (var ii = 0; ii < newLen; ii++) {\n    if (ii === idx) {\n      newArray[ii] = val;\n      after = -1;\n    } else {\n      newArray[ii] = array[ii + after];\n    }\n  }\n  return newArray;\n}\n\nfunction spliceOut(array, idx, canEdit) {\n  var newLen = array.length - 1;\n  if (canEdit && idx === newLen) {\n    array.pop();\n    return array;\n  }\n  var newArray = new Array(newLen);\n  var after = 0;\n  for (var ii = 0; ii < newLen; ii++) {\n    if (ii === idx) {\n      after = 1;\n    }\n    newArray[ii] = array[ii + after];\n  }\n  return newArray;\n}\n\nvar MAX_ARRAY_MAP_SIZE = SIZE / 4;\nvar MAX_BITMAP_INDEXED_SIZE = SIZE / 2;\nvar MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;\n\nvar IS_LIST_SYMBOL = '@@__IMMUTABLE_LIST__@@';\n\nfunction isList(maybeList) {\n  return Boolean(maybeList && maybeList[IS_LIST_SYMBOL]);\n}\n\nvar List = /*@__PURE__*/(function (IndexedCollection$$1) {\n  function List(value) {\n    var empty = emptyList();\n    if (value === null || value === undefined) {\n      return empty;\n    }\n    if (isList(value)) {\n      return value;\n    }\n    var iter = IndexedCollection$$1(value);\n    var size = iter.size;\n    if (size === 0) {\n      return empty;\n    }\n    assertNotInfinite(size);\n    if (size > 0 && size < SIZE) {\n      return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));\n    }\n    return empty.withMutations(function (list) {\n      list.setSize(size);\n      iter.forEach(function (v, i) { return list.set(i, v); });\n    });\n  }\n\n  if ( IndexedCollection$$1 ) List.__proto__ = IndexedCollection$$1;\n  List.prototype = Object.create( IndexedCollection$$1 && IndexedCollection$$1.prototype );\n  List.prototype.constructor = List;\n\n  List.of = function of (/*...values*/) {\n    return this(arguments);\n  };\n\n  List.prototype.toString = function toString () {\n    return this.__toString('List [', ']');\n  };\n\n  // @pragma Access\n\n  List.prototype.get = function get (index, notSetValue) {\n    index = wrapIndex(this, index);\n    if (index >= 0 && index < this.size) {\n      index += this._origin;\n      var node = listNodeFor(this, index);\n      return node && node.array[index & MASK];\n    }\n    return notSetValue;\n  };\n\n  // @pragma Modification\n\n  List.prototype.set = function set (index, value) {\n    return updateList(this, index, value);\n  };\n\n  List.prototype.remove = function remove (index) {\n    return !this.has(index)\n      ? this\n      : index === 0\n        ? this.shift()\n        : index === this.size - 1\n          ? this.pop()\n          : this.splice(index, 1);\n  };\n\n  List.prototype.insert = function insert (index, value) {\n    return this.splice(index, 0, value);\n  };\n\n  List.prototype.clear = function clear () {\n    if (this.size === 0) {\n      return this;\n    }\n    if (this.__ownerID) {\n      this.size = this._origin = this._capacity = 0;\n      this._level = SHIFT;\n      this._root = this._tail = null;\n      this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return emptyList();\n  };\n\n  List.prototype.push = function push (/*...values*/) {\n    var values = arguments;\n    var oldSize = this.size;\n    return this.withMutations(function (list) {\n      setListBounds(list, 0, oldSize + values.length);\n      for (var ii = 0; ii < values.length; ii++) {\n        list.set(oldSize + ii, values[ii]);\n      }\n    });\n  };\n\n  List.prototype.pop = function pop () {\n    return setListBounds(this, 0, -1);\n  };\n\n  List.prototype.unshift = function unshift (/*...values*/) {\n    var values = arguments;\n    return this.withMutations(function (list) {\n      setListBounds(list, -values.length);\n      for (var ii = 0; ii < values.length; ii++) {\n        list.set(ii, values[ii]);\n      }\n    });\n  };\n\n  List.prototype.shift = function shift () {\n    return setListBounds(this, 1);\n  };\n\n  // @pragma Composition\n\n  List.prototype.concat = function concat (/*...collections*/) {\n    var arguments$1 = arguments;\n\n    var seqs = [];\n    for (var i = 0; i < arguments.length; i++) {\n      var argument = arguments$1[i];\n      var seq = IndexedCollection$$1(\n        typeof argument !== 'string' && hasIterator(argument)\n          ? argument\n          : [argument]\n      );\n      if (seq.size !== 0) {\n        seqs.push(seq);\n      }\n    }\n    if (seqs.length === 0) {\n      return this;\n    }\n    if (this.size === 0 && !this.__ownerID && seqs.length === 1) {\n      return this.constructor(seqs[0]);\n    }\n    return this.withMutations(function (list) {\n      seqs.forEach(function (seq) { return seq.forEach(function (value) { return list.push(value); }); });\n    });\n  };\n\n  List.prototype.setSize = function setSize (size) {\n    return setListBounds(this, 0, size);\n  };\n\n  List.prototype.map = function map (mapper, context) {\n    var this$1 = this;\n\n    return this.withMutations(function (list) {\n      for (var i = 0; i < this$1.size; i++) {\n        list.set(i, mapper.call(context, list.get(i), i, list));\n      }\n    });\n  };\n\n  // @pragma Iteration\n\n  List.prototype.slice = function slice (begin, end) {\n    var size = this.size;\n    if (wholeSlice(begin, end, size)) {\n      return this;\n    }\n    return setListBounds(\n      this,\n      resolveBegin(begin, size),\n      resolveEnd(end, size)\n    );\n  };\n\n  List.prototype.__iterator = function __iterator (type, reverse) {\n    var index = reverse ? this.size : 0;\n    var values = iterateList(this, reverse);\n    return new Iterator(function () {\n      var value = values();\n      return value === DONE\n        ? iteratorDone()\n        : iteratorValue(type, reverse ? --index : index++, value);\n    });\n  };\n\n  List.prototype.__iterate = function __iterate (fn, reverse) {\n    var index = reverse ? this.size : 0;\n    var values = iterateList(this, reverse);\n    var value;\n    while ((value = values()) !== DONE) {\n      if (fn(value, reverse ? --index : index++, this) === false) {\n        break;\n      }\n    }\n    return index;\n  };\n\n  List.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n    if (!ownerID) {\n      if (this.size === 0) {\n        return emptyList();\n      }\n      this.__ownerID = ownerID;\n      this.__altered = false;\n      return this;\n    }\n    return makeList(\n      this._origin,\n      this._capacity,\n      this._level,\n      this._root,\n      this._tail,\n      ownerID,\n      this.__hash\n    );\n  };\n\n  return List;\n}(IndexedCollection));\n\nList.isList = isList;\n\nvar ListPrototype = List.prototype;\nListPrototype[IS_LIST_SYMBOL] = true;\nListPrototype[DELETE] = ListPrototype.remove;\nListPrototype.merge = ListPrototype.concat;\nListPrototype.setIn = setIn$1;\nListPrototype.deleteIn = ListPrototype.removeIn = deleteIn;\nListPrototype.update = update$1;\nListPrototype.updateIn = updateIn$1;\nListPrototype.mergeIn = mergeIn;\nListPrototype.mergeDeepIn = mergeDeepIn;\nListPrototype.withMutations = withMutations;\nListPrototype.wasAltered = wasAltered;\nListPrototype.asImmutable = asImmutable;\nListPrototype['@@transducer/init'] = ListPrototype.asMutable = asMutable;\nListPrototype['@@transducer/step'] = function(result, arr) {\n  return result.push(arr);\n};\nListPrototype['@@transducer/result'] = function(obj) {\n  return obj.asImmutable();\n};\n\nvar VNode = function VNode(array, ownerID) {\n  this.array = array;\n  this.ownerID = ownerID;\n};\n\n// TODO: seems like these methods are very similar\n\nVNode.prototype.removeBefore = function removeBefore (ownerID, level, index) {\n  if (index === level ? 1 << level : this.array.length === 0) {\n    return this;\n  }\n  var originIndex = (index >>> level) & MASK;\n  if (originIndex >= this.array.length) {\n    return new VNode([], ownerID);\n  }\n  var removingFirst = originIndex === 0;\n  var newChild;\n  if (level > 0) {\n    var oldChild = this.array[originIndex];\n    newChild =\n      oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);\n    if (newChild === oldChild && removingFirst) {\n      return this;\n    }\n  }\n  if (removingFirst && !newChild) {\n    return this;\n  }\n  var editable = editableVNode(this, ownerID);\n  if (!removingFirst) {\n    for (var ii = 0; ii < originIndex; ii++) {\n      editable.array[ii] = undefined;\n    }\n  }\n  if (newChild) {\n    editable.array[originIndex] = newChild;\n  }\n  return editable;\n};\n\nVNode.prototype.removeAfter = function removeAfter (ownerID, level, index) {\n  if (index === (level ? 1 << level : 0) || this.array.length === 0) {\n    return this;\n  }\n  var sizeIndex = ((index - 1) >>> level) & MASK;\n  if (sizeIndex >= this.array.length) {\n    return this;\n  }\n\n  var newChild;\n  if (level > 0) {\n    var oldChild = this.array[sizeIndex];\n    newChild =\n      oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);\n    if (newChild === oldChild && sizeIndex === this.array.length - 1) {\n      return this;\n    }\n  }\n\n  var editable = editableVNode(this, ownerID);\n  editable.array.splice(sizeIndex + 1);\n  if (newChild) {\n    editable.array[sizeIndex] = newChild;\n  }\n  return editable;\n};\n\nvar DONE = {};\n\nfunction iterateList(list, reverse) {\n  var left = list._origin;\n  var right = list._capacity;\n  var tailPos = getTailOffset(right);\n  var tail = list._tail;\n\n  return iterateNodeOrLeaf(list._root, list._level, 0);\n\n  function iterateNodeOrLeaf(node, level, offset) {\n    return level === 0\n      ? iterateLeaf(node, offset)\n      : iterateNode(node, level, offset);\n  }\n\n  function iterateLeaf(node, offset) {\n    var array = offset === tailPos ? tail && tail.array : node && node.array;\n    var from = offset > left ? 0 : left - offset;\n    var to = right - offset;\n    if (to > SIZE) {\n      to = SIZE;\n    }\n    return function () {\n      if (from === to) {\n        return DONE;\n      }\n      var idx = reverse ? --to : from++;\n      return array && array[idx];\n    };\n  }\n\n  function iterateNode(node, level, offset) {\n    var values;\n    var array = node && node.array;\n    var from = offset > left ? 0 : (left - offset) >> level;\n    var to = ((right - offset) >> level) + 1;\n    if (to > SIZE) {\n      to = SIZE;\n    }\n    return function () {\n      while (true) {\n        if (values) {\n          var value = values();\n          if (value !== DONE) {\n            return value;\n          }\n          values = null;\n        }\n        if (from === to) {\n          return DONE;\n        }\n        var idx = reverse ? --to : from++;\n        values = iterateNodeOrLeaf(\n          array && array[idx],\n          level - SHIFT,\n          offset + (idx << level)\n        );\n      }\n    };\n  }\n}\n\nfunction makeList(origin, capacity, level, root, tail, ownerID, hash) {\n  var list = Object.create(ListPrototype);\n  list.size = capacity - origin;\n  list._origin = origin;\n  list._capacity = capacity;\n  list._level = level;\n  list._root = root;\n  list._tail = tail;\n  list.__ownerID = ownerID;\n  list.__hash = hash;\n  list.__altered = false;\n  return list;\n}\n\nvar EMPTY_LIST;\nfunction emptyList() {\n  return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));\n}\n\nfunction updateList(list, index, value) {\n  index = wrapIndex(list, index);\n\n  if (index !== index) {\n    return list;\n  }\n\n  if (index >= list.size || index < 0) {\n    return list.withMutations(function (list) {\n      index < 0\n        ? setListBounds(list, index).set(0, value)\n        : setListBounds(list, 0, index + 1).set(index, value);\n    });\n  }\n\n  index += list._origin;\n\n  var newTail = list._tail;\n  var newRoot = list._root;\n  var didAlter = MakeRef();\n  if (index >= getTailOffset(list._capacity)) {\n    newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);\n  } else {\n    newRoot = updateVNode(\n      newRoot,\n      list.__ownerID,\n      list._level,\n      index,\n      value,\n      didAlter\n    );\n  }\n\n  if (!didAlter.value) {\n    return list;\n  }\n\n  if (list.__ownerID) {\n    list._root = newRoot;\n    list._tail = newTail;\n    list.__hash = undefined;\n    list.__altered = true;\n    return list;\n  }\n  return makeList(list._origin, list._capacity, list._level, newRoot, newTail);\n}\n\nfunction updateVNode(node, ownerID, level, index, value, didAlter) {\n  var idx = (index >>> level) & MASK;\n  var nodeHas = node && idx < node.array.length;\n  if (!nodeHas && value === undefined) {\n    return node;\n  }\n\n  var newNode;\n\n  if (level > 0) {\n    var lowerNode = node && node.array[idx];\n    var newLowerNode = updateVNode(\n      lowerNode,\n      ownerID,\n      level - SHIFT,\n      index,\n      value,\n      didAlter\n    );\n    if (newLowerNode === lowerNode) {\n      return node;\n    }\n    newNode = editableVNode(node, ownerID);\n    newNode.array[idx] = newLowerNode;\n    return newNode;\n  }\n\n  if (nodeHas && node.array[idx] === value) {\n    return node;\n  }\n\n  if (didAlter) {\n    SetRef(didAlter);\n  }\n\n  newNode = editableVNode(node, ownerID);\n  if (value === undefined && idx === newNode.array.length - 1) {\n    newNode.array.pop();\n  } else {\n    newNode.array[idx] = value;\n  }\n  return newNode;\n}\n\nfunction editableVNode(node, ownerID) {\n  if (ownerID && node && ownerID === node.ownerID) {\n    return node;\n  }\n  return new VNode(node ? node.array.slice() : [], ownerID);\n}\n\nfunction listNodeFor(list, rawIndex) {\n  if (rawIndex >= getTailOffset(list._capacity)) {\n    return list._tail;\n  }\n  if (rawIndex < 1 << (list._level + SHIFT)) {\n    var node = list._root;\n    var level = list._level;\n    while (node && level > 0) {\n      node = node.array[(rawIndex >>> level) & MASK];\n      level -= SHIFT;\n    }\n    return node;\n  }\n}\n\nfunction setListBounds(list, begin, end) {\n  // Sanitize begin & end using this shorthand for ToInt32(argument)\n  // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n  if (begin !== undefined) {\n    begin |= 0;\n  }\n  if (end !== undefined) {\n    end |= 0;\n  }\n  var owner = list.__ownerID || new OwnerID();\n  var oldOrigin = list._origin;\n  var oldCapacity = list._capacity;\n  var newOrigin = oldOrigin + begin;\n  var newCapacity =\n    end === undefined\n      ? oldCapacity\n      : end < 0\n        ? oldCapacity + end\n        : oldOrigin + end;\n  if (newOrigin === oldOrigin && newCapacity === oldCapacity) {\n    return list;\n  }\n\n  // If it's going to end after it starts, it's empty.\n  if (newOrigin >= newCapacity) {\n    return list.clear();\n  }\n\n  var newLevel = list._level;\n  var newRoot = list._root;\n\n  // New origin might need creating a higher root.\n  var offsetShift = 0;\n  while (newOrigin + offsetShift < 0) {\n    newRoot = new VNode(\n      newRoot && newRoot.array.length ? [undefined, newRoot] : [],\n      owner\n    );\n    newLevel += SHIFT;\n    offsetShift += 1 << newLevel;\n  }\n  if (offsetShift) {\n    newOrigin += offsetShift;\n    oldOrigin += offsetShift;\n    newCapacity += offsetShift;\n    oldCapacity += offsetShift;\n  }\n\n  var oldTailOffset = getTailOffset(oldCapacity);\n  var newTailOffset = getTailOffset(newCapacity);\n\n  // New size might need creating a higher root.\n  while (newTailOffset >= 1 << (newLevel + SHIFT)) {\n    newRoot = new VNode(\n      newRoot && newRoot.array.length ? [newRoot] : [],\n      owner\n    );\n    newLevel += SHIFT;\n  }\n\n  // Locate or create the new tail.\n  var oldTail = list._tail;\n  var newTail =\n    newTailOffset < oldTailOffset\n      ? listNodeFor(list, newCapacity - 1)\n      : newTailOffset > oldTailOffset\n        ? new VNode([], owner)\n        : oldTail;\n\n  // Merge Tail into tree.\n  if (\n    oldTail &&\n    newTailOffset > oldTailOffset &&\n    newOrigin < oldCapacity &&\n    oldTail.array.length\n  ) {\n    newRoot = editableVNode(newRoot, owner);\n    var node = newRoot;\n    for (var level = newLevel; level > SHIFT; level -= SHIFT) {\n      var idx = (oldTailOffset >>> level) & MASK;\n      node = node.array[idx] = editableVNode(node.array[idx], owner);\n    }\n    node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;\n  }\n\n  // If the size has been reduced, there's a chance the tail needs to be trimmed.\n  if (newCapacity < oldCapacity) {\n    newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);\n  }\n\n  // If the new origin is within the tail, then we do not need a root.\n  if (newOrigin >= newTailOffset) {\n    newOrigin -= newTailOffset;\n    newCapacity -= newTailOffset;\n    newLevel = SHIFT;\n    newRoot = null;\n    newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);\n\n    // Otherwise, if the root has been trimmed, garbage collect.\n  } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {\n    offsetShift = 0;\n\n    // Identify the new top root node of the subtree of the old root.\n    while (newRoot) {\n      var beginIndex = (newOrigin >>> newLevel) & MASK;\n      if ((beginIndex !== newTailOffset >>> newLevel) & MASK) {\n        break;\n      }\n      if (beginIndex) {\n        offsetShift += (1 << newLevel) * beginIndex;\n      }\n      newLevel -= SHIFT;\n      newRoot = newRoot.array[beginIndex];\n    }\n\n    // Trim the new sides of the new root.\n    if (newRoot && newOrigin > oldOrigin) {\n      newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);\n    }\n    if (newRoot && newTailOffset < oldTailOffset) {\n      newRoot = newRoot.removeAfter(\n        owner,\n        newLevel,\n        newTailOffset - offsetShift\n      );\n    }\n    if (offsetShift) {\n      newOrigin -= offsetShift;\n      newCapacity -= offsetShift;\n    }\n  }\n\n  if (list.__ownerID) {\n    list.size = newCapacity - newOrigin;\n    list._origin = newOrigin;\n    list._capacity = newCapacity;\n    list._level = newLevel;\n    list._root = newRoot;\n    list._tail = newTail;\n    list.__hash = undefined;\n    list.__altered = true;\n    return list;\n  }\n  return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);\n}\n\nfunction getTailOffset(size) {\n  return size < SIZE ? 0 : ((size - 1) >>> SHIFT) << SHIFT;\n}\n\nvar OrderedMap = /*@__PURE__*/(function (Map$$1) {\n  function OrderedMap(value) {\n    return value === null || value === undefined\n      ? emptyOrderedMap()\n      : isOrderedMap(value)\n        ? value\n        : emptyOrderedMap().withMutations(function (map) {\n            var iter = KeyedCollection(value);\n            assertNotInfinite(iter.size);\n            iter.forEach(function (v, k) { return map.set(k, v); });\n          });\n  }\n\n  if ( Map$$1 ) OrderedMap.__proto__ = Map$$1;\n  OrderedMap.prototype = Object.create( Map$$1 && Map$$1.prototype );\n  OrderedMap.prototype.constructor = OrderedMap;\n\n  OrderedMap.of = function of (/*...values*/) {\n    return this(arguments);\n  };\n\n  OrderedMap.prototype.toString = function toString () {\n    return this.__toString('OrderedMap {', '}');\n  };\n\n  // @pragma Access\n\n  OrderedMap.prototype.get = function get (k, notSetValue) {\n    var index = this._map.get(k);\n    return index !== undefined ? this._list.get(index)[1] : notSetValue;\n  };\n\n  // @pragma Modification\n\n  OrderedMap.prototype.clear = function clear () {\n    if (this.size === 0) {\n      return this;\n    }\n    if (this.__ownerID) {\n      this.size = 0;\n      this._map.clear();\n      this._list.clear();\n      return this;\n    }\n    return emptyOrderedMap();\n  };\n\n  OrderedMap.prototype.set = function set (k, v) {\n    return updateOrderedMap(this, k, v);\n  };\n\n  OrderedMap.prototype.remove = function remove (k) {\n    return updateOrderedMap(this, k, NOT_SET);\n  };\n\n  OrderedMap.prototype.wasAltered = function wasAltered () {\n    return this._map.wasAltered() || this._list.wasAltered();\n  };\n\n  OrderedMap.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    return this._list.__iterate(\n      function (entry) { return entry && fn(entry[1], entry[0], this$1); },\n      reverse\n    );\n  };\n\n  OrderedMap.prototype.__iterator = function __iterator (type, reverse) {\n    return this._list.fromEntrySeq().__iterator(type, reverse);\n  };\n\n  OrderedMap.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n    var newMap = this._map.__ensureOwner(ownerID);\n    var newList = this._list.__ensureOwner(ownerID);\n    if (!ownerID) {\n      if (this.size === 0) {\n        return emptyOrderedMap();\n      }\n      this.__ownerID = ownerID;\n      this._map = newMap;\n      this._list = newList;\n      return this;\n    }\n    return makeOrderedMap(newMap, newList, ownerID, this.__hash);\n  };\n\n  return OrderedMap;\n}(Map));\n\nOrderedMap.isOrderedMap = isOrderedMap;\n\nOrderedMap.prototype[IS_ORDERED_SYMBOL] = true;\nOrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;\n\nfunction makeOrderedMap(map, list, ownerID, hash) {\n  var omap = Object.create(OrderedMap.prototype);\n  omap.size = map ? map.size : 0;\n  omap._map = map;\n  omap._list = list;\n  omap.__ownerID = ownerID;\n  omap.__hash = hash;\n  return omap;\n}\n\nvar EMPTY_ORDERED_MAP;\nfunction emptyOrderedMap() {\n  return (\n    EMPTY_ORDERED_MAP ||\n    (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()))\n  );\n}\n\nfunction updateOrderedMap(omap, k, v) {\n  var map = omap._map;\n  var list = omap._list;\n  var i = map.get(k);\n  var has = i !== undefined;\n  var newMap;\n  var newList;\n  if (v === NOT_SET) {\n    // removed\n    if (!has) {\n      return omap;\n    }\n    if (list.size >= SIZE && list.size >= map.size * 2) {\n      newList = list.filter(function (entry, idx) { return entry !== undefined && i !== idx; });\n      newMap = newList\n        .toKeyedSeq()\n        .map(function (entry) { return entry[0]; })\n        .flip()\n        .toMap();\n      if (omap.__ownerID) {\n        newMap.__ownerID = newList.__ownerID = omap.__ownerID;\n      }\n    } else {\n      newMap = map.remove(k);\n      newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);\n    }\n  } else if (has) {\n    if (v === list.get(i)[1]) {\n      return omap;\n    }\n    newMap = map;\n    newList = list.set(i, [k, v]);\n  } else {\n    newMap = map.set(k, list.size);\n    newList = list.set(list.size, [k, v]);\n  }\n  if (omap.__ownerID) {\n    omap.size = newMap.size;\n    omap._map = newMap;\n    omap._list = newList;\n    omap.__hash = undefined;\n    return omap;\n  }\n  return makeOrderedMap(newMap, newList);\n}\n\nvar IS_STACK_SYMBOL = '@@__IMMUTABLE_STACK__@@';\n\nfunction isStack(maybeStack) {\n  return Boolean(maybeStack && maybeStack[IS_STACK_SYMBOL]);\n}\n\nvar Stack = /*@__PURE__*/(function (IndexedCollection$$1) {\n  function Stack(value) {\n    return value === null || value === undefined\n      ? emptyStack()\n      : isStack(value)\n        ? value\n        : emptyStack().pushAll(value);\n  }\n\n  if ( IndexedCollection$$1 ) Stack.__proto__ = IndexedCollection$$1;\n  Stack.prototype = Object.create( IndexedCollection$$1 && IndexedCollection$$1.prototype );\n  Stack.prototype.constructor = Stack;\n\n  Stack.of = function of (/*...values*/) {\n    return this(arguments);\n  };\n\n  Stack.prototype.toString = function toString () {\n    return this.__toString('Stack [', ']');\n  };\n\n  // @pragma Access\n\n  Stack.prototype.get = function get (index, notSetValue) {\n    var head = this._head;\n    index = wrapIndex(this, index);\n    while (head && index--) {\n      head = head.next;\n    }\n    return head ? head.value : notSetValue;\n  };\n\n  Stack.prototype.peek = function peek () {\n    return this._head && this._head.value;\n  };\n\n  // @pragma Modification\n\n  Stack.prototype.push = function push (/*...values*/) {\n    var arguments$1 = arguments;\n\n    if (arguments.length === 0) {\n      return this;\n    }\n    var newSize = this.size + arguments.length;\n    var head = this._head;\n    for (var ii = arguments.length - 1; ii >= 0; ii--) {\n      head = {\n        value: arguments$1[ii],\n        next: head,\n      };\n    }\n    if (this.__ownerID) {\n      this.size = newSize;\n      this._head = head;\n      this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return makeStack(newSize, head);\n  };\n\n  Stack.prototype.pushAll = function pushAll (iter) {\n    iter = IndexedCollection$$1(iter);\n    if (iter.size === 0) {\n      return this;\n    }\n    if (this.size === 0 && isStack(iter)) {\n      return iter;\n    }\n    assertNotInfinite(iter.size);\n    var newSize = this.size;\n    var head = this._head;\n    iter.__iterate(function (value) {\n      newSize++;\n      head = {\n        value: value,\n        next: head,\n      };\n    }, /* reverse */ true);\n    if (this.__ownerID) {\n      this.size = newSize;\n      this._head = head;\n      this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return makeStack(newSize, head);\n  };\n\n  Stack.prototype.pop = function pop () {\n    return this.slice(1);\n  };\n\n  Stack.prototype.clear = function clear () {\n    if (this.size === 0) {\n      return this;\n    }\n    if (this.__ownerID) {\n      this.size = 0;\n      this._head = undefined;\n      this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return emptyStack();\n  };\n\n  Stack.prototype.slice = function slice (begin, end) {\n    if (wholeSlice(begin, end, this.size)) {\n      return this;\n    }\n    var resolvedBegin = resolveBegin(begin, this.size);\n    var resolvedEnd = resolveEnd(end, this.size);\n    if (resolvedEnd !== this.size) {\n      // super.slice(begin, end);\n      return IndexedCollection$$1.prototype.slice.call(this, begin, end);\n    }\n    var newSize = this.size - resolvedBegin;\n    var head = this._head;\n    while (resolvedBegin--) {\n      head = head.next;\n    }\n    if (this.__ownerID) {\n      this.size = newSize;\n      this._head = head;\n      this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return makeStack(newSize, head);\n  };\n\n  // @pragma Mutability\n\n  Stack.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n    if (!ownerID) {\n      if (this.size === 0) {\n        return emptyStack();\n      }\n      this.__ownerID = ownerID;\n      this.__altered = false;\n      return this;\n    }\n    return makeStack(this.size, this._head, ownerID, this.__hash);\n  };\n\n  // @pragma Iteration\n\n  Stack.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    if (reverse) {\n      return new ArraySeq(this.toArray()).__iterate(\n        function (v, k) { return fn(v, k, this$1); },\n        reverse\n      );\n    }\n    var iterations = 0;\n    var node = this._head;\n    while (node) {\n      if (fn(node.value, iterations++, this) === false) {\n        break;\n      }\n      node = node.next;\n    }\n    return iterations;\n  };\n\n  Stack.prototype.__iterator = function __iterator (type, reverse) {\n    if (reverse) {\n      return new ArraySeq(this.toArray()).__iterator(type, reverse);\n    }\n    var iterations = 0;\n    var node = this._head;\n    return new Iterator(function () {\n      if (node) {\n        var value = node.value;\n        node = node.next;\n        return iteratorValue(type, iterations++, value);\n      }\n      return iteratorDone();\n    });\n  };\n\n  return Stack;\n}(IndexedCollection));\n\nStack.isStack = isStack;\n\nvar StackPrototype = Stack.prototype;\nStackPrototype[IS_STACK_SYMBOL] = true;\nStackPrototype.shift = StackPrototype.pop;\nStackPrototype.unshift = StackPrototype.push;\nStackPrototype.unshiftAll = StackPrototype.pushAll;\nStackPrototype.withMutations = withMutations;\nStackPrototype.wasAltered = wasAltered;\nStackPrototype.asImmutable = asImmutable;\nStackPrototype['@@transducer/init'] = StackPrototype.asMutable = asMutable;\nStackPrototype['@@transducer/step'] = function(result, arr) {\n  return result.unshift(arr);\n};\nStackPrototype['@@transducer/result'] = function(obj) {\n  return obj.asImmutable();\n};\n\nfunction makeStack(size, head, ownerID, hash) {\n  var map = Object.create(StackPrototype);\n  map.size = size;\n  map._head = head;\n  map.__ownerID = ownerID;\n  map.__hash = hash;\n  map.__altered = false;\n  return map;\n}\n\nvar EMPTY_STACK;\nfunction emptyStack() {\n  return EMPTY_STACK || (EMPTY_STACK = makeStack(0));\n}\n\nvar IS_SET_SYMBOL = '@@__IMMUTABLE_SET__@@';\n\nfunction isSet(maybeSet) {\n  return Boolean(maybeSet && maybeSet[IS_SET_SYMBOL]);\n}\n\nfunction isOrderedSet(maybeOrderedSet) {\n  return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);\n}\n\nfunction deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (\n    !isCollection(b) ||\n    (a.size !== undefined && b.size !== undefined && a.size !== b.size) ||\n    (a.__hash !== undefined &&\n      b.__hash !== undefined &&\n      a.__hash !== b.__hash) ||\n    isKeyed(a) !== isKeyed(b) ||\n    isIndexed(a) !== isIndexed(b) ||\n    isOrdered(a) !== isOrdered(b)\n  ) {\n    return false;\n  }\n\n  if (a.size === 0 && b.size === 0) {\n    return true;\n  }\n\n  var notAssociative = !isAssociative(a);\n\n  if (isOrdered(a)) {\n    var entries = a.entries();\n    return (\n      b.every(function (v, k) {\n        var entry = entries.next().value;\n        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));\n      }) && entries.next().done\n    );\n  }\n\n  var flipped = false;\n\n  if (a.size === undefined) {\n    if (b.size === undefined) {\n      if (typeof a.cacheResult === 'function') {\n        a.cacheResult();\n      }\n    } else {\n      flipped = true;\n      var _ = a;\n      a = b;\n      b = _;\n    }\n  }\n\n  var allEqual = true;\n  var bSize = b.__iterate(function (v, k) {\n    if (\n      notAssociative\n        ? !a.has(v)\n        : flipped\n          ? !is(v, a.get(k, NOT_SET))\n          : !is(a.get(k, NOT_SET), v)\n    ) {\n      allEqual = false;\n      return false;\n    }\n  });\n\n  return allEqual && a.size === bSize;\n}\n\n/**\n * Contributes additional methods to a constructor\n */\nfunction mixin(ctor, methods) {\n  var keyCopier = function (key) {\n    ctor.prototype[key] = methods[key];\n  };\n  Object.keys(methods).forEach(keyCopier);\n  Object.getOwnPropertySymbols &&\n    Object.getOwnPropertySymbols(methods).forEach(keyCopier);\n  return ctor;\n}\n\nfunction toJS(value) {\n  if (!value || typeof value !== 'object') {\n    return value;\n  }\n  if (!isCollection(value)) {\n    if (!isDataStructure(value)) {\n      return value;\n    }\n    value = Seq(value);\n  }\n  if (isKeyed(value)) {\n    var result$1 = {};\n    value.__iterate(function (v, k) {\n      result$1[k] = toJS(v);\n    });\n    return result$1;\n  }\n  var result = [];\n  value.__iterate(function (v) {\n    result.push(toJS(v));\n  });\n  return result;\n}\n\nvar Set = /*@__PURE__*/(function (SetCollection$$1) {\n  function Set(value) {\n    return value === null || value === undefined\n      ? emptySet()\n      : isSet(value) && !isOrdered(value)\n        ? value\n        : emptySet().withMutations(function (set) {\n            var iter = SetCollection$$1(value);\n            assertNotInfinite(iter.size);\n            iter.forEach(function (v) { return set.add(v); });\n          });\n  }\n\n  if ( SetCollection$$1 ) Set.__proto__ = SetCollection$$1;\n  Set.prototype = Object.create( SetCollection$$1 && SetCollection$$1.prototype );\n  Set.prototype.constructor = Set;\n\n  Set.of = function of (/*...values*/) {\n    return this(arguments);\n  };\n\n  Set.fromKeys = function fromKeys (value) {\n    return this(KeyedCollection(value).keySeq());\n  };\n\n  Set.intersect = function intersect (sets) {\n    sets = Collection(sets).toArray();\n    return sets.length\n      ? SetPrototype.intersect.apply(Set(sets.pop()), sets)\n      : emptySet();\n  };\n\n  Set.union = function union (sets) {\n    sets = Collection(sets).toArray();\n    return sets.length\n      ? SetPrototype.union.apply(Set(sets.pop()), sets)\n      : emptySet();\n  };\n\n  Set.prototype.toString = function toString () {\n    return this.__toString('Set {', '}');\n  };\n\n  // @pragma Access\n\n  Set.prototype.has = function has (value) {\n    return this._map.has(value);\n  };\n\n  // @pragma Modification\n\n  Set.prototype.add = function add (value) {\n    return updateSet(this, this._map.set(value, value));\n  };\n\n  Set.prototype.remove = function remove (value) {\n    return updateSet(this, this._map.remove(value));\n  };\n\n  Set.prototype.clear = function clear () {\n    return updateSet(this, this._map.clear());\n  };\n\n  // @pragma Composition\n\n  Set.prototype.map = function map (mapper, context) {\n    var this$1 = this;\n\n    var removes = [];\n    var adds = [];\n    this.forEach(function (value) {\n      var mapped = mapper.call(context, value, value, this$1);\n      if (mapped !== value) {\n        removes.push(value);\n        adds.push(mapped);\n      }\n    });\n    return this.withMutations(function (set) {\n      removes.forEach(function (value) { return set.remove(value); });\n      adds.forEach(function (value) { return set.add(value); });\n    });\n  };\n\n  Set.prototype.union = function union () {\n    var iters = [], len = arguments.length;\n    while ( len-- ) iters[ len ] = arguments[ len ];\n\n    iters = iters.filter(function (x) { return x.size !== 0; });\n    if (iters.length === 0) {\n      return this;\n    }\n    if (this.size === 0 && !this.__ownerID && iters.length === 1) {\n      return this.constructor(iters[0]);\n    }\n    return this.withMutations(function (set) {\n      for (var ii = 0; ii < iters.length; ii++) {\n        SetCollection$$1(iters[ii]).forEach(function (value) { return set.add(value); });\n      }\n    });\n  };\n\n  Set.prototype.intersect = function intersect () {\n    var iters = [], len = arguments.length;\n    while ( len-- ) iters[ len ] = arguments[ len ];\n\n    if (iters.length === 0) {\n      return this;\n    }\n    iters = iters.map(function (iter) { return SetCollection$$1(iter); });\n    var toRemove = [];\n    this.forEach(function (value) {\n      if (!iters.every(function (iter) { return iter.includes(value); })) {\n        toRemove.push(value);\n      }\n    });\n    return this.withMutations(function (set) {\n      toRemove.forEach(function (value) {\n        set.remove(value);\n      });\n    });\n  };\n\n  Set.prototype.subtract = function subtract () {\n    var iters = [], len = arguments.length;\n    while ( len-- ) iters[ len ] = arguments[ len ];\n\n    if (iters.length === 0) {\n      return this;\n    }\n    iters = iters.map(function (iter) { return SetCollection$$1(iter); });\n    var toRemove = [];\n    this.forEach(function (value) {\n      if (iters.some(function (iter) { return iter.includes(value); })) {\n        toRemove.push(value);\n      }\n    });\n    return this.withMutations(function (set) {\n      toRemove.forEach(function (value) {\n        set.remove(value);\n      });\n    });\n  };\n\n  Set.prototype.sort = function sort (comparator) {\n    // Late binding\n    return OrderedSet(sortFactory(this, comparator));\n  };\n\n  Set.prototype.sortBy = function sortBy (mapper, comparator) {\n    // Late binding\n    return OrderedSet(sortFactory(this, comparator, mapper));\n  };\n\n  Set.prototype.wasAltered = function wasAltered () {\n    return this._map.wasAltered();\n  };\n\n  Set.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    return this._map.__iterate(function (k) { return fn(k, k, this$1); }, reverse);\n  };\n\n  Set.prototype.__iterator = function __iterator (type, reverse) {\n    return this._map.__iterator(type, reverse);\n  };\n\n  Set.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n    var newMap = this._map.__ensureOwner(ownerID);\n    if (!ownerID) {\n      if (this.size === 0) {\n        return this.__empty();\n      }\n      this.__ownerID = ownerID;\n      this._map = newMap;\n      return this;\n    }\n    return this.__make(newMap, ownerID);\n  };\n\n  return Set;\n}(SetCollection));\n\nSet.isSet = isSet;\n\nvar SetPrototype = Set.prototype;\nSetPrototype[IS_SET_SYMBOL] = true;\nSetPrototype[DELETE] = SetPrototype.remove;\nSetPrototype.merge = SetPrototype.concat = SetPrototype.union;\nSetPrototype.withMutations = withMutations;\nSetPrototype.asImmutable = asImmutable;\nSetPrototype['@@transducer/init'] = SetPrototype.asMutable = asMutable;\nSetPrototype['@@transducer/step'] = function(result, arr) {\n  return result.add(arr);\n};\nSetPrototype['@@transducer/result'] = function(obj) {\n  return obj.asImmutable();\n};\n\nSetPrototype.__empty = emptySet;\nSetPrototype.__make = makeSet;\n\nfunction updateSet(set, newMap) {\n  if (set.__ownerID) {\n    set.size = newMap.size;\n    set._map = newMap;\n    return set;\n  }\n  return newMap === set._map\n    ? set\n    : newMap.size === 0\n      ? set.__empty()\n      : set.__make(newMap);\n}\n\nfunction makeSet(map, ownerID) {\n  var set = Object.create(SetPrototype);\n  set.size = map ? map.size : 0;\n  set._map = map;\n  set.__ownerID = ownerID;\n  return set;\n}\n\nvar EMPTY_SET;\nfunction emptySet() {\n  return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));\n}\n\n/**\n * Returns a lazy seq of nums from start (inclusive) to end\n * (exclusive), by step, where start defaults to 0, step to 1, and end to\n * infinity. When start is equal to end, returns empty list.\n */\nvar Range = /*@__PURE__*/(function (IndexedSeq$$1) {\n  function Range(start, end, step) {\n    if (!(this instanceof Range)) {\n      return new Range(start, end, step);\n    }\n    invariant(step !== 0, 'Cannot step a Range by 0');\n    start = start || 0;\n    if (end === undefined) {\n      end = Infinity;\n    }\n    step = step === undefined ? 1 : Math.abs(step);\n    if (end < start) {\n      step = -step;\n    }\n    this._start = start;\n    this._end = end;\n    this._step = step;\n    this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);\n    if (this.size === 0) {\n      if (EMPTY_RANGE) {\n        return EMPTY_RANGE;\n      }\n      EMPTY_RANGE = this;\n    }\n  }\n\n  if ( IndexedSeq$$1 ) Range.__proto__ = IndexedSeq$$1;\n  Range.prototype = Object.create( IndexedSeq$$1 && IndexedSeq$$1.prototype );\n  Range.prototype.constructor = Range;\n\n  Range.prototype.toString = function toString () {\n    if (this.size === 0) {\n      return 'Range []';\n    }\n    return (\n      'Range [ ' +\n      this._start +\n      '...' +\n      this._end +\n      (this._step !== 1 ? ' by ' + this._step : '') +\n      ' ]'\n    );\n  };\n\n  Range.prototype.get = function get (index, notSetValue) {\n    return this.has(index)\n      ? this._start + wrapIndex(this, index) * this._step\n      : notSetValue;\n  };\n\n  Range.prototype.includes = function includes (searchValue) {\n    var possibleIndex = (searchValue - this._start) / this._step;\n    return (\n      possibleIndex >= 0 &&\n      possibleIndex < this.size &&\n      possibleIndex === Math.floor(possibleIndex)\n    );\n  };\n\n  Range.prototype.slice = function slice (begin, end) {\n    if (wholeSlice(begin, end, this.size)) {\n      return this;\n    }\n    begin = resolveBegin(begin, this.size);\n    end = resolveEnd(end, this.size);\n    if (end <= begin) {\n      return new Range(0, 0);\n    }\n    return new Range(\n      this.get(begin, this._end),\n      this.get(end, this._end),\n      this._step\n    );\n  };\n\n  Range.prototype.indexOf = function indexOf (searchValue) {\n    var offsetValue = searchValue - this._start;\n    if (offsetValue % this._step === 0) {\n      var index = offsetValue / this._step;\n      if (index >= 0 && index < this.size) {\n        return index;\n      }\n    }\n    return -1;\n  };\n\n  Range.prototype.lastIndexOf = function lastIndexOf (searchValue) {\n    return this.indexOf(searchValue);\n  };\n\n  Range.prototype.__iterate = function __iterate (fn, reverse) {\n    var size = this.size;\n    var step = this._step;\n    var value = reverse ? this._start + (size - 1) * step : this._start;\n    var i = 0;\n    while (i !== size) {\n      if (fn(value, reverse ? size - ++i : i++, this) === false) {\n        break;\n      }\n      value += reverse ? -step : step;\n    }\n    return i;\n  };\n\n  Range.prototype.__iterator = function __iterator (type, reverse) {\n    var size = this.size;\n    var step = this._step;\n    var value = reverse ? this._start + (size - 1) * step : this._start;\n    var i = 0;\n    return new Iterator(function () {\n      if (i === size) {\n        return iteratorDone();\n      }\n      var v = value;\n      value += reverse ? -step : step;\n      return iteratorValue(type, reverse ? size - ++i : i++, v);\n    });\n  };\n\n  Range.prototype.equals = function equals (other) {\n    return other instanceof Range\n      ? this._start === other._start &&\n          this._end === other._end &&\n          this._step === other._step\n      : deepEqual(this, other);\n  };\n\n  return Range;\n}(IndexedSeq));\n\nvar EMPTY_RANGE;\n\nfunction getIn(collection, searchKeyPath, notSetValue) {\n  var keyPath = coerceKeyPath(searchKeyPath);\n  var i = 0;\n  while (i !== keyPath.length) {\n    collection = get(collection, keyPath[i++], NOT_SET);\n    if (collection === NOT_SET) {\n      return notSetValue;\n    }\n  }\n  return collection;\n}\n\nfunction getIn$1(searchKeyPath, notSetValue) {\n  return getIn(this, searchKeyPath, notSetValue);\n}\n\nfunction hasIn(collection, keyPath) {\n  return getIn(collection, keyPath, NOT_SET) !== NOT_SET;\n}\n\nfunction hasIn$1(searchKeyPath) {\n  return hasIn(this, searchKeyPath);\n}\n\nfunction toObject() {\n  assertNotInfinite(this.size);\n  var object = {};\n  this.__iterate(function (v, k) {\n    object[k] = v;\n  });\n  return object;\n}\n\n// Note: all of these methods are deprecated.\nCollection.isIterable = isCollection;\nCollection.isKeyed = isKeyed;\nCollection.isIndexed = isIndexed;\nCollection.isAssociative = isAssociative;\nCollection.isOrdered = isOrdered;\n\nCollection.Iterator = Iterator;\n\nmixin(Collection, {\n  // ### Conversion to other types\n\n  toArray: function toArray() {\n    assertNotInfinite(this.size);\n    var array = new Array(this.size || 0);\n    var useTuples = isKeyed(this);\n    var i = 0;\n    this.__iterate(function (v, k) {\n      // Keyed collections produce an array of tuples.\n      array[i++] = useTuples ? [k, v] : v;\n    });\n    return array;\n  },\n\n  toIndexedSeq: function toIndexedSeq() {\n    return new ToIndexedSequence(this);\n  },\n\n  toJS: function toJS$1() {\n    return toJS(this);\n  },\n\n  toKeyedSeq: function toKeyedSeq() {\n    return new ToKeyedSequence(this, true);\n  },\n\n  toMap: function toMap() {\n    // Use Late Binding here to solve the circular dependency.\n    return Map(this.toKeyedSeq());\n  },\n\n  toObject: toObject,\n\n  toOrderedMap: function toOrderedMap() {\n    // Use Late Binding here to solve the circular dependency.\n    return OrderedMap(this.toKeyedSeq());\n  },\n\n  toOrderedSet: function toOrderedSet() {\n    // Use Late Binding here to solve the circular dependency.\n    return OrderedSet(isKeyed(this) ? this.valueSeq() : this);\n  },\n\n  toSet: function toSet() {\n    // Use Late Binding here to solve the circular dependency.\n    return Set(isKeyed(this) ? this.valueSeq() : this);\n  },\n\n  toSetSeq: function toSetSeq() {\n    return new ToSetSequence(this);\n  },\n\n  toSeq: function toSeq() {\n    return isIndexed(this)\n      ? this.toIndexedSeq()\n      : isKeyed(this)\n        ? this.toKeyedSeq()\n        : this.toSetSeq();\n  },\n\n  toStack: function toStack() {\n    // Use Late Binding here to solve the circular dependency.\n    return Stack(isKeyed(this) ? this.valueSeq() : this);\n  },\n\n  toList: function toList() {\n    // Use Late Binding here to solve the circular dependency.\n    return List(isKeyed(this) ? this.valueSeq() : this);\n  },\n\n  // ### Common JavaScript methods and properties\n\n  toString: function toString() {\n    return '[Collection]';\n  },\n\n  __toString: function __toString(head, tail) {\n    if (this.size === 0) {\n      return head + tail;\n    }\n    return (\n      head +\n      ' ' +\n      this.toSeq()\n        .map(this.__toStringMapper)\n        .join(', ') +\n      ' ' +\n      tail\n    );\n  },\n\n  // ### ES6 Collection methods (ES6 Array and Map)\n\n  concat: function concat() {\n    var values = [], len = arguments.length;\n    while ( len-- ) values[ len ] = arguments[ len ];\n\n    return reify(this, concatFactory(this, values));\n  },\n\n  includes: function includes(searchValue) {\n    return this.some(function (value) { return is(value, searchValue); });\n  },\n\n  entries: function entries() {\n    return this.__iterator(ITERATE_ENTRIES);\n  },\n\n  every: function every(predicate, context) {\n    assertNotInfinite(this.size);\n    var returnValue = true;\n    this.__iterate(function (v, k, c) {\n      if (!predicate.call(context, v, k, c)) {\n        returnValue = false;\n        return false;\n      }\n    });\n    return returnValue;\n  },\n\n  filter: function filter(predicate, context) {\n    return reify(this, filterFactory(this, predicate, context, true));\n  },\n\n  find: function find(predicate, context, notSetValue) {\n    var entry = this.findEntry(predicate, context);\n    return entry ? entry[1] : notSetValue;\n  },\n\n  forEach: function forEach(sideEffect, context) {\n    assertNotInfinite(this.size);\n    return this.__iterate(context ? sideEffect.bind(context) : sideEffect);\n  },\n\n  join: function join(separator) {\n    assertNotInfinite(this.size);\n    separator = separator !== undefined ? '' + separator : ',';\n    var joined = '';\n    var isFirst = true;\n    this.__iterate(function (v) {\n      isFirst ? (isFirst = false) : (joined += separator);\n      joined += v !== null && v !== undefined ? v.toString() : '';\n    });\n    return joined;\n  },\n\n  keys: function keys() {\n    return this.__iterator(ITERATE_KEYS);\n  },\n\n  map: function map(mapper, context) {\n    return reify(this, mapFactory(this, mapper, context));\n  },\n\n  reduce: function reduce$1(reducer, initialReduction, context) {\n    return reduce(\n      this,\n      reducer,\n      initialReduction,\n      context,\n      arguments.length < 2,\n      false\n    );\n  },\n\n  reduceRight: function reduceRight(reducer, initialReduction, context) {\n    return reduce(\n      this,\n      reducer,\n      initialReduction,\n      context,\n      arguments.length < 2,\n      true\n    );\n  },\n\n  reverse: function reverse() {\n    return reify(this, reverseFactory(this, true));\n  },\n\n  slice: function slice(begin, end) {\n    return reify(this, sliceFactory(this, begin, end, true));\n  },\n\n  some: function some(predicate, context) {\n    return !this.every(not(predicate), context);\n  },\n\n  sort: function sort(comparator) {\n    return reify(this, sortFactory(this, comparator));\n  },\n\n  values: function values() {\n    return this.__iterator(ITERATE_VALUES);\n  },\n\n  // ### More sequential methods\n\n  butLast: function butLast() {\n    return this.slice(0, -1);\n  },\n\n  isEmpty: function isEmpty() {\n    return this.size !== undefined ? this.size === 0 : !this.some(function () { return true; });\n  },\n\n  count: function count(predicate, context) {\n    return ensureSize(\n      predicate ? this.toSeq().filter(predicate, context) : this\n    );\n  },\n\n  countBy: function countBy(grouper, context) {\n    return countByFactory(this, grouper, context);\n  },\n\n  equals: function equals(other) {\n    return deepEqual(this, other);\n  },\n\n  entrySeq: function entrySeq() {\n    var collection = this;\n    if (collection._cache) {\n      // We cache as an entries array, so we can just return the cache!\n      return new ArraySeq(collection._cache);\n    }\n    var entriesSequence = collection\n      .toSeq()\n      .map(entryMapper)\n      .toIndexedSeq();\n    entriesSequence.fromEntrySeq = function () { return collection.toSeq(); };\n    return entriesSequence;\n  },\n\n  filterNot: function filterNot(predicate, context) {\n    return this.filter(not(predicate), context);\n  },\n\n  findEntry: function findEntry(predicate, context, notSetValue) {\n    var found = notSetValue;\n    this.__iterate(function (v, k, c) {\n      if (predicate.call(context, v, k, c)) {\n        found = [k, v];\n        return false;\n      }\n    });\n    return found;\n  },\n\n  findKey: function findKey(predicate, context) {\n    var entry = this.findEntry(predicate, context);\n    return entry && entry[0];\n  },\n\n  findLast: function findLast(predicate, context, notSetValue) {\n    return this.toKeyedSeq()\n      .reverse()\n      .find(predicate, context, notSetValue);\n  },\n\n  findLastEntry: function findLastEntry(predicate, context, notSetValue) {\n    return this.toKeyedSeq()\n      .reverse()\n      .findEntry(predicate, context, notSetValue);\n  },\n\n  findLastKey: function findLastKey(predicate, context) {\n    return this.toKeyedSeq()\n      .reverse()\n      .findKey(predicate, context);\n  },\n\n  first: function first(notSetValue) {\n    return this.find(returnTrue, null, notSetValue);\n  },\n\n  flatMap: function flatMap(mapper, context) {\n    return reify(this, flatMapFactory(this, mapper, context));\n  },\n\n  flatten: function flatten(depth) {\n    return reify(this, flattenFactory(this, depth, true));\n  },\n\n  fromEntrySeq: function fromEntrySeq() {\n    return new FromEntriesSequence(this);\n  },\n\n  get: function get(searchKey, notSetValue) {\n    return this.find(function (_, key) { return is(key, searchKey); }, undefined, notSetValue);\n  },\n\n  getIn: getIn$1,\n\n  groupBy: function groupBy(grouper, context) {\n    return groupByFactory(this, grouper, context);\n  },\n\n  has: function has(searchKey) {\n    return this.get(searchKey, NOT_SET) !== NOT_SET;\n  },\n\n  hasIn: hasIn$1,\n\n  isSubset: function isSubset(iter) {\n    iter = typeof iter.includes === 'function' ? iter : Collection(iter);\n    return this.every(function (value) { return iter.includes(value); });\n  },\n\n  isSuperset: function isSuperset(iter) {\n    iter = typeof iter.isSubset === 'function' ? iter : Collection(iter);\n    return iter.isSubset(this);\n  },\n\n  keyOf: function keyOf(searchValue) {\n    return this.findKey(function (value) { return is(value, searchValue); });\n  },\n\n  keySeq: function keySeq() {\n    return this.toSeq()\n      .map(keyMapper)\n      .toIndexedSeq();\n  },\n\n  last: function last(notSetValue) {\n    return this.toSeq()\n      .reverse()\n      .first(notSetValue);\n  },\n\n  lastKeyOf: function lastKeyOf(searchValue) {\n    return this.toKeyedSeq()\n      .reverse()\n      .keyOf(searchValue);\n  },\n\n  max: function max(comparator) {\n    return maxFactory(this, comparator);\n  },\n\n  maxBy: function maxBy(mapper, comparator) {\n    return maxFactory(this, comparator, mapper);\n  },\n\n  min: function min(comparator) {\n    return maxFactory(\n      this,\n      comparator ? neg(comparator) : defaultNegComparator\n    );\n  },\n\n  minBy: function minBy(mapper, comparator) {\n    return maxFactory(\n      this,\n      comparator ? neg(comparator) : defaultNegComparator,\n      mapper\n    );\n  },\n\n  rest: function rest() {\n    return this.slice(1);\n  },\n\n  skip: function skip(amount) {\n    return amount === 0 ? this : this.slice(Math.max(0, amount));\n  },\n\n  skipLast: function skipLast(amount) {\n    return amount === 0 ? this : this.slice(0, -Math.max(0, amount));\n  },\n\n  skipWhile: function skipWhile(predicate, context) {\n    return reify(this, skipWhileFactory(this, predicate, context, true));\n  },\n\n  skipUntil: function skipUntil(predicate, context) {\n    return this.skipWhile(not(predicate), context);\n  },\n\n  sortBy: function sortBy(mapper, comparator) {\n    return reify(this, sortFactory(this, comparator, mapper));\n  },\n\n  take: function take(amount) {\n    return this.slice(0, Math.max(0, amount));\n  },\n\n  takeLast: function takeLast(amount) {\n    return this.slice(-Math.max(0, amount));\n  },\n\n  takeWhile: function takeWhile(predicate, context) {\n    return reify(this, takeWhileFactory(this, predicate, context));\n  },\n\n  takeUntil: function takeUntil(predicate, context) {\n    return this.takeWhile(not(predicate), context);\n  },\n\n  update: function update(fn) {\n    return fn(this);\n  },\n\n  valueSeq: function valueSeq() {\n    return this.toIndexedSeq();\n  },\n\n  // ### Hashable Object\n\n  hashCode: function hashCode() {\n    return this.__hash || (this.__hash = hashCollection(this));\n  },\n\n  // ### Internal\n\n  // abstract __iterate(fn, reverse)\n\n  // abstract __iterator(type, reverse)\n});\n\nvar CollectionPrototype = Collection.prototype;\nCollectionPrototype[IS_COLLECTION_SYMBOL] = true;\nCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.values;\nCollectionPrototype.toJSON = CollectionPrototype.toArray;\nCollectionPrototype.__toStringMapper = quoteString;\nCollectionPrototype.inspect = CollectionPrototype.toSource = function() {\n  return this.toString();\n};\nCollectionPrototype.chain = CollectionPrototype.flatMap;\nCollectionPrototype.contains = CollectionPrototype.includes;\n\nmixin(KeyedCollection, {\n  // ### More sequential methods\n\n  flip: function flip() {\n    return reify(this, flipFactory(this));\n  },\n\n  mapEntries: function mapEntries(mapper, context) {\n    var this$1 = this;\n\n    var iterations = 0;\n    return reify(\n      this,\n      this.toSeq()\n        .map(function (v, k) { return mapper.call(context, [k, v], iterations++, this$1); })\n        .fromEntrySeq()\n    );\n  },\n\n  mapKeys: function mapKeys(mapper, context) {\n    var this$1 = this;\n\n    return reify(\n      this,\n      this.toSeq()\n        .flip()\n        .map(function (k, v) { return mapper.call(context, k, v, this$1); })\n        .flip()\n    );\n  },\n});\n\nvar KeyedCollectionPrototype = KeyedCollection.prototype;\nKeyedCollectionPrototype[IS_KEYED_SYMBOL] = true;\nKeyedCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.entries;\nKeyedCollectionPrototype.toJSON = toObject;\nKeyedCollectionPrototype.__toStringMapper = function (v, k) { return quoteString(k) + ': ' + quoteString(v); };\n\nmixin(IndexedCollection, {\n  // ### Conversion to other types\n\n  toKeyedSeq: function toKeyedSeq() {\n    return new ToKeyedSequence(this, false);\n  },\n\n  // ### ES6 Collection methods (ES6 Array and Map)\n\n  filter: function filter(predicate, context) {\n    return reify(this, filterFactory(this, predicate, context, false));\n  },\n\n  findIndex: function findIndex(predicate, context) {\n    var entry = this.findEntry(predicate, context);\n    return entry ? entry[0] : -1;\n  },\n\n  indexOf: function indexOf(searchValue) {\n    var key = this.keyOf(searchValue);\n    return key === undefined ? -1 : key;\n  },\n\n  lastIndexOf: function lastIndexOf(searchValue) {\n    var key = this.lastKeyOf(searchValue);\n    return key === undefined ? -1 : key;\n  },\n\n  reverse: function reverse() {\n    return reify(this, reverseFactory(this, false));\n  },\n\n  slice: function slice(begin, end) {\n    return reify(this, sliceFactory(this, begin, end, false));\n  },\n\n  splice: function splice(index, removeNum /*, ...values*/) {\n    var numArgs = arguments.length;\n    removeNum = Math.max(removeNum || 0, 0);\n    if (numArgs === 0 || (numArgs === 2 && !removeNum)) {\n      return this;\n    }\n    // If index is negative, it should resolve relative to the size of the\n    // collection. However size may be expensive to compute if not cached, so\n    // only call count() if the number is in fact negative.\n    index = resolveBegin(index, index < 0 ? this.count() : this.size);\n    var spliced = this.slice(0, index);\n    return reify(\n      this,\n      numArgs === 1\n        ? spliced\n        : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))\n    );\n  },\n\n  // ### More collection methods\n\n  findLastIndex: function findLastIndex(predicate, context) {\n    var entry = this.findLastEntry(predicate, context);\n    return entry ? entry[0] : -1;\n  },\n\n  first: function first(notSetValue) {\n    return this.get(0, notSetValue);\n  },\n\n  flatten: function flatten(depth) {\n    return reify(this, flattenFactory(this, depth, false));\n  },\n\n  get: function get(index, notSetValue) {\n    index = wrapIndex(this, index);\n    return index < 0 ||\n      (this.size === Infinity || (this.size !== undefined && index > this.size))\n      ? notSetValue\n      : this.find(function (_, key) { return key === index; }, undefined, notSetValue);\n  },\n\n  has: function has(index) {\n    index = wrapIndex(this, index);\n    return (\n      index >= 0 &&\n      (this.size !== undefined\n        ? this.size === Infinity || index < this.size\n        : this.indexOf(index) !== -1)\n    );\n  },\n\n  interpose: function interpose(separator) {\n    return reify(this, interposeFactory(this, separator));\n  },\n\n  interleave: function interleave(/*...collections*/) {\n    var collections = [this].concat(arrCopy(arguments));\n    var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, collections);\n    var interleaved = zipped.flatten(true);\n    if (zipped.size) {\n      interleaved.size = zipped.size * collections.length;\n    }\n    return reify(this, interleaved);\n  },\n\n  keySeq: function keySeq() {\n    return Range(0, this.size);\n  },\n\n  last: function last(notSetValue) {\n    return this.get(-1, notSetValue);\n  },\n\n  skipWhile: function skipWhile(predicate, context) {\n    return reify(this, skipWhileFactory(this, predicate, context, false));\n  },\n\n  zip: function zip(/*, ...collections */) {\n    var collections = [this].concat(arrCopy(arguments));\n    return reify(this, zipWithFactory(this, defaultZipper, collections));\n  },\n\n  zipAll: function zipAll(/*, ...collections */) {\n    var collections = [this].concat(arrCopy(arguments));\n    return reify(this, zipWithFactory(this, defaultZipper, collections, true));\n  },\n\n  zipWith: function zipWith(zipper /*, ...collections */) {\n    var collections = arrCopy(arguments);\n    collections[0] = this;\n    return reify(this, zipWithFactory(this, zipper, collections));\n  },\n});\n\nvar IndexedCollectionPrototype = IndexedCollection.prototype;\nIndexedCollectionPrototype[IS_INDEXED_SYMBOL] = true;\nIndexedCollectionPrototype[IS_ORDERED_SYMBOL] = true;\n\nmixin(SetCollection, {\n  // ### ES6 Collection methods (ES6 Array and Map)\n\n  get: function get(value, notSetValue) {\n    return this.has(value) ? value : notSetValue;\n  },\n\n  includes: function includes(value) {\n    return this.has(value);\n  },\n\n  // ### More sequential methods\n\n  keySeq: function keySeq() {\n    return this.valueSeq();\n  },\n});\n\nSetCollection.prototype.has = CollectionPrototype.includes;\nSetCollection.prototype.contains = SetCollection.prototype.includes;\n\n// Mixin subclasses\n\nmixin(KeyedSeq, KeyedCollection.prototype);\nmixin(IndexedSeq, IndexedCollection.prototype);\nmixin(SetSeq, SetCollection.prototype);\n\n// #pragma Helper functions\n\nfunction reduce(collection, reducer, reduction, context, useFirst, reverse) {\n  assertNotInfinite(collection.size);\n  collection.__iterate(function (v, k, c) {\n    if (useFirst) {\n      useFirst = false;\n      reduction = v;\n    } else {\n      reduction = reducer.call(context, reduction, v, k, c);\n    }\n  }, reverse);\n  return reduction;\n}\n\nfunction keyMapper(v, k) {\n  return k;\n}\n\nfunction entryMapper(v, k) {\n  return [k, v];\n}\n\nfunction not(predicate) {\n  return function() {\n    return !predicate.apply(this, arguments);\n  };\n}\n\nfunction neg(predicate) {\n  return function() {\n    return -predicate.apply(this, arguments);\n  };\n}\n\nfunction defaultZipper() {\n  return arrCopy(arguments);\n}\n\nfunction defaultNegComparator(a, b) {\n  return a < b ? 1 : a > b ? -1 : 0;\n}\n\nfunction hashCollection(collection) {\n  if (collection.size === Infinity) {\n    return 0;\n  }\n  var ordered = isOrdered(collection);\n  var keyed = isKeyed(collection);\n  var h = ordered ? 1 : 0;\n  var size = collection.__iterate(\n    keyed\n      ? ordered\n        ? function (v, k) {\n            h = (31 * h + hashMerge(hash(v), hash(k))) | 0;\n          }\n        : function (v, k) {\n            h = (h + hashMerge(hash(v), hash(k))) | 0;\n          }\n      : ordered\n        ? function (v) {\n            h = (31 * h + hash(v)) | 0;\n          }\n        : function (v) {\n            h = (h + hash(v)) | 0;\n          }\n  );\n  return murmurHashOfSize(size, h);\n}\n\nfunction murmurHashOfSize(size, h) {\n  h = imul(h, 0xcc9e2d51);\n  h = imul((h << 15) | (h >>> -15), 0x1b873593);\n  h = imul((h << 13) | (h >>> -13), 5);\n  h = ((h + 0xe6546b64) | 0) ^ size;\n  h = imul(h ^ (h >>> 16), 0x85ebca6b);\n  h = imul(h ^ (h >>> 13), 0xc2b2ae35);\n  h = smi(h ^ (h >>> 16));\n  return h;\n}\n\nfunction hashMerge(a, b) {\n  return (a ^ (b + 0x9e3779b9 + (a << 6) + (a >> 2))) | 0; // int\n}\n\nvar OrderedSet = /*@__PURE__*/(function (Set$$1) {\n  function OrderedSet(value) {\n    return value === null || value === undefined\n      ? emptyOrderedSet()\n      : isOrderedSet(value)\n        ? value\n        : emptyOrderedSet().withMutations(function (set) {\n            var iter = SetCollection(value);\n            assertNotInfinite(iter.size);\n            iter.forEach(function (v) { return set.add(v); });\n          });\n  }\n\n  if ( Set$$1 ) OrderedSet.__proto__ = Set$$1;\n  OrderedSet.prototype = Object.create( Set$$1 && Set$$1.prototype );\n  OrderedSet.prototype.constructor = OrderedSet;\n\n  OrderedSet.of = function of (/*...values*/) {\n    return this(arguments);\n  };\n\n  OrderedSet.fromKeys = function fromKeys (value) {\n    return this(KeyedCollection(value).keySeq());\n  };\n\n  OrderedSet.prototype.toString = function toString () {\n    return this.__toString('OrderedSet {', '}');\n  };\n\n  return OrderedSet;\n}(Set));\n\nOrderedSet.isOrderedSet = isOrderedSet;\n\nvar OrderedSetPrototype = OrderedSet.prototype;\nOrderedSetPrototype[IS_ORDERED_SYMBOL] = true;\nOrderedSetPrototype.zip = IndexedCollectionPrototype.zip;\nOrderedSetPrototype.zipWith = IndexedCollectionPrototype.zipWith;\n\nOrderedSetPrototype.__empty = emptyOrderedSet;\nOrderedSetPrototype.__make = makeOrderedSet;\n\nfunction makeOrderedSet(map, ownerID) {\n  var set = Object.create(OrderedSetPrototype);\n  set.size = map ? map.size : 0;\n  set._map = map;\n  set.__ownerID = ownerID;\n  return set;\n}\n\nvar EMPTY_ORDERED_SET;\nfunction emptyOrderedSet() {\n  return (\n    EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()))\n  );\n}\n\nvar Record = function Record(defaultValues, name) {\n  var hasInitialized;\n\n  var RecordType = function Record(values) {\n    var this$1 = this;\n\n    if (values instanceof RecordType) {\n      return values;\n    }\n    if (!(this instanceof RecordType)) {\n      return new RecordType(values);\n    }\n    if (!hasInitialized) {\n      hasInitialized = true;\n      var keys = Object.keys(defaultValues);\n      var indices = (RecordTypePrototype._indices = {});\n      // Deprecated: left to attempt not to break any external code which\n      // relies on a ._name property existing on record instances.\n      // Use Record.getDescriptiveName() instead\n      RecordTypePrototype._name = name;\n      RecordTypePrototype._keys = keys;\n      RecordTypePrototype._defaultValues = defaultValues;\n      for (var i = 0; i < keys.length; i++) {\n        var propName = keys[i];\n        indices[propName] = i;\n        if (RecordTypePrototype[propName]) {\n          /* eslint-disable no-console */\n          typeof console === 'object' &&\n            console.warn &&\n            console.warn(\n              'Cannot define ' +\n                recordName(this) +\n                ' with property \"' +\n                propName +\n                '\" since that property name is part of the Record API.'\n            );\n          /* eslint-enable no-console */\n        } else {\n          setProp(RecordTypePrototype, propName);\n        }\n      }\n    }\n    this.__ownerID = undefined;\n    this._values = List().withMutations(function (l) {\n      l.setSize(this$1._keys.length);\n      KeyedCollection(values).forEach(function (v, k) {\n        l.set(this$1._indices[k], v === this$1._defaultValues[k] ? undefined : v);\n      });\n    });\n  };\n\n  var RecordTypePrototype = (RecordType.prototype = Object.create(\n    RecordPrototype\n  ));\n  RecordTypePrototype.constructor = RecordType;\n\n  if (name) {\n    RecordType.displayName = name;\n  }\n\n  return RecordType;\n};\n\nRecord.prototype.toString = function toString () {\n  var str = recordName(this) + ' { ';\n  var keys = this._keys;\n  var k;\n  for (var i = 0, l = keys.length; i !== l; i++) {\n    k = keys[i];\n    str += (i ? ', ' : '') + k + ': ' + quoteString(this.get(k));\n  }\n  return str + ' }';\n};\n\nRecord.prototype.equals = function equals (other) {\n  return (\n    this === other ||\n    (other &&\n      this._keys === other._keys &&\n      recordSeq(this).equals(recordSeq(other)))\n  );\n};\n\nRecord.prototype.hashCode = function hashCode () {\n  return recordSeq(this).hashCode();\n};\n\n// @pragma Access\n\nRecord.prototype.has = function has (k) {\n  return this._indices.hasOwnProperty(k);\n};\n\nRecord.prototype.get = function get (k, notSetValue) {\n  if (!this.has(k)) {\n    return notSetValue;\n  }\n  var index = this._indices[k];\n  var value = this._values.get(index);\n  return value === undefined ? this._defaultValues[k] : value;\n};\n\n// @pragma Modification\n\nRecord.prototype.set = function set (k, v) {\n  if (this.has(k)) {\n    var newValues = this._values.set(\n      this._indices[k],\n      v === this._defaultValues[k] ? undefined : v\n    );\n    if (newValues !== this._values && !this.__ownerID) {\n      return makeRecord(this, newValues);\n    }\n  }\n  return this;\n};\n\nRecord.prototype.remove = function remove (k) {\n  return this.set(k);\n};\n\nRecord.prototype.clear = function clear () {\n  var newValues = this._values.clear().setSize(this._keys.length);\n  return this.__ownerID ? this : makeRecord(this, newValues);\n};\n\nRecord.prototype.wasAltered = function wasAltered () {\n  return this._values.wasAltered();\n};\n\nRecord.prototype.toSeq = function toSeq () {\n  return recordSeq(this);\n};\n\nRecord.prototype.toJS = function toJS$1 () {\n  return toJS(this);\n};\n\nRecord.prototype.entries = function entries () {\n  return this.__iterator(ITERATE_ENTRIES);\n};\n\nRecord.prototype.__iterator = function __iterator (type, reverse) {\n  return recordSeq(this).__iterator(type, reverse);\n};\n\nRecord.prototype.__iterate = function __iterate (fn, reverse) {\n  return recordSeq(this).__iterate(fn, reverse);\n};\n\nRecord.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n  if (ownerID === this.__ownerID) {\n    return this;\n  }\n  var newValues = this._values.__ensureOwner(ownerID);\n  if (!ownerID) {\n    this.__ownerID = ownerID;\n    this._values = newValues;\n    return this;\n  }\n  return makeRecord(this, newValues, ownerID);\n};\n\nRecord.isRecord = isRecord;\nRecord.getDescriptiveName = recordName;\nvar RecordPrototype = Record.prototype;\nRecordPrototype[IS_RECORD_SYMBOL] = true;\nRecordPrototype[DELETE] = RecordPrototype.remove;\nRecordPrototype.deleteIn = RecordPrototype.removeIn = deleteIn;\nRecordPrototype.getIn = getIn$1;\nRecordPrototype.hasIn = CollectionPrototype.hasIn;\nRecordPrototype.merge = merge;\nRecordPrototype.mergeWith = mergeWith;\nRecordPrototype.mergeIn = mergeIn;\nRecordPrototype.mergeDeep = mergeDeep$1;\nRecordPrototype.mergeDeepWith = mergeDeepWith$1;\nRecordPrototype.mergeDeepIn = mergeDeepIn;\nRecordPrototype.setIn = setIn$1;\nRecordPrototype.update = update$1;\nRecordPrototype.updateIn = updateIn$1;\nRecordPrototype.withMutations = withMutations;\nRecordPrototype.asMutable = asMutable;\nRecordPrototype.asImmutable = asImmutable;\nRecordPrototype[ITERATOR_SYMBOL] = RecordPrototype.entries;\nRecordPrototype.toJSON = RecordPrototype.toObject =\n  CollectionPrototype.toObject;\nRecordPrototype.inspect = RecordPrototype.toSource = function() {\n  return this.toString();\n};\n\nfunction makeRecord(likeRecord, values, ownerID) {\n  var record = Object.create(Object.getPrototypeOf(likeRecord));\n  record._values = values;\n  record.__ownerID = ownerID;\n  return record;\n}\n\nfunction recordName(record) {\n  return record.constructor.displayName || record.constructor.name || 'Record';\n}\n\nfunction recordSeq(record) {\n  return keyedSeqFromValue(record._keys.map(function (k) { return [k, record.get(k)]; }));\n}\n\nfunction setProp(prototype, name) {\n  try {\n    Object.defineProperty(prototype, name, {\n      get: function() {\n        return this.get(name);\n      },\n      set: function(value) {\n        invariant(this.__ownerID, 'Cannot set on an immutable record.');\n        this.set(name, value);\n      },\n    });\n  } catch (error) {\n    // Object.defineProperty failed. Probably IE8.\n  }\n}\n\n/**\n * Returns a lazy Seq of `value` repeated `times` times. When `times` is\n * undefined, returns an infinite sequence of `value`.\n */\nvar Repeat = /*@__PURE__*/(function (IndexedSeq$$1) {\n  function Repeat(value, times) {\n    if (!(this instanceof Repeat)) {\n      return new Repeat(value, times);\n    }\n    this._value = value;\n    this.size = times === undefined ? Infinity : Math.max(0, times);\n    if (this.size === 0) {\n      if (EMPTY_REPEAT) {\n        return EMPTY_REPEAT;\n      }\n      EMPTY_REPEAT = this;\n    }\n  }\n\n  if ( IndexedSeq$$1 ) Repeat.__proto__ = IndexedSeq$$1;\n  Repeat.prototype = Object.create( IndexedSeq$$1 && IndexedSeq$$1.prototype );\n  Repeat.prototype.constructor = Repeat;\n\n  Repeat.prototype.toString = function toString () {\n    if (this.size === 0) {\n      return 'Repeat []';\n    }\n    return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';\n  };\n\n  Repeat.prototype.get = function get (index, notSetValue) {\n    return this.has(index) ? this._value : notSetValue;\n  };\n\n  Repeat.prototype.includes = function includes (searchValue) {\n    return is(this._value, searchValue);\n  };\n\n  Repeat.prototype.slice = function slice (begin, end) {\n    var size = this.size;\n    return wholeSlice(begin, end, size)\n      ? this\n      : new Repeat(\n          this._value,\n          resolveEnd(end, size) - resolveBegin(begin, size)\n        );\n  };\n\n  Repeat.prototype.reverse = function reverse () {\n    return this;\n  };\n\n  Repeat.prototype.indexOf = function indexOf (searchValue) {\n    if (is(this._value, searchValue)) {\n      return 0;\n    }\n    return -1;\n  };\n\n  Repeat.prototype.lastIndexOf = function lastIndexOf (searchValue) {\n    if (is(this._value, searchValue)) {\n      return this.size;\n    }\n    return -1;\n  };\n\n  Repeat.prototype.__iterate = function __iterate (fn, reverse) {\n    var size = this.size;\n    var i = 0;\n    while (i !== size) {\n      if (fn(this._value, reverse ? size - ++i : i++, this) === false) {\n        break;\n      }\n    }\n    return i;\n  };\n\n  Repeat.prototype.__iterator = function __iterator (type, reverse) {\n    var this$1 = this;\n\n    var size = this.size;\n    var i = 0;\n    return new Iterator(\n      function () { return i === size\n          ? iteratorDone()\n          : iteratorValue(type, reverse ? size - ++i : i++, this$1._value); }\n    );\n  };\n\n  Repeat.prototype.equals = function equals (other) {\n    return other instanceof Repeat\n      ? is(this._value, other._value)\n      : deepEqual(other);\n  };\n\n  return Repeat;\n}(IndexedSeq));\n\nvar EMPTY_REPEAT;\n\nfunction fromJS(value, converter) {\n  return fromJSWith(\n    [],\n    converter || defaultConverter,\n    value,\n    '',\n    converter && converter.length > 2 ? [] : undefined,\n    { '': value }\n  );\n}\n\nfunction fromJSWith(stack, converter, value, key, keyPath, parentValue) {\n  var toSeq = Array.isArray(value)\n    ? IndexedSeq\n    : isPlainObj(value)\n      ? KeyedSeq\n      : null;\n  if (toSeq) {\n    if (~stack.indexOf(value)) {\n      throw new TypeError('Cannot convert circular structure to Immutable');\n    }\n    stack.push(value);\n    keyPath && key !== '' && keyPath.push(key);\n    var converted = converter.call(\n      parentValue,\n      key,\n      toSeq(value).map(function (v, k) { return fromJSWith(stack, converter, v, k, keyPath, value); }\n      ),\n      keyPath && keyPath.slice()\n    );\n    stack.pop();\n    keyPath && keyPath.pop();\n    return converted;\n  }\n  return value;\n}\n\nfunction defaultConverter(k, v) {\n  return isKeyed(v) ? v.toMap() : v.toList();\n}\n\nvar version = \"4.0.0-rc.11\";\n\nvar Immutable = {\n  version: version,\n\n  Collection: Collection,\n  // Note: Iterable is deprecated\n  Iterable: Collection,\n\n  Seq: Seq,\n  Map: Map,\n  OrderedMap: OrderedMap,\n  List: List,\n  Stack: Stack,\n  Set: Set,\n  OrderedSet: OrderedSet,\n\n  Record: Record,\n  Range: Range,\n  Repeat: Repeat,\n\n  is: is,\n  fromJS: fromJS,\n  hash: hash,\n\n  isImmutable: isImmutable,\n  isCollection: isCollection,\n  isKeyed: isKeyed,\n  isIndexed: isIndexed,\n  isAssociative: isAssociative,\n  isOrdered: isOrdered,\n  isValueObject: isValueObject,\n  isSeq: isSeq,\n  isList: isList,\n  isMap: isMap,\n  isOrderedMap: isOrderedMap,\n  isStack: isStack,\n  isSet: isSet,\n  isOrderedSet: isOrderedSet,\n  isRecord: isRecord,\n\n  get: get,\n  getIn: getIn,\n  has: has,\n  hasIn: hasIn,\n  merge: merge$1,\n  mergeDeep: mergeDeep,\n  mergeWith: mergeWith$1,\n  mergeDeepWith: mergeDeepWith,\n  remove: remove,\n  removeIn: removeIn,\n  set: set,\n  setIn: setIn,\n  update: update,\n  updateIn: updateIn,\n};\n\n// Note: Iterable is deprecated\nvar Iterable = Collection;\n\nexport default Immutable;\nexport { version, Collection, Iterable, Seq, Map, OrderedMap, List, Stack, Set, OrderedSet, Record, Range, Repeat, is, fromJS, hash, isImmutable, isCollection, isKeyed, isIndexed, isAssociative, isOrdered, isValueObject, get, getIn, has, hasIn, merge$1 as merge, mergeDeep, mergeWith$1 as mergeWith, mergeDeepWith, remove, removeIn, set, setIn, update, updateIn };\n","\"use strict\"\n\nconst minimatch = require(\"minimatch\")\nconst splitRe = /([!?+*@]\\([^)]+\\)|\\*{1,2}|\\?)/\nconst endWithNegRe = /!\\([^)]+\\)$/\n\nclass Capture {\n\tconstructor(pattern, options) {\n\t\tthis.pattern = pattern\n\t\tthis.options = options || {}\n\t}\n\n\tmakeRe() {\n\t\tif (!this.regexp && this.regexp !== false) {\n\t\t\tthis.regexp = makeRe(this.pattern, this.options)\n\t\t}\n\t\treturn this.regexp\n\t}\n\n\tcapture(path) {\n\t\tlet result = false\n\t\tlet match = path.match(this.makeRe())\n\t\tif (match) {\n\t\t\tmatch = match.filter(isDef)\n\t\t\tresult = match[1] || match[0]\n\t\t\tif (!this.options.notrim && result !== \"/\") {\n\t\t\t\tresult = result.replace(/^\\/|\\/$/g, \"\")\n\t\t\t}\n\t\t}\n\t\treturn result\n\t}\n}\n\nfunction split(pattern) {\n\tconst parts = pattern.split(splitRe)\n\tif (parts.length === 1) {\n\t\treturn [\"\", parts[0], \"\"]\n\t}\n\treturn [parts[0], parts.slice(1, -1).join(\"\"), parts[parts.length - 1]]\n}\n\nconst nonegate = {nonegate: true}\n\nfunction _makeRe(pattern, options) {\n\tconst flags = options && options.nocase ? \"i\" : \"\"\n\tconst subpatterns = minimatch.braceExpand(pattern, options)\n\tconst expressions = subpatterns.map(subpattern => {\n\t\tconst parts = split(subpattern)\n\t\tconst left = parts[0]\n\t\tconst middle = parts[1]\n\t\tconst right = parts[2]\n\t\tconst opts = left ? Object.assign({}, options, nonegate) : options\n\t\tconst re = minimatch.makeRe(middle, opts)\n\t\tlet capture = re.source.slice(4, -2)\n\t\tif (endWithNegRe.test(middle)) {\n\t\t\tcapture = capture.replace(/\\)\\$\\)/g,\n\t\t\t\t\"(?\" + (right.startsWith(\"/\") ? \"=\" : \"!\") + \"/)))\"\n\t\t\t)\n\t\t}\n\t\treturn regExpEscape(left) + \"(\" + capture + \")\" + regExpEscape(right)\n\t})\n\treturn new RegExp(\"^(?:\" + expressions.join(\"|\") + \")$\", flags)\n}\n\nfunction makeRe(pattern, options) {\n\ttry {\n\t\treturn _makeRe(pattern, options)\n\t} catch (e) {\n\t\treturn false\n\t}\n}\n\nfunction match(list, pattern, options) {\n\tconst cap = new Capture(pattern, options)\n\tconst result = []\n\tfor (let i = 0; i < list.length; i++) {\n\t\tconst path = list[i]\n\t\tconst match = cap.capture(path)\n\t\tif (match) {\n\t\t\tresult.push([path, match])\n\t\t}\n\t}\n\treturn result\n}\n\nmodule.exports = function(path, pattern, options) {\n\treturn new Capture(pattern, options).capture(path)\n}\n\nObject.assign(module.exports, {\n\tCapture,\n\tsplit,\n\tmakeRe,\n\tmatch,\n})\n\nfunction isDef(v) {\n\treturn v !== undefined\n}\n\n// private function copied from https://github.com/isaacs/minimatch\nfunction regExpEscape(s) {\n\treturn s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\")\n}\n","module.exports = minimatch\nminimatch.Minimatch = Minimatch\n\nvar path = { sep: '/' }\ntry {\n  path = require('path')\n} catch (er) {}\n\nvar GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}\nvar expand = require('brace-expansion')\n\nvar plTypes = {\n  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},\n  '?': { open: '(?:', close: ')?' },\n  '+': { open: '(?:', close: ')+' },\n  '*': { open: '(?:', close: ')*' },\n  '@': { open: '(?:', close: ')' }\n}\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nvar qmark = '[^/]'\n\n// * => any number of characters\nvar star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nvar twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nvar twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?'\n\n// characters that need to be escaped in RegExp.\nvar reSpecials = charSet('().*{}+?[]^$\\\\!')\n\n// \"abc\" -> { a:true, b:true, c:true }\nfunction charSet (s) {\n  return s.split('').reduce(function (set, c) {\n    set[c] = true\n    return set\n  }, {})\n}\n\n// normalizes slashes.\nvar slashSplit = /\\/+/\n\nminimatch.filter = filter\nfunction filter (pattern, options) {\n  options = options || {}\n  return function (p, i, list) {\n    return minimatch(p, pattern, options)\n  }\n}\n\nfunction ext (a, b) {\n  a = a || {}\n  b = b || {}\n  var t = {}\n  Object.keys(b).forEach(function (k) {\n    t[k] = b[k]\n  })\n  Object.keys(a).forEach(function (k) {\n    t[k] = a[k]\n  })\n  return t\n}\n\nminimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return minimatch\n\n  var orig = minimatch\n\n  var m = function minimatch (p, pattern, options) {\n    return orig.minimatch(p, pattern, ext(def, options))\n  }\n\n  m.Minimatch = function Minimatch (pattern, options) {\n    return new orig.Minimatch(pattern, ext(def, options))\n  }\n\n  return m\n}\n\nMinimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return Minimatch\n  return minimatch.defaults(def).Minimatch\n}\n\nfunction minimatch (p, pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  // \"\" only matches \"\"\n  if (pattern.trim() === '') return p === ''\n\n  return new Minimatch(pattern, options).match(p)\n}\n\nfunction Minimatch (pattern, options) {\n  if (!(this instanceof Minimatch)) {\n    return new Minimatch(pattern, options)\n  }\n\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n  pattern = pattern.trim()\n\n  // windows support: need to use /, not \\\n  if (path.sep !== '/') {\n    pattern = pattern.split(path.sep).join('/')\n  }\n\n  this.options = options\n  this.set = []\n  this.pattern = pattern\n  this.regexp = null\n  this.negate = false\n  this.comment = false\n  this.empty = false\n\n  // make the set of regexps etc.\n  this.make()\n}\n\nMinimatch.prototype.debug = function () {}\n\nMinimatch.prototype.make = make\nfunction make () {\n  // don't do it more than once.\n  if (this._made) return\n\n  var pattern = this.pattern\n  var options = this.options\n\n  // empty patterns and comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    this.comment = true\n    return\n  }\n  if (!pattern) {\n    this.empty = true\n    return\n  }\n\n  // step 1: figure out negation, etc.\n  this.parseNegate()\n\n  // step 2: expand braces\n  var set = this.globSet = this.braceExpand()\n\n  if (options.debug) this.debug = console.error\n\n  this.debug(this.pattern, set)\n\n  // step 3: now we have a set, so turn each one into a series of path-portion\n  // matching patterns.\n  // These will be regexps, except in the case of \"**\", which is\n  // set to the GLOBSTAR object for globstar behavior,\n  // and will not contain any / characters\n  set = this.globParts = set.map(function (s) {\n    return s.split(slashSplit)\n  })\n\n  this.debug(this.pattern, set)\n\n  // glob --> regexps\n  set = set.map(function (s, si, set) {\n    return s.map(this.parse, this)\n  }, this)\n\n  this.debug(this.pattern, set)\n\n  // filter out everything that didn't compile properly.\n  set = set.filter(function (s) {\n    return s.indexOf(false) === -1\n  })\n\n  this.debug(this.pattern, set)\n\n  this.set = set\n}\n\nMinimatch.prototype.parseNegate = parseNegate\nfunction parseNegate () {\n  var pattern = this.pattern\n  var negate = false\n  var options = this.options\n  var negateOffset = 0\n\n  if (options.nonegate) return\n\n  for (var i = 0, l = pattern.length\n    ; i < l && pattern.charAt(i) === '!'\n    ; i++) {\n    negate = !negate\n    negateOffset++\n  }\n\n  if (negateOffset) this.pattern = pattern.substr(negateOffset)\n  this.negate = negate\n}\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = function (pattern, options) {\n  return braceExpand(pattern, options)\n}\n\nMinimatch.prototype.braceExpand = braceExpand\n\nfunction braceExpand (pattern, options) {\n  if (!options) {\n    if (this instanceof Minimatch) {\n      options = this.options\n    } else {\n      options = {}\n    }\n  }\n\n  pattern = typeof pattern === 'undefined'\n    ? this.pattern : pattern\n\n  if (typeof pattern === 'undefined') {\n    throw new TypeError('undefined pattern')\n  }\n\n  if (options.nobrace ||\n    !pattern.match(/\\{.*\\}/)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nMinimatch.prototype.parse = parse\nvar SUBPARSE = {}\nfunction parse (pattern, isSub) {\n  if (pattern.length > 1024 * 64) {\n    throw new TypeError('pattern is too long')\n  }\n\n  var options = this.options\n\n  // shortcuts\n  if (!options.noglobstar && pattern === '**') return GLOBSTAR\n  if (pattern === '') return ''\n\n  var re = ''\n  var hasMagic = !!options.nocase\n  var escaping = false\n  // ? => one single character\n  var patternListStack = []\n  var negativeLists = []\n  var stateChar\n  var inClass = false\n  var reClassStart = -1\n  var classStart = -1\n  // . and .. never match anything that doesn't start with .,\n  // even when options.dot is set.\n  var patternStart = pattern.charAt(0) === '.' ? '' // anything\n  // not (start or / followed by . or .. followed by / or end)\n  : options.dot ? '(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))'\n  : '(?!\\\\.)'\n  var self = this\n\n  function clearStateChar () {\n    if (stateChar) {\n      // we had some state-tracking character\n      // that wasn't consumed by this pass.\n      switch (stateChar) {\n        case '*':\n          re += star\n          hasMagic = true\n        break\n        case '?':\n          re += qmark\n          hasMagic = true\n        break\n        default:\n          re += '\\\\' + stateChar\n        break\n      }\n      self.debug('clearStateChar %j %j', stateChar, re)\n      stateChar = false\n    }\n  }\n\n  for (var i = 0, len = pattern.length, c\n    ; (i < len) && (c = pattern.charAt(i))\n    ; i++) {\n    this.debug('%s\\t%s %s %j', pattern, i, re, c)\n\n    // skip over any that are escaped.\n    if (escaping && reSpecials[c]) {\n      re += '\\\\' + c\n      escaping = false\n      continue\n    }\n\n    switch (c) {\n      case '/':\n        // completely not allowed, even escaped.\n        // Should already be path-split by now.\n        return false\n\n      case '\\\\':\n        clearStateChar()\n        escaping = true\n      continue\n\n      // the various stateChar values\n      // for the \"extglob\" stuff.\n      case '?':\n      case '*':\n      case '+':\n      case '@':\n      case '!':\n        this.debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c)\n\n        // all of those are literals inside a class, except that\n        // the glob [!a] means [^a] in regexp\n        if (inClass) {\n          this.debug('  in class')\n          if (c === '!' && i === classStart + 1) c = '^'\n          re += c\n          continue\n        }\n\n        // if we already have a stateChar, then it means\n        // that there was something like ** or +? in there.\n        // Handle the stateChar, then proceed with this one.\n        self.debug('call clearStateChar %j', stateChar)\n        clearStateChar()\n        stateChar = c\n        // if extglob is disabled, then +(asdf|foo) isn't a thing.\n        // just clear the statechar *now*, rather than even diving into\n        // the patternList stuff.\n        if (options.noext) clearStateChar()\n      continue\n\n      case '(':\n        if (inClass) {\n          re += '('\n          continue\n        }\n\n        if (!stateChar) {\n          re += '\\\\('\n          continue\n        }\n\n        patternListStack.push({\n          type: stateChar,\n          start: i - 1,\n          reStart: re.length,\n          open: plTypes[stateChar].open,\n          close: plTypes[stateChar].close\n        })\n        // negation is (?:(?!js)[^/]*)\n        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'\n        this.debug('plType %j %j', stateChar, re)\n        stateChar = false\n      continue\n\n      case ')':\n        if (inClass || !patternListStack.length) {\n          re += '\\\\)'\n          continue\n        }\n\n        clearStateChar()\n        hasMagic = true\n        var pl = patternListStack.pop()\n        // negation is (?:(?!js)[^/]*)\n        // The others are (?:<pattern>)<type>\n        re += pl.close\n        if (pl.type === '!') {\n          negativeLists.push(pl)\n        }\n        pl.reEnd = re.length\n      continue\n\n      case '|':\n        if (inClass || !patternListStack.length || escaping) {\n          re += '\\\\|'\n          escaping = false\n          continue\n        }\n\n        clearStateChar()\n        re += '|'\n      continue\n\n      // these are mostly the same in regexp and glob\n      case '[':\n        // swallow any state-tracking char before the [\n        clearStateChar()\n\n        if (inClass) {\n          re += '\\\\' + c\n          continue\n        }\n\n        inClass = true\n        classStart = i\n        reClassStart = re.length\n        re += c\n      continue\n\n      case ']':\n        //  a right bracket shall lose its special\n        //  meaning and represent itself in\n        //  a bracket expression if it occurs\n        //  first in the list.  -- POSIX.2 2.8.3.2\n        if (i === classStart + 1 || !inClass) {\n          re += '\\\\' + c\n          escaping = false\n          continue\n        }\n\n        // handle the case where we left a class open.\n        // \"[z-a]\" is valid, equivalent to \"\\[z-a\\]\"\n        if (inClass) {\n          // split where the last [ was, make sure we don't have\n          // an invalid re. if so, re-walk the contents of the\n          // would-be class to re-translate any characters that\n          // were passed through as-is\n          // TODO: It would probably be faster to determine this\n          // without a try/catch and a new RegExp, but it's tricky\n          // to do safely.  For now, this is safe and works.\n          var cs = pattern.substring(classStart + 1, i)\n          try {\n            RegExp('[' + cs + ']')\n          } catch (er) {\n            // not a valid class!\n            var sp = this.parse(cs, SUBPARSE)\n            re = re.substr(0, reClassStart) + '\\\\[' + sp[0] + '\\\\]'\n            hasMagic = hasMagic || sp[1]\n            inClass = false\n            continue\n          }\n        }\n\n        // finish up the class.\n        hasMagic = true\n        inClass = false\n        re += c\n      continue\n\n      default:\n        // swallow any state char that wasn't consumed\n        clearStateChar()\n\n        if (escaping) {\n          // no need\n          escaping = false\n        } else if (reSpecials[c]\n          && !(c === '^' && inClass)) {\n          re += '\\\\'\n        }\n\n        re += c\n\n    } // switch\n  } // for\n\n  // handle the case where we left a class open.\n  // \"[abc\" is valid, equivalent to \"\\[abc\"\n  if (inClass) {\n    // split where the last [ was, and escape it\n    // this is a huge pita.  We now have to re-walk\n    // the contents of the would-be class to re-translate\n    // any characters that were passed through as-is\n    cs = pattern.substr(classStart + 1)\n    sp = this.parse(cs, SUBPARSE)\n    re = re.substr(0, reClassStart) + '\\\\[' + sp[0]\n    hasMagic = hasMagic || sp[1]\n  }\n\n  // handle the case where we had a +( thing at the *end*\n  // of the pattern.\n  // each pattern list stack adds 3 chars, and we need to go through\n  // and escape any | chars that were passed through as-is for the regexp.\n  // Go through and escape them, taking care not to double-escape any\n  // | chars that were already escaped.\n  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n    var tail = re.slice(pl.reStart + pl.open.length)\n    this.debug('setting tail', re, pl)\n    // maybe some even number of \\, then maybe 1 \\, followed by a |\n    tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, function (_, $1, $2) {\n      if (!$2) {\n        // the | isn't already escaped, so escape it.\n        $2 = '\\\\'\n      }\n\n      // need to escape all those slashes *again*, without escaping the\n      // one that we need for escaping the | character.  As it works out,\n      // escaping an even number of slashes can be done by simply repeating\n      // it exactly after itself.  That's why this trick works.\n      //\n      // I am sorry that you have to see this.\n      return $1 + $1 + $2 + '|'\n    })\n\n    this.debug('tail=%j\\n   %s', tail, tail, pl, re)\n    var t = pl.type === '*' ? star\n      : pl.type === '?' ? qmark\n      : '\\\\' + pl.type\n\n    hasMagic = true\n    re = re.slice(0, pl.reStart) + t + '\\\\(' + tail\n  }\n\n  // handle trailing things that only matter at the very end.\n  clearStateChar()\n  if (escaping) {\n    // trailing \\\\\n    re += '\\\\\\\\'\n  }\n\n  // only need to apply the nodot start if the re starts with\n  // something that could conceivably capture a dot\n  var addPatternStart = false\n  switch (re.charAt(0)) {\n    case '.':\n    case '[':\n    case '(': addPatternStart = true\n  }\n\n  // Hack to work around lack of negative lookbehind in JS\n  // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n  // like 'a.xyz.yz' doesn't match.  So, the first negative\n  // lookahead, has to look ALL the way ahead, to the end of\n  // the pattern.\n  for (var n = negativeLists.length - 1; n > -1; n--) {\n    var nl = negativeLists[n]\n\n    var nlBefore = re.slice(0, nl.reStart)\n    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)\n    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)\n    var nlAfter = re.slice(nl.reEnd)\n\n    nlLast += nlAfter\n\n    // Handle nested stuff like *(*.js|!(*.json)), where open parens\n    // mean that we should *not* include the ) in the bit that is considered\n    // \"after\" the negated section.\n    var openParensBefore = nlBefore.split('(').length - 1\n    var cleanAfter = nlAfter\n    for (i = 0; i < openParensBefore; i++) {\n      cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '')\n    }\n    nlAfter = cleanAfter\n\n    var dollar = ''\n    if (nlAfter === '' && isSub !== SUBPARSE) {\n      dollar = '$'\n    }\n    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast\n    re = newRe\n  }\n\n  // if the re is not \"\" at this point, then we need to make sure\n  // it doesn't match against an empty path part.\n  // Otherwise a/* will match a/, which it should not.\n  if (re !== '' && hasMagic) {\n    re = '(?=.)' + re\n  }\n\n  if (addPatternStart) {\n    re = patternStart + re\n  }\n\n  // parsing just a piece of a larger pattern.\n  if (isSub === SUBPARSE) {\n    return [re, hasMagic]\n  }\n\n  // skip the regexp for non-magical patterns\n  // unescape anything in it, though, so that it'll be\n  // an exact match against a file etc.\n  if (!hasMagic) {\n    return globUnescape(pattern)\n  }\n\n  var flags = options.nocase ? 'i' : ''\n  try {\n    var regExp = new RegExp('^' + re + '$', flags)\n  } catch (er) {\n    // If it was an invalid regular expression, then it can't match\n    // anything.  This trick looks for a character after the end of\n    // the string, which is of course impossible, except in multi-line\n    // mode, but it's not a /m regex.\n    return new RegExp('$.')\n  }\n\n  regExp._glob = pattern\n  regExp._src = re\n\n  return regExp\n}\n\nminimatch.makeRe = function (pattern, options) {\n  return new Minimatch(pattern, options || {}).makeRe()\n}\n\nMinimatch.prototype.makeRe = makeRe\nfunction makeRe () {\n  if (this.regexp || this.regexp === false) return this.regexp\n\n  // at this point, this.set is a 2d array of partial\n  // pattern strings, or \"**\".\n  //\n  // It's better to use .match().  This function shouldn't\n  // be used, really, but it's pretty convenient sometimes,\n  // when you just want to work with a regex.\n  var set = this.set\n\n  if (!set.length) {\n    this.regexp = false\n    return this.regexp\n  }\n  var options = this.options\n\n  var twoStar = options.noglobstar ? star\n    : options.dot ? twoStarDot\n    : twoStarNoDot\n  var flags = options.nocase ? 'i' : ''\n\n  var re = set.map(function (pattern) {\n    return pattern.map(function (p) {\n      return (p === GLOBSTAR) ? twoStar\n      : (typeof p === 'string') ? regExpEscape(p)\n      : p._src\n    }).join('\\\\\\/')\n  }).join('|')\n\n  // must match entire pattern\n  // ending in a * or ** will make it less strict.\n  re = '^(?:' + re + ')$'\n\n  // can match anything, as long as it's not this.\n  if (this.negate) re = '^(?!' + re + ').*$'\n\n  try {\n    this.regexp = new RegExp(re, flags)\n  } catch (ex) {\n    this.regexp = false\n  }\n  return this.regexp\n}\n\nminimatch.match = function (list, pattern, options) {\n  options = options || {}\n  var mm = new Minimatch(pattern, options)\n  list = list.filter(function (f) {\n    return mm.match(f)\n  })\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\n\nMinimatch.prototype.match = match\nfunction match (f, partial) {\n  this.debug('match', f, this.pattern)\n  // short-circuit in the case of busted things.\n  // comments, etc.\n  if (this.comment) return false\n  if (this.empty) return f === ''\n\n  if (f === '/' && partial) return true\n\n  var options = this.options\n\n  // windows: need to use /, not \\\n  if (path.sep !== '/') {\n    f = f.split(path.sep).join('/')\n  }\n\n  // treat the test path as a set of pathparts.\n  f = f.split(slashSplit)\n  this.debug(this.pattern, 'split', f)\n\n  // just ONE of the pattern sets in this.set needs to match\n  // in order for it to be valid.  If negating, then just one\n  // match means that we have failed.\n  // Either way, return on the first hit.\n\n  var set = this.set\n  this.debug(this.pattern, 'set', set)\n\n  // Find the basename of the path by looking for the last non-empty segment\n  var filename\n  var i\n  for (i = f.length - 1; i >= 0; i--) {\n    filename = f[i]\n    if (filename) break\n  }\n\n  for (i = 0; i < set.length; i++) {\n    var pattern = set[i]\n    var file = f\n    if (options.matchBase && pattern.length === 1) {\n      file = [filename]\n    }\n    var hit = this.matchOne(file, pattern, partial)\n    if (hit) {\n      if (options.flipNegate) return true\n      return !this.negate\n    }\n  }\n\n  // didn't get any hits.  this is success if it's a negative\n  // pattern, failure otherwise.\n  if (options.flipNegate) return false\n  return this.negate\n}\n\n// set partial to true to test if, for example,\n// \"/a/b\" matches the start of \"/*/b/*/d\"\n// Partial means, if you run out of file before you run\n// out of pattern, then that's fine, as long as all\n// the parts match.\nMinimatch.prototype.matchOne = function (file, pattern, partial) {\n  var options = this.options\n\n  this.debug('matchOne',\n    { 'this': this, file: file, pattern: pattern })\n\n  this.debug('matchOne', file.length, pattern.length)\n\n  for (var fi = 0,\n      pi = 0,\n      fl = file.length,\n      pl = pattern.length\n      ; (fi < fl) && (pi < pl)\n      ; fi++, pi++) {\n    this.debug('matchOne loop')\n    var p = pattern[pi]\n    var f = file[fi]\n\n    this.debug(pattern, p, f)\n\n    // should be impossible.\n    // some invalid regexp stuff in the set.\n    if (p === false) return false\n\n    if (p === GLOBSTAR) {\n      this.debug('GLOBSTAR', [pattern, p, f])\n\n      // \"**\"\n      // a/**/b/**/c would match the following:\n      // a/b/x/y/z/c\n      // a/x/y/z/b/c\n      // a/b/x/b/x/c\n      // a/b/c\n      // To do this, take the rest of the pattern after\n      // the **, and see if it would match the file remainder.\n      // If so, return success.\n      // If not, the ** \"swallows\" a segment, and try again.\n      // This is recursively awful.\n      //\n      // a/**/b/**/c matching a/b/x/y/z/c\n      // - a matches a\n      // - doublestar\n      //   - matchOne(b/x/y/z/c, b/**/c)\n      //     - b matches b\n      //     - doublestar\n      //       - matchOne(x/y/z/c, c) -> no\n      //       - matchOne(y/z/c, c) -> no\n      //       - matchOne(z/c, c) -> no\n      //       - matchOne(c, c) yes, hit\n      var fr = fi\n      var pr = pi + 1\n      if (pr === pl) {\n        this.debug('** at the end')\n        // a ** at the end will just swallow the rest.\n        // We have found a match.\n        // however, it will not swallow /.x, unless\n        // options.dot is set.\n        // . and .. are *never* matched by **, for explosively\n        // exponential reasons.\n        for (; fi < fl; fi++) {\n          if (file[fi] === '.' || file[fi] === '..' ||\n            (!options.dot && file[fi].charAt(0) === '.')) return false\n        }\n        return true\n      }\n\n      // ok, let's see if we can swallow whatever we can.\n      while (fr < fl) {\n        var swallowee = file[fr]\n\n        this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n        // XXX remove this slice.  Just pass the start index.\n        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n          this.debug('globstar found match!', fr, fl, swallowee)\n          // found a match.\n          return true\n        } else {\n          // can't swallow \".\" or \"..\" ever.\n          // can only swallow \".foo\" when explicitly asked.\n          if (swallowee === '.' || swallowee === '..' ||\n            (!options.dot && swallowee.charAt(0) === '.')) {\n            this.debug('dot detected!', file, fr, pattern, pr)\n            break\n          }\n\n          // ** swallows a segment, and continue.\n          this.debug('globstar swallow a segment, and continue')\n          fr++\n        }\n      }\n\n      // no match was found.\n      // However, in partial mode, we can't say this is necessarily over.\n      // If there's more *pattern* left, then\n      if (partial) {\n        // ran out of file\n        this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n        if (fr === fl) return true\n      }\n      return false\n    }\n\n    // something other than **\n    // non-magic patterns just have to match exactly\n    // patterns with magic have been turned into regexps.\n    var hit\n    if (typeof p === 'string') {\n      if (options.nocase) {\n        hit = f.toLowerCase() === p.toLowerCase()\n      } else {\n        hit = f === p\n      }\n      this.debug('string match', p, f, hit)\n    } else {\n      hit = f.match(p)\n      this.debug('pattern match', p, f, hit)\n    }\n\n    if (!hit) return false\n  }\n\n  // Note: ending in / means that we'll get a final \"\"\n  // at the end of the pattern.  This can only match a\n  // corresponding \"\" at the end of the file.\n  // If the file ends in /, then it can only match a\n  // a pattern that ends in /, unless the pattern just\n  // doesn't have any more for it. But, a/b/ should *not*\n  // match \"a/b/*\", even though \"\" matches against the\n  // [^/]*? pattern, except in partial mode, where it might\n  // simply not be reached yet.\n  // However, a/b/ should still satisfy a/*\n\n  // now either we fell off the end of the pattern, or we're done.\n  if (fi === fl && pi === pl) {\n    // ran out of pattern and filename at the same time.\n    // an exact hit!\n    return true\n  } else if (fi === fl) {\n    // ran out of file, but still had pattern left.\n    // this is ok if we're doing the match as part of\n    // a glob fs traversal.\n    return partial\n  } else if (pi === pl) {\n    // ran out of pattern, still have file left.\n    // this is only acceptable if we're on the very last\n    // empty segment of a file with a trailing slash.\n    // a/* should match a/b/\n    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')\n    return emptyFileEnd\n  }\n\n  // should be unreachable.\n  throw new Error('wtf?')\n}\n\n// replace stuff like \\* with *\nfunction globUnescape (s) {\n  return s.replace(/\\\\(.)/g, '$1')\n}\n\nfunction regExpEscape (s) {\n  return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n}\n","// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,\n// backported and transplited with Babel, with backwards-compat fixes\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  if (path.length === 0) return '.';\n  var code = path.charCodeAt(0);\n  var hasRoot = code === 47 /*/*/;\n  var end = -1;\n  var matchedSlash = true;\n  for (var i = path.length - 1; i >= 1; --i) {\n    code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n      // We saw the first non-path separator\n      matchedSlash = false;\n    }\n  }\n\n  if (end === -1) return hasRoot ? '/' : '.';\n  if (hasRoot && end === 1) {\n    // return '//';\n    // Backwards-compat fix:\n    return '/';\n  }\n  return path.slice(0, end);\n};\n\nfunction basename(path) {\n  if (typeof path !== 'string') path = path + '';\n\n  var start = 0;\n  var end = -1;\n  var matchedSlash = true;\n  var i;\n\n  for (i = path.length - 1; i >= 0; --i) {\n    if (path.charCodeAt(i) === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // path component\n      matchedSlash = false;\n      end = i + 1;\n    }\n  }\n\n  if (end === -1) return '';\n  return path.slice(start, end);\n}\n\n// Uses a mixed approach for backwards-compatibility, as ext behavior changed\n// in new Node.js versions, so only basename() above is backported here\nexports.basename = function (path, ext) {\n  var f = basename(path);\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\nexports.extname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  var startDot = -1;\n  var startPart = 0;\n  var end = -1;\n  var matchedSlash = true;\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n  var preDotState = 0;\n  for (var i = path.length - 1; i >= 0; --i) {\n    var code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n    if (code === 46 /*.*/) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n    } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n\n  if (startDot === -1 || end === -1 ||\n      // We saw a non-dot character immediately before the dot\n      preDotState === 0 ||\n      // The (right-most) trimmed path component is exactly '..'\n      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n    return '';\n  }\n  return path.slice(startDot, end);\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","var map = {\n\t\"./\": \"./src/commands/index.js\",\n\t\"./cat\": \"./src/commands/cat.js\",\n\t\"./cat.js\": \"./src/commands/cat.js\",\n\t\"./cd\": \"./src/commands/cd.js\",\n\t\"./cd.js\": \"./src/commands/cd.js\",\n\t\"./clear\": \"./src/commands/clear.js\",\n\t\"./clear.js\": \"./src/commands/clear.js\",\n\t\"./cp\": \"./src/commands/cp.js\",\n\t\"./cp.js\": \"./src/commands/cp.js\",\n\t\"./echo\": \"./src/commands/echo.js\",\n\t\"./echo.js\": \"./src/commands/echo.js\",\n\t\"./head\": \"./src/commands/head.js\",\n\t\"./head.js\": \"./src/commands/head.js\",\n\t\"./history\": \"./src/commands/history.js\",\n\t\"./history.js\": \"./src/commands/history.js\",\n\t\"./index\": \"./src/commands/index.js\",\n\t\"./index.js\": \"./src/commands/index.js\",\n\t\"./ls\": \"./src/commands/ls.js\",\n\t\"./ls.js\": \"./src/commands/ls.js\",\n\t\"./mkdir\": \"./src/commands/mkdir.js\",\n\t\"./mkdir.js\": \"./src/commands/mkdir.js\",\n\t\"./printenv\": \"./src/commands/printenv.js\",\n\t\"./printenv.js\": \"./src/commands/printenv.js\",\n\t\"./pwd\": \"./src/commands/pwd.js\",\n\t\"./pwd.js\": \"./src/commands/pwd.js\",\n\t\"./rm\": \"./src/commands/rm.js\",\n\t\"./rm.js\": \"./src/commands/rm.js\",\n\t\"./rmdir\": \"./src/commands/rmdir.js\",\n\t\"./rmdir.js\": \"./src/commands/rmdir.js\",\n\t\"./tail\": \"./src/commands/tail.js\",\n\t\"./tail.js\": \"./src/commands/tail.js\",\n\t\"./touch\": \"./src/commands/touch.js\",\n\t\"./touch.js\": \"./src/commands/touch.js\",\n\t\"./util/_head_tail_util\": \"./src/commands/util/_head_tail_util.js\",\n\t\"./util/_head_tail_util.js\": \"./src/commands/util/_head_tail_util.js\",\n\t\"./whoami\": \"./src/commands/whoami.js\",\n\t\"./whoami.js\": \"./src/commands/whoami.js\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./src/commands sync recursive ^\\\\.\\\\/.*$\";","/**\n * Combines one or more files to display in the terminal output\n * Usage: cat file1.txt file2.txt\n */\nimport parseOptions from 'parser/option-parser';\nimport * as FileOp from 'fs/operations-with-permissions/file-operations';\nimport * as OutputFactory from 'emulator-output/output-factory';\nimport { resolvePath } from 'emulator-state/util';\n\nconst fileToTextOutput = (fs, filePath) => {\n  const {err, file} = FileOp.readFile(fs, filePath);\n\n  if (err) {\n    return OutputFactory.makeErrorOutput(err);\n  };\n\n  return OutputFactory.makeTextOutput(file.get('content'));\n};\n\nexport const optDef = {};\n\nexport default (state, commandOptions) => {\n  const {argv} = parseOptions(commandOptions, optDef);\n\n  if (argv.length === 0) {\n    return {};\n  }\n\n  const filePaths = argv.map(pathArg => resolvePath(state, pathArg));\n\n  return {\n    outputs: filePaths.map(path => fileToTextOutput(state.getFileSystem(), path))\n  };\n};\n","/**\n * Changes the current working directory to another directory\n * Usage: cd /newDirectory\n */\nimport parseOptions from 'parser/option-parser';\nimport * as DirectoryOp from 'fs/operations-with-permissions/directory-operations';\nimport * as EnvVariableUtil from 'emulator-state/environment-variables';\nimport * as OutputFactory from 'emulator-output/output-factory';\nimport { makeError, fsErrorType } from 'fs/fs-error';\nimport { resolvePath } from 'emulator-state/util';\n\nconst updateStateCwd = (state, newCwdPath) => {\n  return EnvVariableUtil.setEnvironmentVariable(\n    state.getEnvVariables(), 'cwd', newCwdPath\n  );\n};\n\nexport const optDef = {};\n\nexport default (state, commandOptions) => {\n  const {argv} = parseOptions(commandOptions, optDef);\n  const newCwdPath = argv[0] ? resolvePath(state, argv[0]) : '/';\n\n  if (!DirectoryOp.hasDirectory(state.getFileSystem(), newCwdPath)) {\n    const newCwdPathDoesNotExistErr = makeError(fsErrorType.NO_SUCH_DIRECTORY);\n\n    return {\n      output: OutputFactory.makeErrorOutput(newCwdPathDoesNotExistErr)\n    };\n  }\n\n  return {\n    state: state.setEnvVariables(\n      updateStateCwd(state, newCwdPath)\n    )\n  };\n};\n","/**\n * Removes all terminal output\n * Usage: clear\n */\nimport { create as createOutputs } from 'emulator-state/outputs';\n\nexport const optDef = {};\n\nexport default (state, commandOptions) => {\n  return {\n    state: state.setOutputs(createOutputs())\n  };\n};\n","/**\n * Copies a file/directory to another file/directory\n * Usage: cp file new-file\n */\nimport parseOptions from 'parser/option-parser';\nimport * as FileOp from 'fs/operations-with-permissions/file-operations';\nimport * as DirectoryOp from 'fs/operations-with-permissions/directory-operations';\nimport * as PathUtil from 'fs/util/path-util';\nimport * as OutputFactory from 'emulator-output/output-factory';\nimport * as FileUtil from 'fs/util/file-util';\nimport { makeError, fsErrorType } from 'fs/fs-error';\nimport { resolvePath } from 'emulator-state/util';\n\n/**\n * Copy from a source file into a directory or another file.\n *\n * A trailing slash / can be used in the destination to explicitly state the\n * destination is a directory and not a file.\n * @param  {Map}     state              emulator state\n * @param  {string}  srcPath            source file path\n * @param  {string}  destPath           destination file or destination directory path\n * @param  {Boolean} isTrailingPathDest true if the destPath ended in a /\n * @return {object}                     cp command return object\n */\nconst copySourceFile = (state, srcPath, destPath, isTrailingPathDest) => {\n  const fs = state.getFileSystem();\n\n  if (isTrailingPathDest && !DirectoryOp.hasDirectory(fs, destPath)) {\n    const dirAtTrailingPathNonExistentErr = makeError(fsErrorType.NO_SUCH_DIRECTORY);\n\n    return {\n      output: OutputFactory.makeErrorOutput(dirAtTrailingPathNonExistentErr)\n    };\n  }\n\n  const {fs: copiedFS, err} = FileOp.copyFile(fs, srcPath, destPath);\n\n  if (err) {\n    return {\n      output: OutputFactory.makeErrorOutput(err)\n    };\n  }\n\n  return {\n    state: state.setFileSystem(copiedFS)\n  };\n};\n\n/**\n * Copies a directory into another directory\n *\n * When the destination path exists, cp copies the source FOLDER into the\n * destination.\n *\n * When the destination DOES NOT exist, cp copies the source FILES into the\n * destination.\n * @param  {Map}    state      emulator state\n * @param  {string} srcPath    source directory path (copy from)\n * @param  {string} destPath   destination directory path (copy to)\n * @return {object}            cp command return object\n */\nconst copySourceDirectory = (state, srcPath, destPath) => {\n  if (DirectoryOp.hasDirectory(state.getFileSystem(), destPath)) {\n    const lastPathComponent = PathUtil.getLastPathPart(srcPath);\n\n    // Remap dest to copy source FOLDER, as destination path exists\n    if (lastPathComponent !== '/') {\n      destPath = `${destPath}/${lastPathComponent}`;\n    }\n  }\n\n  // Make directory to copy into, if it doesn't already exist\n  if (!DirectoryOp.hasDirectory(state.getFileSystem(), destPath)) {\n    const emptyDir = FileUtil.makeDirectory();\n    const {fs, err} = DirectoryOp.addDirectory(state.getFileSystem(), destPath, emptyDir, false);\n\n    state = state.setFileSystem(fs);\n\n    if (err) {\n      return {\n        output: OutputFactory.makeErrorOutput(err)\n      };\n    }\n  }\n\n  const {fs, err} = DirectoryOp.copyDirectory(state.getFileSystem(), srcPath, destPath);\n\n  if (err) {\n    return {\n      output: OutputFactory.makeErrorOutput(err)\n    };\n  }\n\n  return {\n    state: state.setFileSystem(fs)\n  };\n};\n\nexport const optDef = {\n  '-r, --recursive': '' // required to copy directories\n};\n\nexport default (state, commandOptions) => {\n  const {argv, options} = parseOptions(commandOptions, optDef);\n\n  if (argv.length < 2) {\n    return {};\n  }\n\n  const srcPath = resolvePath(state, argv[0]);\n  const destPath = resolvePath(state, argv[1]);\n  const isTrailingDestPath = PathUtil.isTrailingPath(argv[1]);\n\n  if (srcPath === destPath) {\n    return {\n      output: OutputFactory.makeTextOutput('Source and destination are the same (not copied).')\n    };\n  }\n\n  if (options.recursive) {\n    return copySourceDirectory(state, srcPath, destPath);\n  }\n\n  return copySourceFile(state, srcPath, destPath, isTrailingDestPath);\n};\n","/**\n * Prints arguments to text output\n * Usage: echo 'hello world'\n */\nimport * as OutputFactory from 'emulator-output/output-factory';\nimport { getEnvironmentVariable } from 'emulator-state/environment-variables';\n\nconst VARIABLE_GROUP_REGEX = /\\$(\\w+)/g;\nconst DOUBLE_SPACE_REGEX = /\\s\\s+/g;\n\nconst substituteEnvVariables = (environmentVariables, inputStr) => {\n  return inputStr.replace(VARIABLE_GROUP_REGEX, (match, varName) =>\n    getEnvironmentVariable(environmentVariables, varName) || ''\n  );\n};\n\nexport const optDef = {};\n\nexport default (state, commandOptions) => {\n  const input = commandOptions.join(' ');\n  const outputStr = substituteEnvVariables(\n    state.getEnvVariables(), input\n  );\n  const cleanStr = outputStr.trim().replace(DOUBLE_SPACE_REGEX, ' ');\n\n  return {\n    output: OutputFactory.makeTextOutput(cleanStr)\n  };\n};\n","/**\n * Prints the first n lines of a file\n * Usage: head -n 5 file.txt\n */\nimport parseOptions from 'parser/option-parser';\nimport * as OutputFactory from 'emulator-output/output-factory';\nimport { trimFileContent } from 'commands/util/_head_tail_util.js';\nimport { resolvePath } from 'emulator-state/util';\n\nexport const optDef = {\n  '-n, --lines': '<count>'\n};\n\nexport default (state, commandOptions) => {\n  const {argv, options} = parseOptions(commandOptions, optDef);\n\n  if (argv.length === 0) {\n    return {};\n  }\n\n  const filePath = resolvePath(state, argv[0]);\n  const headTrimmingFn = (lines, lineCount) => lines.slice(0, lineCount);\n  const {content, err} = trimFileContent(\n    state.getFileSystem(), filePath, options, headTrimmingFn\n  );\n\n  if (err) {\n    return {\n      output: OutputFactory.makeErrorOutput(err)\n    };\n  }\n\n  return {\n    output: OutputFactory.makeTextOutput(content)\n  };\n};\n","/**\n * Lists or clears commands executed in the terminal\n * Usage: history -c\n */\nimport parseOptions from 'parser/option-parser';\nimport * as OutputFactory from 'emulator-output/output-factory';\nimport { create as createHistory } from 'emulator-state/history';\n\nconst clearStateHistory = (state) =>\n  state.setHistory(createHistory());\n\nconst stringifyStateHistory = (state) =>\n  state.getHistory().join('\\n');\n\nexport const optDef = {\n  '-c, --clear': '' // remove history entries\n};\n\nexport default (state, commandOptions) => {\n  const {options} = parseOptions(commandOptions, optDef);\n\n  if (options.clear) {\n    return {\n      state: clearStateHistory(state)\n    };\n  };\n\n  return {\n    output: OutputFactory.makeTextOutput(stringifyStateHistory(state))\n  };\n};\n","export const commandNames = [\n  'cat',\n  'cd',\n  'clear',\n  'cp',\n  'echo',\n  'head',\n  'history',\n  'ls',\n  'mkdir',\n  'printenv',\n  'pwd',\n  'rm',\n  'rmdir',\n  'tail',\n  'touch',\n  'whoami'\n];\n\nexport default commandNames.reduce((mapping, commandName) => {\n  return {\n    ...mapping,\n    [commandName]: {\n      function: require(`commands/${commandName}`).default,\n      optDef: require(`commands/${commandName}`).optDef\n    }\n  };\n}, {});\n","/**\n * Lists the contents of a directory\n * Usage: ls /folderName\n */\nimport parseOptions from 'parser/option-parser';\nimport * as DirectoryOp from 'fs/operations-with-permissions/directory-operations';\nimport * as EnvVariableUtil from 'emulator-state/environment-variables';\nimport * as PathUtil from 'fs/util/path-util';\nimport * as OutputFactory from 'emulator-output/output-factory';\nimport { Seq } from 'immutable';\n\nconst IMPLIED_DIRECTORY_ENTRIES = Seq(['.', '..']); // . = listed folder, .. = parent folder\n\n/**\n * Finds the directory path to list entries in.\n *\n * If ls has an argument passed in (example: ls /home/user/directory-to-list),\n * use the first argument as the directory to list.\n *\n * If ls is used without any path arguments (example: ls), the cwd (current\n * working directory) should be listed by ls.\n * @param  {Map}    envVariables  environment variables\n * @param  {array}  argv          argument vector\n * @return {string}               directory path to list\n */\nconst resolveDirectoryToList = (envVariables, argv) => {\n  const cwd = EnvVariableUtil.getEnvironmentVariable(envVariables, 'cwd');\n\n  if (argv.length > 0) {\n    return PathUtil.toAbsolutePath(argv[0], cwd);\n  }\n\n  return cwd;\n};\n\n/**\n * Alphabetically sorts the ls listing for display to the user\n * @param  {array}  listing list of files/directories to present to the user\n * @return {object}         return object of ls\n */\nconst makeSortedReturn = (listing) => {\n  const sortedListing = listing.sort();\n\n  return {\n    output: OutputFactory.makeTextOutput(sortedListing.join('\\n'))\n  };\n};\n\nconst removeHiddenFilesFilter = (record) => {\n  return !record.startsWith('.');\n};\n\nexport const optDef = {\n  '-a, --all': '', // Include hidden directory entries starting with .\n  '-A, --almost-all': '' // Do not include . and .. as implied directory entries\n};\n\nexport default (state, commandOptions) => {\n  const {options, argv} = parseOptions(commandOptions, optDef);\n  const dirPath = resolveDirectoryToList(state.getEnvVariables(), argv);\n  const {err, list: dirList} = DirectoryOp.listDirectory(state.getFileSystem(), dirPath);\n\n  if (err) {\n    return {\n      output: OutputFactory.makeErrorOutput(err)\n    };\n  }\n\n  if (options.all) {\n    return makeSortedReturn(IMPLIED_DIRECTORY_ENTRIES.concat(dirList));\n  } else if (options.almostAll) {\n    return makeSortedReturn(dirList);\n  }\n\n  return makeSortedReturn(dirList.filter(removeHiddenFilesFilter));\n};\n","/**\n * Creates an empty directory\n * Usage: mkdir /newDir\n */\nimport parseOptions from 'parser/option-parser';\nimport * as DirOp from 'fs/operations-with-permissions/directory-operations';\nimport * as OutputFactory from 'emulator-output/output-factory';\nimport * as FileUtil from 'fs/util/file-util';\nimport { resolvePath } from 'emulator-state/util';\n\nconst EMPTY_DIR = FileUtil.makeDirectory();\n\nexport const optDef = {};\n\nexport default (state, commandOptions) => {\n  const {argv} = parseOptions(commandOptions, optDef);\n\n  if (argv.length === 0) {\n    return {}; // do nothing if no arguments are given\n  }\n\n  const newFolderPath = resolvePath(state, argv[0]);\n  const {fs, err} = DirOp.addDirectory(state.getFileSystem(), newFolderPath, EMPTY_DIR, false);\n\n  if (err) {\n    return {\n      output: OutputFactory.makeErrorOutput(err)\n    };\n  }\n\n  return {\n    state: state.setFileSystem(fs)\n  };\n};\n","/**\n * Prints environment variable values\n * Usage: printenv cwd\n */\nimport parseOptions from 'parser/option-parser';\nimport * as OutputFactory from 'emulator-output/output-factory';\nimport { getEnvironmentVariable } from 'emulator-state/environment-variables';\n\n// Converts all key-value pairs of the environment variables to a printable format\nconst stringifyEnvVariables = (envVariables) => {\n  const outputs = envVariables.reduce((outputs, varVal, varKey) => [\n    ...outputs, `${varKey}=${varVal}`\n  ], []);\n\n  return outputs.join('\\n');\n};\n\nexport const optDef = {};\n\nexport default (state, commandOptions) => {\n  const {argv} = parseOptions(commandOptions, optDef);\n  const envVariables = state.getEnvVariables();\n\n  if (argv.length === 0) {\n    return {\n      output: OutputFactory.makeTextOutput(stringifyEnvVariables(envVariables))\n    };\n  }\n\n  // An argument has been passed to printenv; printenv will only print the first\n  // argument provided\n  const varValue = getEnvironmentVariable(envVariables, argv[0]);\n\n  if (varValue) {\n    return {\n      output: OutputFactory.makeTextOutput(varValue)\n    };\n  }\n\n  return {};\n};\n","/**\n * Prints out the current working directory (cwd).\n * Usage: pwd\n */\nimport * as OutputFactory from 'emulator-output/output-factory';\nimport { getEnvironmentVariable } from 'emulator-state/environment-variables';\n\nexport const optDef = {};\n\nexport default (state, commandOptions) => {\n  return {\n    output: OutputFactory.makeTextOutput(\n      getEnvironmentVariable(state.getEnvVariables(), 'cwd')\n    )\n  };\n};\n","/**\n * Removes a directory or a file\n * Usage: rm /existingDir\n */\nimport parseOptions from 'parser/option-parser';\nimport * as FileOp from 'fs/operations-with-permissions/file-operations';\nimport * as DirOp from 'fs/operations-with-permissions/directory-operations';\nimport * as OutputFactory from 'emulator-output/output-factory';\nimport { resolvePath } from 'emulator-state/util';\nimport { makeError, fsErrorType } from 'fs/fs-error';\n\nexport const optDef = {\n  '--no-preserve-root, --noPreserveRoot': '',\n  '-r, --recursive': ''\n};\n\nconst makeNoPathErrorOutput = () => {\n  const noSuchFileOrDirError = makeError(fsErrorType.NO_SUCH_FILE_OR_DIRECTORY);\n\n  return {\n    output: OutputFactory.makeErrorOutput(noSuchFileOrDirError)\n  };\n};\n\nexport default (state, commandOptions) => {\n  const {argv, options} = parseOptions(commandOptions, optDef);\n\n  if (argv.length === 0) {\n    return {}; // do nothing if no arguments are given\n  }\n\n  const deletionPath = resolvePath(state, argv[0]);\n  const fs = state.getFileSystem();\n\n  if (deletionPath === '/' && options.noPreserveRoot !== true) {\n    return {}; // do nothing as cannot safely delete the root\n  }\n\n  if (!fs.has(deletionPath)) {\n    return makeNoPathErrorOutput();\n  }\n\n  const {fs: deletedPathFS, err} = options.recursive === true ?\n    DirOp.deleteDirectory(fs, deletionPath, true) :\n    FileOp.deleteFile(fs, deletionPath);\n\n  if (err) {\n    return {\n      output: OutputFactory.makeErrorOutput(err)\n    };\n  }\n\n  return {\n    state: state.setFileSystem(deletedPathFS)\n  };\n};\n","/**\n * Removes an empty directory\n * Usage: rmdir /emptyDir\n */\nimport parseOptions from 'parser/option-parser';\nimport * as DirOp from 'fs/operations-with-permissions/directory-operations';\nimport * as OutputFactory from 'emulator-output/output-factory';\nimport { resolvePath } from 'emulator-state/util';\n\nexport const optDef = {};\n\nexport default (state, commandOptions) => {\n  const {argv} = parseOptions(commandOptions, optDef);\n\n  if (argv.length === 0) {\n    return {}; // do nothing if no arguments are given\n  }\n\n  const pathToDelete = resolvePath(state, argv[0]);\n  const {fs, err} = DirOp.deleteDirectory(state.getFileSystem(), pathToDelete, false);\n\n  if (err) {\n    return {\n      output: OutputFactory.makeErrorOutput(err)\n    };\n  }\n\n  return {\n    state: state.setFileSystem(fs)\n  };\n};\n","/**\n * Prints the last n lines of a file\n * Usage: tail -n 5 file.txt\n */\nimport parseOptions from 'parser/option-parser';\nimport * as OutputFactory from 'emulator-output/output-factory';\nimport { trimFileContent } from 'commands/util/_head_tail_util.js';\nimport { resolvePath } from 'emulator-state/util';\n\nexport const optDef = {\n  '-n, --lines': '<count>'\n};\n\nexport default (state, commandOptions) => {\n  const {argv, options} = parseOptions(commandOptions, optDef);\n\n  if (argv.length === 0) {\n    return {};\n  }\n\n  const filePath = resolvePath(state, argv[0]);\n  const tailTrimmingFn = (lines, lineCount) => lines.slice(-1 * lineCount);\n  const {content, err} = trimFileContent(\n    state.getFileSystem(), filePath, options, tailTrimmingFn\n  );\n\n  if (err) {\n    return {\n      output: OutputFactory.makeErrorOutput(err)\n    };\n  }\n\n  return {\n    output: OutputFactory.makeTextOutput(content)\n  };\n};\n","/**\n * Creates an empty file.\n * Usage: touch new_file.txt\n */\nimport parseOptions from 'parser/option-parser';\nimport * as FileOp from 'fs/operations-with-permissions/file-operations';\nimport * as OutputFactory from 'emulator-output/output-factory';\nimport * as FileUtil from 'fs/util/file-util';\nimport { resolvePath } from 'emulator-state/util';\n\nconst EMPTY_FILE = FileUtil.makeFile();\n\nexport const optDef = {};\n\nexport default (state, commandOptions) => {\n  const {argv} = parseOptions(commandOptions, optDef);\n\n  if (argv.length === 0) {\n    return {}; // do nothing if no arguments are given\n  }\n\n  const filePath = resolvePath(state, argv[0]);\n\n  if (state.getFileSystem().has(filePath)) {\n    return {}; // do nothing if already has a file at the provided path\n  }\n\n  const {fs, err} = FileOp.writeFile(state.getFileSystem(), filePath, EMPTY_FILE);\n\n  if (err) {\n    return {\n      output: OutputFactory.makeErrorOutput(err)\n    };\n  }\n\n  return {\n    state: state.setFileSystem(fs)\n  };\n};\n","import * as FileOp from 'fs/operations-with-permissions/file-operations';\nimport * as OutputFactory from 'emulator-output/output-factory';\n\nconst DEFAULT_LINE_COUNT = 10;\n\nexport const trimFileContent = (fs, filePath, options, trimmingFn) => {\n  const {file, err} = FileOp.readFile(fs, filePath);\n\n  if (err) {\n    return {\n      err: OutputFactory.makeErrorOutput(err)\n    };\n  };\n\n  const linesCount = options.lines ? Number(options.lines) : DEFAULT_LINE_COUNT;\n  const trimmedLines = trimmingFn(file.get('content').split('\\n'), linesCount);\n\n  return {\n    content: trimmedLines.join('\\n')\n  };\n};\n","/**\n * Prints the username of the logged in user\n * Usage: whoami\n */\nimport * as OutputFactory from 'emulator-output/output-factory';\nimport { getEnvironmentVariable } from 'emulator-state/environment-variables';\n\nconst FALLBACK_USERNAME = 'root';\n\nexport const optDef = {};\n\nexport default (state, commandOptions) => {\n  return {\n    output: OutputFactory.makeTextOutput(\n      getEnvironmentVariable(state.getEnvVariables(), 'user') || FALLBACK_USERNAME\n    )\n  };\n};\n","import * as OutputFactory from 'emulator-output/output-factory';\nimport * as OutputType from 'emulator-output/output-type';\n\nexport default {\n  OutputFactory, OutputType\n};\n","import { Record } from 'immutable';\nimport { HEADER_OUTPUT_TYPE, TEXT_OUTPUT_TYPE, TEXT_ERROR_OUTPUT_TYPE } from 'emulator-output/output-type';\n\n/**\n * Output from a command or emulator used for display to the user\n * @type {OutputRecord}\n */\nexport const OutputRecord = Record({\n  type: undefined,\n  content: undefined\n});\n\n/**\n * A terminal header containing metadata\n * @param  {string} cwd   the current working directory path\n * @return {OutputRecord} output record\n */\nexport const makeHeaderOutput = (cwd, command) => {\n  return new OutputRecord({\n    type: HEADER_OUTPUT_TYPE,\n    content: { cwd, command }\n  });\n};\n\n/**\n * Unstyled text output\n * @param  {string} content plain string output from a command or the emulator\n * @return {OutputRecord}   output record\n */\nexport const makeTextOutput = (content) => {\n  return new OutputRecord({\n    type: TEXT_OUTPUT_TYPE,\n    content\n  });\n};\n\n/**\n * Error text output\n * @param  {object} err internal error object\n * @return {OutputRecord}   output record\n */\nexport const makeErrorOutput = (err) => {\n  return new OutputRecord({\n    type: TEXT_ERROR_OUTPUT_TYPE,\n    content: `${err.source}: ${err.type}`\n  });\n};\n","/**\n * Types of output which can be used to display content to the user\n * @type {String}\n */\nexport const TEXT_OUTPUT_TYPE = 'TEXT_OUTPUT';\nexport const TEXT_ERROR_OUTPUT_TYPE = 'TEXT_ERROR_OUTPUT';\nexport const HEADER_OUTPUT_TYPE = 'HEADER_OUTPUT_TYPE';\n","import { Map } from 'immutable';\nimport { create as createCommandMapping } from 'emulator-state/command-mapping';\nimport { create as createEnvironmentVariables } from 'emulator-state/environment-variables';\nimport { create as createFileSystem } from 'emulator-state/file-system';\nimport { create as createHistory } from 'emulator-state/history';\nimport { create as createOutputs } from 'emulator-state/outputs';\n\nconst FS_KEY = 'fs';\nconst ENVIRONMENT_VARIABLES_KEY = 'environmentVariables';\nconst HISTORY_KEY = 'history';\nconst OUTPUTS_KEY = 'outputs';\nconst COMMAND_MAPPING_KEY = 'commandMapping';\n\nexport default class EmulatorState {\n  constructor(immutable) {\n    if (!immutable || !(immutable instanceof Map)) {\n      throw new Error('Do not use the constructor directly. Use the static create method.');\n    }\n\n    this._immutable = immutable;\n  }\n\n  /**\n   * Creates emulator state with defaults\n   * @return {EmulatorState} default emulator state\n   */\n  static createEmpty() {\n    return EmulatorState.create({});\n  }\n\n  /**\n   * Creates emulator state using the user's state components, or a default\n   * fallback if none is provided\n   * @param  {object} optionally contains each component as a key and the component as a value\n   * @return {EmulatorState}     emulator state\n   */\n  static create({\n    fs = createFileSystem(),\n    environmentVariables = createEnvironmentVariables(),\n    history = createHistory(),\n    outputs = createOutputs(),\n    commandMapping = createCommandMapping()\n  }) {\n    const stateMap = new Map({\n      [FS_KEY]: fs,\n      [ENVIRONMENT_VARIABLES_KEY]: environmentVariables,\n      [HISTORY_KEY]: history,\n      [OUTPUTS_KEY]: outputs,\n      [COMMAND_MAPPING_KEY]: commandMapping\n    });\n\n    return new EmulatorState(stateMap);\n  }\n\n  getFileSystem() {\n    return this.getImmutable().get(FS_KEY);\n  }\n\n  setFileSystem(newFileSystem) {\n    return new EmulatorState(\n      this.getImmutable().set(FS_KEY, newFileSystem)\n    );\n  }\n\n  getEnvVariables() {\n    return this.getImmutable().get(ENVIRONMENT_VARIABLES_KEY);\n  }\n\n  setEnvVariables(newEnvVariables) {\n    return new EmulatorState(\n      this.getImmutable().set(ENVIRONMENT_VARIABLES_KEY, newEnvVariables)\n    );\n  }\n\n  getHistory() {\n    return this.getImmutable().get(HISTORY_KEY);\n  }\n\n  setHistory(newHistory) {\n    return new EmulatorState(\n      this.getImmutable().set(HISTORY_KEY, newHistory)\n    );\n  }\n\n  getOutputs() {\n    return this.getImmutable().get(OUTPUTS_KEY);\n  }\n\n  setOutputs(newOutputs) {\n    return new EmulatorState(\n      this.getImmutable().set(OUTPUTS_KEY, newOutputs)\n    );\n  }\n\n  getCommandMapping() {\n    return this.getImmutable().get(COMMAND_MAPPING_KEY);\n  }\n\n  setCommandMapping(newCommandMapping) {\n    return new EmulatorState(\n      this.getImmutable().set(COMMAND_MAPPING_KEY, newCommandMapping)\n    );\n  }\n\n  getImmutable() {\n    return this._immutable;\n  }\n\n  toJS() {\n    return this._immutable.toJS();\n  }\n}\n","import { fromJS } from 'immutable';\nimport defaultCommandMapping from 'commands';\n\n/**\n * Links a command name to a function\n * @param  {Object} [commandMapping={}] default command map\n * @return {Map}                        command mapping\n */\nexport const create = (commandMapping = defaultCommandMapping) => {\n  for (const commandName of Object.keys(commandMapping)) {\n    const command = commandMapping[commandName];\n\n    if (!command.hasOwnProperty('function')) {\n      throw new Error(`Failed to create command mapping: missing command function for ${commandName}`);\n    }\n\n    if (!command.hasOwnProperty('optDef')) {\n      throw new Error(`Failed to create command mapping: missing option definition (optDef) for ${commandName}`);\n    }\n  }\n\n  return fromJS(commandMapping);\n};\n\n/**\n * Checks if a comand has been defined with a function in the command mapping\n * @param  {Map}     commandMapping command mapping\n * @param  {string}  commandName    command name to check if available\n * @return {Boolean}                true, if the command is available\n */\nexport const isCommandSet = (commandMapping, commandName) => {\n  return commandMapping.has(commandName);\n};\n\n/**\n * Set a command function with a key of the command name into the command mapping\n * @param  {Map}      commandMapping command mapping\n * @param  {string}   commandName    name of the function\n * @param  {function} commandFn      command function\n * @param  {object}   optDef         option definition (optional)\n * @return {Map}                     command mapping\n */\nexport const setCommand = (commandMapping, commandName, commandFn, optDef) => {\n  if (commandFn === undefined) {\n    throw new Error(`Cannot set ${commandName} command without function`);\n  }\n\n  if (optDef === undefined) {\n    throw new Error(`Cannot set ${commandName} command without optDef (pass in {} if the command takes no options)`);\n  }\n\n  return commandMapping.set(commandName, fromJS({\n    'function': commandFn,\n    'optDef': optDef\n  }));\n};\n\n/**\n * Removes a command name and its function from a command mapping\n * @param  {Map}    commandMapping command mapping\n * @param  {string} commandName    name of command to remove\n * @return {Map}                   command mapping\n */\nexport const unsetCommand = (commandMapping, commandName) => {\n  return commandMapping.delete(commandName);\n};\n\n/**\n * Gets the function of a command based on its command name (the key) from the\n * command mapping\n * @param  {Map}      commandMapping command mapping\n * @param  {string}   commandName    name of command\n * @return {function}                command function\n */\nexport const getCommandFn = (commandMapping, commandName) => {\n  if (commandMapping.has(commandName)) {\n    return commandMapping.get(commandName).get('function');\n  }\n\n  return undefined;\n};\n\n/**\n * Gets the option definition of a command based on its command name\n * @param  {Map}      commandMapping command mapping\n * @param  {string}   commandName    name of command\n * @return {Map}                     option definition\n */\nexport const getCommandOptDef = (commandMapping, commandName) => {\n  if (commandMapping.has(commandName)) {\n    return commandMapping.get(commandName).get('optDef');\n  }\n\n  return undefined;\n};\n\n/**\n * Gets command names\n * @param  {Map}      commandMapping command mapping\n * @return {Seq}                     sequence of command names\n */\nexport const getCommandNames = (commandMapping) => {\n  return commandMapping.keySeq();\n};\n","import { Map } from 'immutable';\n\n/**\n * Environment variable mapping containing arbitary data accessed by any\n * command or the emulator as a key-value pair\n * @param  {Object} [defaultVariables={}] default environment variables\n * @return {Map}                          environment variables\n */\nexport const create = (defaultVariables = {}, cwd = '/') => {\n  if (!cwd && !defaultVariables.hasOwnProperty('cwd')) {\n    throw new Error(\n      \"Failed to create environment variables. Missing 'cwd' (current working directory).\"\n    );\n  }\n\n  return Map({\n    'cwd': cwd, // cwd can be undefined as it can be set in defaultVariables\n    ...defaultVariables\n  });\n};\n\n/**\n * Gets the value of an environment variable\n * @param  {Map} environmentVariables environment variables\n * @param  {string} key               name of the environment variable\n * @return {T}                        the value stored in the environment variable\n */\nexport const getEnvironmentVariable = (environmentVariables, key) => {\n  return environmentVariables.get(key);\n};\n\n/**\n * Sets the value of an environment variable\n * @param {Map} environmentVariables environment variables\n * @param {string} key               name of the environment variable\n * @param {T} val                    value to store in the environment variable\n * @return {Map}                     environment variables\n */\nexport const setEnvironmentVariable = (environmentVariables, key, val) => {\n  return environmentVariables.set(key, val);\n};\n\n/**\n * Removes an environment variable\n * @param {Map} environmentVariables environment variables\n * @param {string} key               name of the environment variable\n * @return {Map}                     environment variables\n */\nexport const unsetEnvironmentVariable = (environmentVariables, key) => {\n  return environmentVariables.delete(key);\n};\n","import * as FileUtil from 'fs/util/file-util';\nimport * as DirOp from 'fs/operations/directory-operations';\nimport { fromJS } from 'immutable';\n\nconst DEFAULT_FILE_SYSTEM = {\n  '/': FileUtil.makeDirectory()\n};\n\n/**\n * Creates an immutable data structure for a file system\n * @param  {object} jsFs a file system in a simple JavaScript object\n * @return {Map}         an immutable file system\n */\nexport const create = (jsFs = DEFAULT_FILE_SYSTEM) => {\n  return DirOp.fillGaps(fromJS(jsFs));\n};\n","import { Stack } from 'immutable';\n\n/**\n * Creates a new history stack of previous commands that have been run in the\n * emulator\n * @param  {array}  [entries=[]] commands which have already been run (if any)\n * @return {Stack}               history list\n */\nexport const create = (entries = []) => {\n  return Stack.of(...entries);\n};\n\n/**\n * Stores a command in history in a stack (i.e., the latest command is on top of\n * the history stack)\n * @param  {Stack} history     history\n * @param  {string} commandRun the command to store\n * @return {Stack}             history\n */\nexport const recordCommand = (history, commandRun) => {\n  return history.push(commandRun);\n};\n","import * as CommandMapping from 'emulator-state/command-mapping';\nimport * as EnvironmentVariables from 'emulator-state/environment-variables';\nimport * as FileSystem from 'emulator-state/file-system';\nimport * as History from 'emulator-state/history';\nimport * as Outputs from 'emulator-state/outputs';\nimport EmulatorState from 'emulator-state/EmulatorState';\n\nexport default {\n  EmulatorState,\n  CommandMapping,\n  EnvironmentVariables,\n  FileSystem,\n  History,\n  Outputs\n};\n","import { List } from 'immutable';\nimport { Record } from 'immutable';\n\n/**\n * Stores outputs from the emulator (e.g. text to display after running a command)\n * @param  {Array}  [outputs=[]] Previous outputs\n * @return {List}               List of outputs objects\n */\nexport const create = (outputs = []) => {\n  return List(outputs);\n};\n\n/**\n * Adds a new output record\n * @param {List}         outputs      outputs list\n * @param {OutputRecord} outputRecord record conforming to output schema\n */\nexport const addRecord = (outputs, outputRecord) => {\n  if (!Record.isRecord(outputRecord)) {\n    throw new Error('Only records of type OutputRecord can be added to outputs');\n  }\n\n  if (!outputRecord.has('type')) {\n    throw new Error('Output record must include a type');\n  }\n\n  if (!outputRecord.has('content')) {\n    throw new Error('Output record must include content');\n  }\n\n  return outputs.push(outputRecord);\n};\n","import * as EnvVariableUtil from 'emulator-state/environment-variables';\nimport * as PathUtil from 'fs/util/path-util';\n\n/**\n * Converts a given path to an absolute path using the\n * current working directory\n * @param  {EmulatorState} state emulator state\n * @param  {string} path         path (relative or absolute)\n * @return {string}              absolute path\n */\nexport const resolvePath = (state, path) => {\n  const cwd = EnvVariableUtil.getEnvironmentVariable(\n    state.getEnvVariables(), 'cwd'\n  );\n\n  return PathUtil.toAbsolutePath(path, cwd);\n};\n","import * as PathUtil from 'fs/util/path-util';\nimport * as GlobUtil from 'fs/util/glob-util';\nimport { isCommandSet, getCommandNames, getCommandOptDef } from 'emulator-state/command-mapping';\n\n/**\n * Suggest command names\n * @param  {Map}    cmdMapping     command mapping\n * @param  {string} partialStr     partial user input of a command\n * @return {array}                 list of possible text suggestions\n */\nexport const suggestCommands = (cmdMapping, partialStr) => {\n  const commandNameSeq = getCommandNames(cmdMapping);\n\n  return [...GlobUtil.globSeq(commandNameSeq, `${partialStr}*`)];\n};\n\n/**\n * Suggest command options\n * @param  {Map}    cmdMapping     command mapping\n * @param  {string} commandName    name of the command user is running\n * @param  {string} partialStr     partial user input of a command (excluding the command name)\n * @return {array}                 list of possible text suggestions\n */\nexport const suggestCommandOptions = (cmdMapping, commandName, partialStr) => {\n  if (!isCommandSet(cmdMapping, commandName)) {\n    return [];\n  }\n\n  const optDefSeq = getCommandOptDef(cmdMapping, commandName)\n    .keySeq()\n    .flatMap(opts =>\n      opts.split(',').map(opt => opt.trim())\n    );\n\n  return [...GlobUtil.globSeq(optDefSeq, `${partialStr}*`)];\n};\n\n/**\n * Suggest file and folder names from partially completed user input\n * @param  {Map}    fileSystem file system\n * @param  {string} cwd        current working directory\n * @param  {string} partialStr partial string to base suggestions on (excluding the command name)\n * @return {array}             list of possible text suggestions\n */\nexport const suggestFileSystemNames = (fileSystem, cwd, partialStr) => {\n  const path = PathUtil.toAbsolutePath(partialStr, cwd);\n\n  // complete name of a folder or file\n  const completeNamePattern = `${path}*`;\n  // complete child folder name\n  const completeSubfolderPattern = path === '/' ? '/*' : `${path}*/*`;\n  // only complete child folders when the path ends with / (which marks a directory path)\n  const globPattern = partialStr.endsWith('/') ? completeSubfolderPattern : completeNamePattern;\n\n  const childPaths = GlobUtil.globPaths(fileSystem, globPattern);\n\n  if (PathUtil.isAbsPath(partialStr)) {\n    return [...childPaths]; // absolute paths\n  }\n\n  return [...childPaths.map(path => {\n    const pathPartsWithoutTail = PathUtil.toPathParts(partialStr).slice(0, -1);\n    const newTail = PathUtil.getLastPathPart(path);\n\n    return PathUtil.toPath(pathPartsWithoutTail.concat(newTail));\n  })]; // relative paths\n};\n","import { makeError, emulatorErrorType } from 'emulator/emulator-error';\nimport { makeErrorOutput } from 'emulator-output/output-factory';\nimport * as CommandMappingUtil from 'emulator-state/command-mapping';\n\n/**\n * Makes an internal emulator error for emulator output. Error output may be\n * visible to the user.\n * @param  {string} errorType type of emulator error\n * @return {object}           error output object\n */\nexport const makeRunnerErrorOutput = (errorType) => {\n  return makeErrorOutput(makeError(errorType));\n};\n\n/**\n * Runs a command and returns an object containing either:\n * - outputs from running the command, or\n * - new emulator state after running the command, or\n * - new emulator state and output after running the command\n *\n * The form of the object from this function is as follows:\n * {\n *   outputs: [optional array of output records]\n *   output: [optional single output record]\n *   state: [optional Map]\n * }\n * @param  {Map}    commandMapping command mapping from emulator state\n * @param  {string} commandName    name of command to run\n * @param  {array}  commandArgs    commands to provide to the command function\n * @param  {string}  errorStr      a default string to be displayed if no command is found\n * @return {object}                outputs and/or new state of the emulator\n */\nexport const run = (commandMapping, commandName, commandArgs, errorStr=emulatorErrorType.COMMAND_NOT_FOUND) => {\n\n  const notFoundCallback = () => ({\n    output: makeRunnerErrorOutput(errorStr)\n  })\n\n  if (!CommandMappingUtil.isCommandSet(commandMapping, commandName)) {\n    return notFoundCallback(...commandArgs);\n  }\n\n  const command = CommandMappingUtil.getCommandFn(commandMapping, commandName);\n\n  try {\n    return command(...commandArgs); // run extracted command from the mapping\n  } catch (fatalCommandError) {\n    return {\n      output: makeRunnerErrorOutput(emulatorErrorType.UNEXPECTED_COMMAND_FAILURE)\n    };\n  }\n};\n","/**\n * Emulator error type\n * @type {Object}\n */\nexport const emulatorErrorType = {\n  COMMAND_NOT_FOUND: 'Command not found',\n  UNEXPECTED_COMMAND_FAILURE: 'Unhandled command error'\n};\n\n/**\n * Creates an error to display to the user originating from the emulator\n * @param  {string} emulatorErrorType  file system error type\n * @param  {string} [message='']       optional metadata for developers about the error\n * @return {object}                    internal error object\n */\nexport const makeError = (emulatorErrorType, message = '') => {\n  return {\n    source: 'emulator',\n    type: emulatorErrorType,\n    message\n  };\n};\n","import * as CommandRunner from 'emulator/command-runner';\nimport parseCommands from 'parser/command-parser';\nimport { makeHeaderOutput, makeTextOutput } from 'emulator-output/output-factory';\nimport { recordCommand } from 'emulator-state/history';\nimport { getEnvironmentVariable } from 'emulator-state/environment-variables';\nimport { suggestCommands, suggestCommandOptions, suggestFileSystemNames } from 'emulator/auto-complete';\nimport { List } from 'immutable';\n\nexport default class Emulator {\n  /**\n   * Completes user input if there is one, and only one, suggestion.\n   *\n   * If there are no suggestions or more than one suggestion, the original\n   * user input will be returned.\n   * @param  {EmulatorState} state      emulator state\n   * @param  {string}        partialStr partial user input to the emulator\n   * @return {string}                   completed user input when one suggest (or, otherwsie, the original input)\n   */\n  autocomplete(state, partialStr) {\n    const suggestions = this.suggest(state, partialStr);\n\n    if (suggestions.length !== 1) {\n      return partialStr;\n    }\n\n    const strParts = new List(partialStr.split(' '));\n    const autocompletedText = suggestions[0];\n\n    return strParts\n      .update(-1, lastVal => autocompletedText)\n      .join(' ');\n  };\n\n  /**\n   * Suggest what the user will type next\n   * @param  {EmulatorState} state      emulator state\n   * @param  {string}        partialStr partial user input of a command\n   * @return {array}                    list of possible text suggestions\n   */\n  suggest(state, partialStr) {\n    partialStr = this._trimLeadingSpace(partialStr);\n\n    const lastPartialChar = partialStr.slice(-1);\n    const isTypingNewPart = lastPartialChar === ' ';\n\n    const strParts = partialStr.trim().split(' ');\n    const {start: cmdName, end: lastTextEntered} = this._getBoundaryWords(strParts);\n\n    if (!isTypingNewPart && strParts.length === 1) {\n      return suggestCommands(state.getCommandMapping(), cmdName);\n    }\n\n    const strToComplete = isTypingNewPart ? '' : lastTextEntered;\n    const cwd = getEnvironmentVariable(state.getEnvVariables(), 'cwd');\n\n    return [\n      ...suggestCommandOptions(state.getCommandMapping(), cmdName, strToComplete),\n      ...suggestFileSystemNames(state.getFileSystem(), cwd, strToComplete)\n    ];\n  };\n\n  _trimLeadingSpace(str) {\n    return str.replace(/^\\s+/g, '');\n  };\n\n  _getBoundaryWords(strParts) {\n    return {\n      start: strParts[0],\n      end: strParts[strParts.length - 1]\n    };\n  };\n\n  /**\n   * Runs emulator command\n   * @param  {EmulatorState}  state                   emulator state before running command\n   * @param  {string}         str                     command string to execute\n   * @param  {Array}          [executionListeners=[]] list of plugins to notify while running the command\n   * @param  {string}         errorStr                string to display on unrecognized command\n   * @return {EmulatorState}                          updated emulator state after running command\n   */\n  execute(state, str, executionListeners = [], errorStr) {\n    for (const executionListener of executionListeners) {\n      executionListener.onExecuteStarted(state, str);\n    }\n\n    state = this._addHeaderOutput(state, str);\n\n    if (str.trim() === '') {\n      // empty command string\n      state = this._addCommandOutputs(state, [makeTextOutput('')]);\n    } else {\n      state = this._addCommandToHistory(state, str);\n      state = this._updateStateByExecution(state, str, errorStr);\n    }\n\n    for (const executionListener of executionListeners) {\n      executionListener.onExecuteCompleted(state);\n    }\n\n    return state;\n  };\n\n  _updateStateByExecution(state, commandStrToExecute, errorStr) {\n    for (const {commandName, commandOptions} of parseCommands(commandStrToExecute)) {\n      const commandMapping = state.getCommandMapping();\n      const commandArgs = [state, commandOptions];\n\n      const {state: nextState, output, outputs} = CommandRunner.run(\n        commandMapping, commandName, commandArgs, errorStr\n      );\n\n      if (nextState) {\n        state = nextState;\n      }\n\n      if (output) {\n        state = this._addCommandOutputs(state, [output]);\n      } else if (outputs) {\n        state = this._addCommandOutputs(state, outputs);\n      }\n    }\n\n    return state;\n  }\n\n  _addCommandToHistory(state, command) {\n    const history = state.getHistory();\n\n    return state.setHistory(recordCommand(history, command));\n  }\n\n  _addHeaderOutput(state, commandStr) {\n    const envVariables = state.getEnvVariables();\n    const cwd = getEnvironmentVariable(envVariables, 'cwd');\n\n    return this._addCommandOutputs(state, [makeHeaderOutput(cwd, commandStr)]);\n  }\n\n  /**\n   * Appends outputs to the internal state of outputs\n   * @param {List} outputs list of outputs\n   */\n  _addCommandOutputs(state, outputs) {\n    for (const output of outputs) {\n      const outputs = state.getOutputs();\n\n      state = state.setOutputs(outputs.push(output));\n    }\n\n    return state;\n  }\n}\n","/**\n * Makes a stack iterator for a point in history.\n *\n * Can go backwards and forwards through the history and is bounded by\n * the size of the stack.\n */\nexport default class BoundedHistoryIterator {\n  constructor(historyStack, index = 0) {\n    this.historyStack = historyStack.push('');\n    this.index = index;\n  }\n\n  hasUp() {\n    return this.index + 1 < this.historyStack.size;\n  }\n\n  up() {\n    if (this.hasUp()) {\n      this.index++;\n    }\n\n    return this.historyStack.get(this.index);\n  }\n\n  hasDown() {\n    return this.index - 1 >= 0;\n  }\n\n  down() {\n    if (this.hasDown()) {\n      this.index--;\n    }\n\n    return this.historyStack.get(this.index);\n  }\n};\n","import BoundedHistoryIterator from 'emulator/plugins/BoundedHistoryIterator';\n\nexport default class HistoryKeyboardPlugin {\n  constructor(state) {\n    this._nullableHistoryIterator = null;\n    this.historyStack = state.getHistory();\n  }\n\n  // Plugin contract\n  onExecuteStarted(state, str) {\n    // no-op\n  }\n\n  // Plugin contract\n  onExecuteCompleted(state) {\n    this._nullableHistoryIterator = null;\n    this.historyStack = state.getHistory();\n  }\n\n  // Plugin API\n  completeUp() {\n    this.createHistoryIteratorIfNull();\n\n    return this._nullableHistoryIterator.up();\n  }\n\n  completeDown() {\n    this.createHistoryIteratorIfNull();\n\n    return this._nullableHistoryIterator.down();\n  }\n\n  // Private methods\n  createHistoryIteratorIfNull() {\n    if (!this._nullableHistoryIterator) {\n      this._nullableHistoryIterator = new BoundedHistoryIterator(\n        this.historyStack\n      );\n    }\n  }\n}\n","/**\n * File system error types\n * @type {Object}\n */\nexport const fsErrorType = {\n  FILE_EXISTS: 'File exists',\n  DIRECTORY_EXISTS: 'Directory exists',\n  DIRECTORY_NOT_EMPTY: 'Directory not empty',\n  NO_SUCH_FILE_OR_DIRECTORY: 'No such file or directory',\n  NO_SUCH_FILE: 'No such file',\n  NO_SUCH_DIRECTORY: 'No such directory',\n  FILE_OR_DIRECTORY_EXISTS: 'File or directory exists',\n  IS_A_DIRECTORY: 'Is a directory',\n  NOT_A_DIRECTORY: 'Not a directory',\n  PERMISSION_DENIED: 'Permission denied',\n  OTHER: 'Other'\n};\n\n/**\n * Create a non-fatal file system error object\n *\n * For fatal errors do not use this. Throw an error instead.\n * @param  {string} fsErrorType  file system error type\n * @param  {string} [message=''] optional metadata for developers about the error\n * @return {object}              internal error object\n */\nexport const makeError = (fsErrorType, message = '') => {\n  return {\n    source: 'fs',\n    type: fsErrorType,\n    message\n  };\n};\n","import * as DirOp from './operations-with-permissions/directory-operations';\nimport * as FileOp from './operations-with-permissions/file-operations';\n\nexport default {\n  DirOp,\n  FileOp\n};\n","/**\n * Adds modification permissions to directory operations by wrapping\n * directory operations\n */\nimport * as DirectoryOperations from 'fs/operations/directory-operations';\nimport * as PermissionUtil from 'fs/util/permission-util';\nimport { makeError, fsErrorType } from 'fs/fs-error';\n\nconst makeDirectoryOperationPermissionError = (message = 'Cannot modify directory') => {\n  return {\n    err: makeError(fsErrorType.PERMISSION_DENIED, message)\n  };\n};\n\nexport const hasDirectory = (...args) => {\n  return DirectoryOperations.hasDirectory(...args);\n};\n\nexport const listDirectory = (...args) => {\n  return DirectoryOperations.listDirectory(...args);\n};\n\nexport const listDirectoryFiles = (...args) => {\n  return DirectoryOperations.listDirectoryFiles(...args);\n};\n\nexport const listDirectoryFolders = (...args) => {\n  return DirectoryOperations.listDirectoryFolders(...args);\n};\n\nexport const addDirectory = (fs, path, ...args) => {\n  if (!PermissionUtil.canModifyPath(fs, path)) {\n    return makeDirectoryOperationPermissionError();\n  }\n\n  return DirectoryOperations.addDirectory(fs, path, ...args);\n};\n\nexport const copyDirectory = (fs, srcPath, destPath, ...args) => {\n  if (!PermissionUtil.canModifyPath(fs, srcPath)) {\n    return makeDirectoryOperationPermissionError('Cannot modify source directory');\n  }\n\n  if (!PermissionUtil.canModifyPath(fs, destPath)) {\n    return makeDirectoryOperationPermissionError('Cannot modify dest directory');\n  }\n\n  return DirectoryOperations.copyDirectory(fs, srcPath, destPath, ...args);\n};\n\nexport const deleteDirectory = (fs, path, ...args) => {\n  if (!PermissionUtil.canModifyPath(fs, path)) {\n    return makeDirectoryOperationPermissionError();\n  }\n\n  return DirectoryOperations.deleteDirectory(fs, path, ...args);\n};\n\nexport const renameDirectory = (fs, currentPath, newPath) => {\n  if (!PermissionUtil.canModifyPath(fs, currentPath)) {\n    return makeDirectoryOperationPermissionError('Cannot modify current path');\n  }\n\n  if (!PermissionUtil.canModifyPath(fs, newPath)) {\n    return makeDirectoryOperationPermissionError('Cannot modify renamed path');\n  }\n\n  return DirectoryOperations.renameDirectory(fs, currentPath, newPath);\n};\n","/**\n * Adds modification permissions to file operations by wrapping\n * file operations\n */\nimport * as PermissionUtil from 'fs/util/permission-util';\nimport * as FileOperations from 'fs/operations/file-operations';\nimport { makeError, fsErrorType } from 'fs/fs-error';\n\nconst makeFileOperationPermissionError = (message = 'Cannot modify file') => {\n  return {\n    err: makeError(fsErrorType.PERMISSION_DENIED, message)\n  };\n};\n\nexport const hasFile = (...args) => {\n  return FileOperations.hasFile(...args);\n};\n\nexport const readFile = (...args) => {\n  return FileOperations.readFile(...args);\n};\n\nexport const writeFile = (fs, filePath, ...args) => {\n  if (!PermissionUtil.canModifyPath(fs, filePath)) {\n    return makeFileOperationPermissionError();\n  }\n\n  return FileOperations.writeFile(fs, filePath, ...args);\n};\n\nexport const copyFile = (fs, sourcePath, destPath) => {\n  if (!PermissionUtil.canModifyPath(fs, sourcePath)) {\n    return makeFileOperationPermissionError('Cannot modify source file');\n  }\n\n  if (!PermissionUtil.canModifyPath(fs, destPath)) {\n    return makeFileOperationPermissionError('Cannot modify destination file');\n  }\n\n  return FileOperations.copyFile(fs, sourcePath, destPath);\n};\n\nexport const deleteFile = (fs, filePath) => {\n  if (!PermissionUtil.canModifyPath(fs, filePath)) {\n    return makeFileOperationPermissionError();\n  }\n\n  return FileOperations.deleteFile(fs, filePath);\n};\n","import * as GlobUtil from 'fs/util/glob-util';\nimport * as DirOp from 'fs/operations/directory-operations';\nimport * as FileOp from 'fs/operations/file-operations';\nimport * as PathUtil from 'fs/util/path-util';\nimport { makeError, fsErrorType } from 'fs/fs-error';\n\n/**\n * Adds a file or directory to a path\n * @param {Map}     fs                     file system\n * @param {string}  pathToAdd              path to add the file or directory to\n * @param {string}  fsElementToAdd         file or directory map\n * @param {Boolean} [addParentPaths=false] true, if path parent directories should\n *                                         be made (if they don't exist)\n * @return {object}                        file system or error\n */\nexport const add = (fs, pathToAdd, fsElementToAdd, addParentPaths = false) => {\n  if (fs.has(pathToAdd)) {\n    return {\n      err: makeError(fsErrorType.FILE_OR_DIRECTORY_EXISTS)\n    };\n  }\n\n  const parentPaths = PathUtil.getPathBreadCrumbs(pathToAdd).slice(0, -1);\n\n  for (const parentPath of parentPaths) {\n    if (FileOp.hasFile(fs, parentPath)) {\n      return {\n        err: makeError(fsErrorType.NOT_A_DIRECTORY,\n          `Cannot add path to a file: ${parentPath}`)\n      };\n    }\n\n    if (!fs.has(parentPath) && !addParentPaths) {\n      return {\n        err: makeError(fsErrorType.NO_SUCH_DIRECTORY,\n          `Parent directory does not exist: ${parentPath}`)\n      };\n    }\n  }\n\n  const addedDirectoryFs = fs.set(pathToAdd, fsElementToAdd);\n\n  return {\n    fs: addParentPaths ? DirOp.fillGaps(addedDirectoryFs) : addedDirectoryFs\n  };\n};\n\n/**\n * Removes a file or directory from a path\n * @param  {Map}     fs                                  file system\n * @param  {string}  pathToRemove                        removes the path\n * @param  {Boolean} [isNonEmptyDirectoryRemovable=true] true if non-empty paths can be removed\n * @return {object}                                      file system or error\n */\nexport const remove = (fs, pathToRemove, isNonEmptyDirectoryRemovable = true) => {\n  if (!fs.has(pathToRemove)) {\n    return {\n      err: makeError(fsErrorType.NO_SUCH_FILE_OR_DIRECTORY)\n    };\n  }\n\n  const childPathPattern = pathToRemove === '/' ? '/**' : `${pathToRemove}/**`;\n  const childPaths = GlobUtil.globPaths(fs, childPathPattern);\n\n  if (!isNonEmptyDirectoryRemovable && !childPaths.isEmpty()) {\n    return {\n      err: makeError(fsErrorType.DIRECTORY_NOT_EMPTY)\n    };\n  }\n\n  return {\n    fs: fs.removeAll(childPaths.concat(pathToRemove))\n  };\n};\n","import * as FileUtil from 'fs/util/file-util';\nimport * as GlobUtil from 'fs/util/glob-util';\nimport * as PathUtil from 'fs/util/path-util';\nimport * as BaseOp from 'fs/operations/base-operations';\nimport { makeError, fsErrorType } from 'fs/fs-error';\nimport { hasFile } from 'fs/operations/file-operations';\n\nconst onlyFilesFilter = fs => path => FileUtil.isFile(fs.get(path));\nconst onlyDirectoriesFilter = fs => path => FileUtil.isDirectory(fs.get(path));\n\n/**\n * Fill file system gaps with empty directories.\n *\n * EXPLANATION:\n * A file system can be left in a state where there the directory structure\n * is incomplete and there may be illogical gaps in the structure after\n * manually creating or editing the file system.\n *\n * For example, we might have a file system that looks like this after manually\n * adding a directory of '/a/b/c':\n *\n * {\n *  '/': {..}\n *  '/a/b/c': {..}\n * }\n *\n * As a result of the operation, we're missing directories of '/a' and '/a/b'.\n * We can fill these missing directory gaps to get a properly formed directory\n * structure:\n *\n * {\n *  '/': {..}\n *  '/a': {..}\n *  '/a/b': {..}\n *  '/a/b/c': {..}\n * }\n * @param  {Map}    fs   file system with gaps in directory structure\n * @return {Map}         file system without directory gaps\n */\nexport const fillGaps = (fs) => {\n  const emptyDirectory = FileUtil.makeDirectory();\n\n  const directoryGapPaths = fs.keySeq() // sequence of paths\n    .flatMap(path => PathUtil.getPathBreadCrumbs(path))\n    .filter(path => !fs.has(path));\n\n  return fs.withMutations((fs) => {\n    for (const directoryGapPath of directoryGapPaths) {\n      fs.set(directoryGapPath, emptyDirectory);\n    }\n  });\n};\n\n/**\n * Check if a directory exists in the file system\n * @param  {Map}     fs   file system\n * @param  {string}  path path to check if is a directory\n * @return {boolean}      true, if the directory exists\n */\nexport const hasDirectory = (fs, path) => {\n  return fs.has(path) && FileUtil.isDirectory(fs.get(path));\n};\n\n/**\n * Creates a list of file names\n * @param  {Map}    fs   file system\n * @param  {string} path directory path to list files in\n * @return {object}      list of file names or an error\n */\nexport const listDirectoryFiles = (fs, path) => {\n  if (hasFile(fs, path)) {\n    return {\n      err: makeError(fsErrorType.FILE_EXISTS, 'File exists at path')\n    };\n  }\n\n  if (!hasDirectory(fs, path)) {\n    return {\n      err: makeError(fsErrorType.NO_SUCH_DIRECTORY, 'Cannot list files in non-existent directory')\n    };\n  };\n\n  const filesPattern = path === '/' ? '/*' : `${path}/*`;\n\n  return {\n    list: GlobUtil.captureGlobPaths(fs, filesPattern, onlyFilesFilter(fs))\n  };\n};\n\n/**\n * Creates a list of folder names inside the current directory.\n * @param  {Map}    fs   file system\n * @param  {string} path path to list directories in\n * @return {object}      list of directories or an error\n */\nexport const listDirectoryFolders = (fs, path, isTrailingSlashAppended = true) => {\n  if (hasFile(fs, path)) {\n    return {\n      err: makeError(fsErrorType.FILE_EXISTS, 'File exists at path')\n    };\n  }\n\n  if (!hasDirectory(fs, path)) {\n    return {\n      err: makeError(fsErrorType.NO_SUCH_DIRECTORY, 'Cannot list folders in non-existent directory')\n    };\n  };\n\n  const foldersPattern = path === '/' ? '/*' : `${path}/*`;\n  const folderNames = GlobUtil.captureGlobPaths(\n    fs, foldersPattern, onlyDirectoriesFilter(fs)\n  );\n\n  if (isTrailingSlashAppended) {\n    return {\n      list: folderNames.map(folderName => `${folderName}/`)\n    };\n  }\n\n  return {\n    list: folderNames\n  };\n};\n\n/**\n * Lists files and folders in a directory\n * @param  {Map}     fs                                      file system\n * @param  {string}  path                                    directory path to list files and folders in\n * @param  {boolean} [addTrailingSlash=true]                 add a / to the end of folder names\n * @return {object}                                          file system or an error\n */\nexport const listDirectory = (fs, path, addTrailingSlash = true) => {\n  const {err: listFileErr, list: fileList} = listDirectoryFiles(fs, path);\n  const {err: listFolderErr, list: folderList} = listDirectoryFolders(fs, path, addTrailingSlash);\n\n  if (listFileErr || listFolderErr) {\n    return {\n      err: listFileErr ? listFileErr : listFolderErr\n    };\n  };\n\n  return {\n    list: fileList.concat(folderList)\n  };\n};\n\n/**\n * Adds a directory to the file system\n * @param {Map}     fs                           file system\n * @param {string}  path                         path to add a directory to\n * @param {Map}     dir                          directory\n * @param {boolean} [isReplaceExistingDir=false] whether a directory can be overwritten if it already exists\n * @return {object}                              file system or an error\n */\nexport const addDirectory = (fs, path, dir, addParentPaths = true) => {\n  if (hasFile(fs, PathUtil.getPathParent(path))) {\n    return {\n      err: makeError(fsErrorType.FILE_EXISTS, 'File exists at path')\n    };\n  }\n\n  return BaseOp.add(fs, path, dir, addParentPaths);\n};\n\n/**\n * Private helper function implementing rules for replacing a source path (the path\n * we're copying from) with a destination path (the path we're copying to). Note\n * that in our file system:\n * - A file cannot overwrite a directory,\n * - a directory cannot overwrite a file, and\n * - a file/directory can overwrite a file/directory.\n * @param  {Map}       fs      file system\n * @param  {Sequence}  pathSeq sequence of source and destination paths\n * @return {Boolean}           true, if a source path can replace a destination path\n */\nconst isPathTypeMatching = (fs, pathSeq) => {\n  for (const [srcPath, destPath] of pathSeq) {\n    if (fs.has(destPath)) {\n      if (hasFile(fs, srcPath) && hasDirectory(fs, destPath)) {\n        // Cannot overwrite a file with a directory\n        return false;\n      } else if (hasDirectory(fs, srcPath) && hasFile(fs, destPath)) {\n        // Cannot overwrite a directory with a file\n        return false;\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Copies a directory (and all directories included inside that directory)\n * from a source directory to a destination directory\n *\n * If the destination doesn't exist, it can be created.\n *\n * The source and destination must be a directory and not a file.\n * @param  {Map}     fs                             file system\n * @param  {string}  srcPath                        directory path to copy from\n * @param  {string}  destPath                       directory path to copy to\n * @return {object}                                 file system or an error\n */\nexport const copyDirectory = (fs, srcPath, destPath, overwrite = true) => {\n  if (!hasDirectory(fs, srcPath)) {\n    return {\n      err: makeError(fsErrorType.NO_SUCH_DIRECTORY, 'Source directory does not exist')\n    };\n  };\n\n  if (!hasDirectory(fs, destPath)) {\n    return {\n      err: makeError(fsErrorType.NO_SUCH_DIRECTORY, 'Destination directory does not exist')\n    };\n  };\n\n  const srcChildPattern = srcPath === '/' ? '/**' : `${srcPath}/**`;\n  const srcPaths = GlobUtil.globPaths(fs, srcChildPattern);\n  const srcSubPaths = GlobUtil.captureGlobPaths(fs, srcChildPattern);\n  const destPaths = srcSubPaths.map(path => path === '/' ? destPath : `${destPath}/${path}`);\n\n  if (!isPathTypeMatching(fs, srcPaths.zip(destPaths))) {\n    return {\n      err: makeError(fsErrorType.OTHER, 'Cannot overwrite a directory with file OR a file with directory')\n    };\n  }\n\n  return {\n    fs: fs.withMutations((newFs) => {\n      for (const [srcPath, destPath] of srcPaths.zip(destPaths)) {\n        if (!fs.has(destPath) || overwrite) {\n          newFs.set(destPath, fs.get(srcPath));\n        }\n      }\n    })\n  };\n};\n\n/**\n * Remove a directory from a file system\n * @param  {Map}     fs                                   file system\n * @param  {string}  pathToDelete                         directory path to delete\n * @param  {Boolean} [isNonEmptyDirectoryRemovable=false] whether directories with files in them can be removed\n * @return {object}                                       file system or an error\n */\nexport const deleteDirectory = (fs, pathToDelete, isNonEmptyDirectoryRemovable = false) => {\n  if (hasFile(fs, pathToDelete)) {\n    return {\n      err: makeError(fsErrorType.FILE_EXISTS, 'File exists at path')\n    };\n  }\n\n  if (!hasDirectory(fs, pathToDelete)) {\n    return {\n      err: makeError(fsErrorType.NO_SUCH_DIRECTORY, `No such directory: ${pathToDelete}`)\n    };\n  };\n\n  return BaseOp.remove(fs, pathToDelete, isNonEmptyDirectoryRemovable);\n};\n\n/**\n * Rename a directory\n * @param  {Map}    fs          file system\n * @param  {string} currentPath directory path to rename (and hence remove)\n * @param  {string} newPath     path to place the renamed directory\n * @return {object}             file system or an error\n */\nexport const renameDirectory = (fs, currentPath, newPath) => {\n  const {err, fs: copiedFS} = copyDirectory(fs, currentPath, newPath, true);\n\n  if (err) {\n    return {err};\n  }\n\n  return deleteDirectory(copiedFS, currentPath, true);\n};\n","import * as PathUtil from 'fs/util/path-util';\nimport * as BaseOp from 'fs/operations/base-operations';\nimport { isFile } from 'fs/util/file-util';\nimport { hasDirectory } from 'fs/operations/directory-operations';\nimport { makeError, fsErrorType } from 'fs/fs-error';\n\n/**\n * Checks whether a file exists\n * @param  {Map}     fs       file system\n * @param  {string}  dirPath  directory of the file to check for existence\n * @param  {string}  fileName file name to check for existence\n * @return {Boolean}          true, if the file exists\n */\nexport const hasFile = (fs, filePath) => {\n  if (fs.has(filePath)) {\n    const possibleFile = fs.get(filePath);\n\n    return isFile(possibleFile);\n  }\n  return false;\n};\n\n/**\n * Get a file from the file system\n * @param  {Map}    fs       file system\n * @param  {string} filePath path to file to read\n * @return {object}          file system or an error\n */\nexport const readFile = (fs, filePath) => {\n  if (hasDirectory(fs, filePath)) {\n    return {\n      err: makeError(fsErrorType.IS_A_DIRECTORY)\n    };\n  }\n\n  if (!hasFile(fs, filePath)) {\n    return {\n      err: makeError(fsErrorType.NO_SUCH_FILE)\n    };\n  }\n\n  return {\n    file: fs.get(filePath)\n  };\n};\n\n/**\n * Write a new file to the file system\n * @param  {Map}     fs                            file system\n * @param  {string}  filePath                      path to new file\n * @param  {Map}     file                          the new file\n * @return {object}                                file system or an error\n */\nexport const writeFile = (fs, filePath, file) => {\n  return BaseOp.add(fs, filePath, file);\n};\n\n/**\n * Copies a file from a source directory to a destination directory\n * @param  {Map}    fs           file system\n * @param  {string} sourcePath   path to source file (to copy from)\n * @param  {string} destPath     path to destination file (to copy to)\n * @return {object}              file system or an error\n */\nexport const copyFile = (fs, sourcePath, destPath) => {\n  if (!hasFile(fs, sourcePath)) {\n    return {\n      err: makeError(fsErrorType.NO_SUCH_FILE, 'Source file does not exist')\n    };\n  }\n\n  const pathParent = PathUtil.getPathParent(destPath);\n\n  if (!hasDirectory(fs, pathParent)) {\n    return {\n      err: makeError(fsErrorType.NO_SUCH_DIRECTORY, 'Destination directory does not exist')\n    };\n  }\n\n  if (hasDirectory(fs, destPath)) {\n    // Copying file to directory without specifying the filename explicitly\n    const sourceFileName = PathUtil.getLastPathPart(sourcePath);\n\n    destPath = destPath === '/' ? `/${sourceFileName}` : `${destPath}/${sourceFileName}`;\n  }\n\n  return {\n    fs: fs.set(destPath, fs.get(sourcePath))\n  };\n};\n\n/**\n * Removes a file from the file system\n * @param  {Map}    fs       file system\n * @param  {string} filePath path to the file to delete\n * @return {object}          file system or an error\n */\nexport const deleteFile = (fs, filePath) => {\n  if (hasDirectory(fs, filePath)) {\n    return {\n      err: makeError(fsErrorType.IS_A_DIRECTORY)\n    };\n  }\n\n  if (!hasFile(fs, filePath)) {\n    return {\n      err: makeError(fsErrorType.NO_SUCH_FILE)\n    };\n  }\n\n  return BaseOp.remove(fs, filePath);\n};\n","import { fromJS } from 'immutable';\n\n/**\n * Checks if a JavaScript object is a file object\n * @param  {object}  json potential file\n * @return {boolean}      whether the object conforms to the file schema\n */\nexport const isFile = (map) => {\n  return map.has('content');\n};\n\n/**\n * Checks if a JavaScript object is a directory object\n * @param  {object}  json potential directory\n * @return {boolean}      whether the object conforms to the directory schema\n */\nexport const isDirectory = (map) => {\n  return !map.has('content');\n};\n\n/**\n * Makes an file conforming to the file schema\n * @param  {object} content  content of the file\n * @return {object}          new file\n */\nexport const makeFile = (content = '', metadata = {}) => {\n  return fromJS({\n    content,\n    ...metadata\n  });\n};\n\n/**\n * Makes an directory conforming to the directory schema\n * @param  {object} children child directories or files\n * @return {object}          new directory\n */\nexport const makeDirectory = (metadata = {}) => {\n  return fromJS({\n    ...metadata\n  });\n};\n","import minimatch from 'minimatch';\nimport capture from 'minimatch-capture';\nimport { List } from 'immutable';\n\nconst GLOB_OPTIONS = {dot: true};\n\nexport const glob = (str, globPattern) => {\n  return minimatch(str, globPattern, GLOB_OPTIONS);\n};\n\nexport const globSeq = (seq, globPattern) => {\n  return seq.filter((path) => minimatch(path, globPattern, GLOB_OPTIONS));\n};\n\nexport const globPaths = (fs, globPattern) => {\n  return globSeq(fs.keySeq(), globPattern);\n};\n\nexport const captureGlobPaths = (fs, globPattern, filterCondition = (path) => true) => {\n  return fs.keySeq().reduce((captures, path) => {\n    if (filterCondition(path)) {\n      const pathCaptures = capture(path, globPattern, GLOB_OPTIONS);\n\n      if (pathCaptures) {\n        return captures.concat(pathCaptures);\n      }\n    }\n\n    return captures;\n  }, List());\n};\n","/**\n * Tests if a path is a trailing path.\n *\n * A trailing path ends with a trailing slash (/) and excludes the root\n * directory (/).\n * @param  {string}  path path with or without a trailing slash\n * @return {Boolean}      true, if the path is a trailing path\n */\nexport const isTrailingPath = (path) => {\n  return path.endsWith('/') && path !== '/';\n};\n\n/**\n * Removes a trailing slash (/) from a path\n * @param  {string} path path with or without a trailing /\n * @return {string}      path without trailing /\n */\nexport const removeTrailingSeparator = (path) => {\n  if (path.endsWith('/') && path !== '/') {\n    return path.slice(0, -1);\n  }\n  return path;\n};\n\n/**\n * Tests if a path is absolute\n * @param  {string}  path\n * @return {boolean}\n */\nexport const isAbsPath = (path) => {\n  return path.startsWith('/');\n};\n\n/**\n * Converts a path to an ordered array of folders and files.\n *\n * Example: Parts of '/a/b/c/e.txt' has parts of ['/', 'a', 'b', 'c', 'e.txt']\n *\n * A relative path splits parts at /. An absolute path splits at / and also\n * considers the root directory (/) as a part of the path.\n * @param  {string} path [description]\n * @return {array}       list of path parts\n */\nexport const toPathParts = (path) => {\n  if (path === '/') {\n    return ['/'];\n  };\n\n  path = removeTrailingSeparator(path);\n  const pathParts = path.split('/');\n\n  if (isAbsPath(path)) {\n    const [, ...nonRootPathParts] = pathParts;\n\n    return ['/', ...nonRootPathParts];\n  }\n\n  return pathParts;\n};\n\n/**\n * Converts path parts back to a path\n * @param  {array} pathParts path parts\n * @return {string}          path\n */\nexport const toPath = (pathParts) => {\n  if (pathParts[0] === '/') { // absolute path\n    const [, ...nonRootPathParts] = pathParts;\n\n    return `/${nonRootPathParts.join('/')}`;\n  }\n\n  return pathParts.join('/');\n};\n\n/**\n * Find breadcrumb paths, i.e. all paths that need to be walked to get to\n * the specified path\n * Example: /a/b/c will have breadcrumb paths of '/', '/a', '/a/b', '/a/b/c'\n * @param  {string} path path to a directory\n * @return {array}       list of paths that lead up to a path\n */\nexport const getPathBreadCrumbs = (path) => {\n  const pathParts = toPathParts(path);\n\n  if (pathParts.length <= 1) {\n    return ['/'];\n  }\n\n  const [, secondPathPart, ...pathPartsWithoutRoot] = pathParts;\n\n  return pathPartsWithoutRoot.reduce((breadCrumbs, pathPart) => {\n    const previousBreadCrumb = breadCrumbs[breadCrumbs.length - 1];\n\n    return [...breadCrumbs, `${previousBreadCrumb}/${pathPart}`];\n  }, ['/', `/${secondPathPart}`]);\n};\n\n/**\n * Removes the file name from the end of a file path, returning the path to the\n * directory of the file\n * @param  {string} filePath path which ends with a file name\n * @return {string}          directory path\n */\nexport const getPathParent = (filePath) => {\n  if (filePath === '/') {\n    return '/';\n  }\n\n  const pathParts = toPathParts(filePath); // converts path string to array\n  const pathPartsWithoutFileName = pathParts.slice(0, -1); // removes last element of array\n\n  return toPath(pathPartsWithoutFileName);\n};\n\n/**\n * Extracts the file name from the end of the file path\n * @param  {string} filePath path which ends with a file name\n * @return {string}          file name from the path\n */\nexport const getLastPathPart = (filePath) => {\n  const pathParts = toPathParts(filePath); // converts path string to array\n\n  return pathParts[pathParts.length - 1];\n};\n\n/**\n * Extracts the file name and directory path from a file path\n * @param  {string} filePath path which ends with a file name\n * @return {object}          object with directory and file name\n */\nexport const splitFilePath = (filePath) => {\n  return {\n    'dirPath': getPathParent(filePath),\n    'fileName': getLastPathPart(filePath)\n  };\n};\n\n/**\n * Converts a relative path to an absolute path\n * @param  {string} relativePath\n * @param  {string} cwd          current working directory\n * @return {string}              absolute path\n */\nconst GO_UP = '..';\nconst CURRENT_DIR = '.';\nconst isStackAtRootDirectory = stack => stack.length === 1 && stack[0] === '/';\n\nexport const toAbsolutePath = (relativePath, cwd) => {\n  relativePath = removeTrailingSeparator(relativePath);\n  const pathStack = isAbsPath(relativePath) ? [] : toPathParts(cwd);\n\n  for (const pathPart of toPathParts(relativePath)) {\n    if (pathPart === GO_UP) {\n      if (!isStackAtRootDirectory(pathStack)) {\n        pathStack.pop();\n      }\n    } else if (pathPart !== CURRENT_DIR) {\n      pathStack.push(pathPart);\n    }\n  }\n\n  return toPath(pathStack);\n};\n","import * as PathUtil from 'fs/util/path-util';\n\nconst DEFAULT_PERMISSION = true;\n\n/**\n * Checks if a single path can be modified by checking the 'canModify' key held\n * in the path.\n *\n * This does NOT check parents of the path.\n * @param  {Map}     fs   file system\n * @param  {string}  path path to check for modification permission\n * @return {Boolean}      true, if a single path can be modified\n */\nconst isModificationAllowed = (fs, path) => {\n  const directory = fs.get(path, null);\n\n  if (directory) {\n    const canModify = directory.get('canModify', DEFAULT_PERMISSION);\n\n    if (!canModify) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * Checks if a path and its parents can be modified.\n * @param  {Map}     fs   file systems\n * @param  {String}  path path to a directory or file\n * @return {Boolean}      true, if the path and its parents can be modified\n */\nexport const canModifyPath = (fs, path) => {\n  const breadCrumbPaths = PathUtil.getPathBreadCrumbs(path);\n\n  for (const breadCrumbPath of breadCrumbPaths) {\n    if (!isModificationAllowed(fs, breadCrumbPath)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n","import Emulator from 'emulator';\nimport HistoryKeyboardPlugin from 'emulator/plugins/HistoryKeyboardPlugin';\nimport { EmulatorState, CommandMapping, EnvironmentVariables, FileSystem, History, Outputs } from 'emulator-state';\nimport { OutputFactory, OutputType } from 'emulator-output';\nimport { DirOp, FileOp } from 'fs';\nimport { OptionParser } from 'parser';\nimport defaultCommandMapping from 'commands';\n\n// Any class/function exported here forms part of the emulator API\nexport {\n  Emulator, HistoryKeyboardPlugin,\n  defaultCommandMapping,\n  EmulatorState, CommandMapping, EnvironmentVariables, FileSystem, History, Outputs, // state API\n  OutputFactory, OutputType, // output API\n  DirOp, FileOp, // file system API\n  OptionParser // parser API\n};\n","/**\n * Removes excess whitespace (> 1 space) from edges of string and inside string.\n * @param  {string} str string\n * @return {string}     string without > 1 space of whitespace\n */\nconst removeExcessWhiteSpace = str => str.trim().replace(/\\s\\s+/g, ' ');\n\n/**\n * Places the command name and each following argument into a list\n * @param  {string} command sh command\n * @return {array}          command name and arguments (if any)\n */\nconst toCommandParts = command => removeExcessWhiteSpace(command).split(/\\s/);\n\n/**\n * Creates a list of commands split into the command name and arguments\n * @param  {string} commands command input\n * @return {array}           list of parsed command\n */\nexport const parseCommands = (commands) => {\n  return commands\n    .split(/&&|;/) // split command delimiters: `&&` and `;`\n    .map((command) => toCommandParts(command))\n    .map(([commandName, ...commandOptions]) => ({\n      commandName,\n      commandOptions\n    }));\n};\n\nexport default parseCommands;\n","import * as OptionParser from 'parser/option-parser';\n\nexport default {\n  OptionParser\n};\n","import getOpts from 'get-options';\n\n/**\n * Creates an options object with bindings based on optDefs\n * @param  {string} commandOptions string representation of command arguments\n * @param  {object} optDef         see get-options documentation for schema details\n * @return {object}                options object\n */\nexport const parseOptions = (commandOptions, optDef) =>\n  getOpts(commandOptions, optDef, {\n    noAliasPropagation: 'first-only'\n  });\n\nexport default parseOptions;\n"],"sourceRoot":""}